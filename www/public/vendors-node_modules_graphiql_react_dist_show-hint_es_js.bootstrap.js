"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwww"] = self["webpackChunkwww"] || []).push([["vendors-node_modules_graphiql_react_dist_show-hint_es_js"],{

/***/ "./node_modules/@graphiql/react/dist/show-hint.es.js":
/*!***********************************************************!*\
  !*** ./node_modules/@graphiql/react/dist/show-hint.es.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   s: () => (/* binding */ dt)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codemirror.es2.js */ \"./node_modules/@graphiql/react/dist/codemirror.es2.js\");\nvar rt = Object.defineProperty;\nvar p = (H, A) => rt(H, \"name\", { value: A, configurable: !0 });\n\nfunction ht(H, A) {\n  for (var r = 0; r < A.length; r++) {\n    const w = A[r];\n    if (typeof w != \"string\" && !Array.isArray(w)) {\n      for (const v in w)\n        if (v !== \"default\" && !(v in H)) {\n          const b = Object.getOwnPropertyDescriptor(w, v);\n          b && Object.defineProperty(H, v, b.get ? b : {\n            enumerable: !0,\n            get: () => w[v]\n          });\n        }\n    }\n  }\n  return Object.freeze(Object.defineProperty(H, Symbol.toStringTag, { value: \"Module\" }));\n}\np(ht, \"_mergeNamespaces\");\nvar at = { exports: {} };\n(function(H, A) {\n  (function(r) {\n    r((0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.r)());\n  })(function(r) {\n    var w = \"CodeMirror-hint\", v = \"CodeMirror-hint-active\";\n    r.showHint = function(t, e, i) {\n      if (!e)\n        return t.showHint(i);\n      i && i.async && (e.async = !0);\n      var n = { hint: e };\n      if (i)\n        for (var s in i)\n          n[s] = i[s];\n      return t.showHint(n);\n    }, r.defineExtension(\"showHint\", function(t) {\n      t = Z(this, this.getCursor(\"start\"), t);\n      var e = this.listSelections();\n      if (!(e.length > 1)) {\n        if (this.somethingSelected()) {\n          if (!t.hint.supportsSelection)\n            return;\n          for (var i = 0; i < e.length; i++)\n            if (e[i].head.line != e[i].anchor.line)\n              return;\n        }\n        this.state.completionActive && this.state.completionActive.close();\n        var n = this.state.completionActive = new b(this, t);\n        n.options.hint && (r.signal(this, \"startCompletion\", this), n.update(!0));\n      }\n    }), r.defineExtension(\"closeHint\", function() {\n      this.state.completionActive && this.state.completionActive.close();\n    });\n    function b(t, e) {\n      if (this.cm = t, this.options = e, this.widget = null, this.debounce = 0, this.tick = 0, this.startPos = this.cm.getCursor(\"start\"), this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length, this.options.updateOnCursorActivity) {\n        var i = this;\n        t.on(\"cursorActivity\", this.activityFunc = function() {\n          i.cursorActivity();\n        });\n      }\n    }\n    p(b, \"Completion\");\n    var J = window.requestAnimationFrame || function(t) {\n      return setTimeout(t, 1e3 / 60);\n    }, Q = window.cancelAnimationFrame || clearTimeout;\n    b.prototype = {\n      close: function() {\n        this.active() && (this.cm.state.completionActive = null, this.tick = null, this.options.updateOnCursorActivity && this.cm.off(\"cursorActivity\", this.activityFunc), this.widget && this.data && r.signal(this.data, \"close\"), this.widget && this.widget.close(), r.signal(this.cm, \"endCompletion\", this.cm));\n      },\n      active: function() {\n        return this.cm.state.completionActive == this;\n      },\n      pick: function(t, e) {\n        var i = t.list[e], n = this;\n        this.cm.operation(function() {\n          i.hint ? i.hint(n.cm, t, i) : n.cm.replaceRange(\n            _(i),\n            i.from || t.from,\n            i.to || t.to,\n            \"complete\"\n          ), r.signal(t, \"pick\", i), n.cm.scrollIntoView();\n        }), this.options.closeOnPick && this.close();\n      },\n      cursorActivity: function() {\n        this.debounce && (Q(this.debounce), this.debounce = 0);\n        var t = this.startPos;\n        this.data && (t = this.data.from);\n        var e = this.cm.getCursor(), i = this.cm.getLine(e.line);\n        if (e.line != this.startPos.line || i.length - e.ch != this.startLen - this.startPos.ch || e.ch < t.ch || this.cm.somethingSelected() || !e.ch || this.options.closeCharacters.test(i.charAt(e.ch - 1)))\n          this.close();\n        else {\n          var n = this;\n          this.debounce = J(function() {\n            n.update();\n          }), this.widget && this.widget.disable();\n        }\n      },\n      update: function(t) {\n        if (this.tick != null) {\n          var e = this, i = ++this.tick;\n          U(this.options.hint, this.cm, this.options, function(n) {\n            e.tick == i && e.finishUpdate(n, t);\n          });\n        }\n      },\n      finishUpdate: function(t, e) {\n        this.data && r.signal(this.data, \"update\");\n        var i = this.widget && this.widget.picked || e && this.options.completeSingle;\n        this.widget && this.widget.close(), this.data = t, t && t.list.length && (i && t.list.length == 1 ? this.pick(t, 0) : (this.widget = new K(this, t), r.signal(t, \"shown\")));\n      }\n    };\n    function Z(t, e, i) {\n      var n = t.options.hintOptions, s = {};\n      for (var c in D)\n        s[c] = D[c];\n      if (n)\n        for (var c in n)\n          n[c] !== void 0 && (s[c] = n[c]);\n      if (i)\n        for (var c in i)\n          i[c] !== void 0 && (s[c] = i[c]);\n      return s.hint.resolve && (s.hint = s.hint.resolve(t, e)), s;\n    }\n    p(Z, \"parseOptions\");\n    function _(t) {\n      return typeof t == \"string\" ? t : t.text;\n    }\n    p(_, \"getText\");\n    function tt(t, e) {\n      var i = {\n        Up: function() {\n          e.moveFocus(-1);\n        },\n        Down: function() {\n          e.moveFocus(1);\n        },\n        PageUp: function() {\n          e.moveFocus(-e.menuSize() + 1, !0);\n        },\n        PageDown: function() {\n          e.moveFocus(e.menuSize() - 1, !0);\n        },\n        Home: function() {\n          e.setFocus(0);\n        },\n        End: function() {\n          e.setFocus(e.length - 1);\n        },\n        Enter: e.pick,\n        Tab: e.pick,\n        Esc: e.close\n      }, n = /Mac/.test(navigator.platform);\n      n && (i[\"Ctrl-P\"] = function() {\n        e.moveFocus(-1);\n      }, i[\"Ctrl-N\"] = function() {\n        e.moveFocus(1);\n      });\n      var s = t.options.customKeys, c = s ? {} : i;\n      function o(u, l) {\n        var a;\n        typeof l != \"string\" ? a = /* @__PURE__ */ p(function(S) {\n          return l(S, e);\n        }, \"bound\") : i.hasOwnProperty(l) ? a = i[l] : a = l, c[u] = a;\n      }\n      if (p(o, \"addBinding\"), s)\n        for (var f in s)\n          s.hasOwnProperty(f) && o(f, s[f]);\n      var h = t.options.extraKeys;\n      if (h)\n        for (var f in h)\n          h.hasOwnProperty(f) && o(f, h[f]);\n      return c;\n    }\n    p(tt, \"buildKeyMap\");\n    function B(t, e) {\n      for (; e && e != t; ) {\n        if (e.nodeName.toUpperCase() === \"LI\" && e.parentNode == t)\n          return e;\n        e = e.parentNode;\n      }\n    }\n    p(B, \"getHintElement\");\n    function K(t, e) {\n      this.id = \"cm-complete-\" + Math.floor(Math.random(1e6)), this.completion = t, this.data = e, this.picked = !1;\n      var i = this, n = t.cm, s = n.getInputField().ownerDocument, c = s.defaultView || s.parentWindow, o = this.hints = s.createElement(\"ul\");\n      o.setAttribute(\"role\", \"listbox\"), o.setAttribute(\"aria-expanded\", \"true\"), o.id = this.id;\n      var f = t.cm.options.theme;\n      o.className = \"CodeMirror-hints \" + f, this.selectedHint = e.selectedHint || 0;\n      for (var h = e.list, u = 0; u < h.length; ++u) {\n        var l = o.appendChild(s.createElement(\"li\")), a = h[u], S = w + (u != this.selectedHint ? \"\" : \" \" + v);\n        a.className != null && (S = a.className + \" \" + S), l.className = S, u == this.selectedHint && l.setAttribute(\"aria-selected\", \"true\"), l.id = this.id + \"-\" + u, l.setAttribute(\"role\", \"option\"), a.render ? a.render(l, e, a) : l.appendChild(s.createTextNode(a.displayText || _(a))), l.hintId = u;\n      }\n      var x = t.options.container || s.body, y = n.cursorCoords(t.options.alignWithWord ? e.from : null), k = y.left, O = y.bottom, j = !0, F = 0, E = 0;\n      if (x !== s.body) {\n        var nt = [\"absolute\", \"relative\", \"fixed\"].indexOf(c.getComputedStyle(x).position) !== -1, W = nt ? x : x.offsetParent, M = W.getBoundingClientRect(), z = s.body.getBoundingClientRect();\n        F = M.left - z.left - W.scrollLeft, E = M.top - z.top - W.scrollTop;\n      }\n      o.style.left = k - F + \"px\", o.style.top = O - E + \"px\";\n      var N = c.innerWidth || Math.max(s.body.offsetWidth, s.documentElement.offsetWidth), L = c.innerHeight || Math.max(s.body.offsetHeight, s.documentElement.offsetHeight);\n      x.appendChild(o), n.getInputField().setAttribute(\"aria-autocomplete\", \"list\"), n.getInputField().setAttribute(\"aria-owns\", this.id), n.getInputField().setAttribute(\"aria-activedescendant\", this.id + \"-\" + this.selectedHint);\n      var m = t.options.moveOnOverlap ? o.getBoundingClientRect() : new DOMRect(), q = t.options.paddingForScrollbar ? o.scrollHeight > o.clientHeight + 1 : !1, T;\n      setTimeout(function() {\n        T = n.getScrollInfo();\n      });\n      var st = m.bottom - L;\n      if (st > 0) {\n        var P = m.bottom - m.top, ot = y.top - (y.bottom - m.top);\n        if (ot - P > 0)\n          o.style.top = (O = y.top - P - E) + \"px\", j = !1;\n        else if (P > L) {\n          o.style.height = L - 5 + \"px\", o.style.top = (O = y.bottom - m.top - E) + \"px\";\n          var V = n.getCursor();\n          e.from.ch != V.ch && (y = n.cursorCoords(V), o.style.left = (k = y.left - F) + \"px\", m = o.getBoundingClientRect());\n        }\n      }\n      var C = m.right - N;\n      if (q && (C += n.display.nativeBarWidth), C > 0 && (m.right - m.left > N && (o.style.width = N - 5 + \"px\", C -= m.right - m.left - N), o.style.left = (k = y.left - C - F) + \"px\"), q)\n        for (var I = o.firstChild; I; I = I.nextSibling)\n          I.style.paddingRight = n.display.nativeBarWidth + \"px\";\n      if (n.addKeyMap(this.keyMap = tt(t, {\n        moveFocus: function(d, g) {\n          i.changeActive(i.selectedHint + d, g);\n        },\n        setFocus: function(d) {\n          i.changeActive(d);\n        },\n        menuSize: function() {\n          return i.screenAmount();\n        },\n        length: h.length,\n        close: function() {\n          t.close();\n        },\n        pick: function() {\n          i.pick();\n        },\n        data: e\n      })), t.options.closeOnUnfocus) {\n        var Y;\n        n.on(\"blur\", this.onBlur = function() {\n          Y = setTimeout(function() {\n            t.close();\n          }, 100);\n        }), n.on(\"focus\", this.onFocus = function() {\n          clearTimeout(Y);\n        });\n      }\n      n.on(\"scroll\", this.onScroll = function() {\n        var d = n.getScrollInfo(), g = n.getWrapperElement().getBoundingClientRect();\n        T || (T = n.getScrollInfo());\n        var X = O + T.top - d.top, R = X - (c.pageYOffset || (s.documentElement || s.body).scrollTop);\n        if (j || (R += o.offsetHeight), R <= g.top || R >= g.bottom)\n          return t.close();\n        o.style.top = X + \"px\", o.style.left = k + T.left - d.left + \"px\";\n      }), r.on(o, \"dblclick\", function(d) {\n        var g = B(o, d.target || d.srcElement);\n        g && g.hintId != null && (i.changeActive(g.hintId), i.pick());\n      }), r.on(o, \"click\", function(d) {\n        var g = B(o, d.target || d.srcElement);\n        g && g.hintId != null && (i.changeActive(g.hintId), t.options.completeOnSingleClick && i.pick());\n      }), r.on(o, \"mousedown\", function() {\n        setTimeout(function() {\n          n.focus();\n        }, 20);\n      });\n      var $ = this.getSelectedHintRange();\n      return ($.from !== 0 || $.to !== 0) && this.scrollToActive(), r.signal(e, \"select\", h[this.selectedHint], o.childNodes[this.selectedHint]), !0;\n    }\n    p(K, \"Widget\"), K.prototype = {\n      close: function() {\n        if (this.completion.widget == this) {\n          this.completion.widget = null, this.hints.parentNode && this.hints.parentNode.removeChild(this.hints), this.completion.cm.removeKeyMap(this.keyMap);\n          var t = this.completion.cm.getInputField();\n          t.removeAttribute(\"aria-activedescendant\"), t.removeAttribute(\"aria-owns\");\n          var e = this.completion.cm;\n          this.completion.options.closeOnUnfocus && (e.off(\"blur\", this.onBlur), e.off(\"focus\", this.onFocus)), e.off(\"scroll\", this.onScroll);\n        }\n      },\n      disable: function() {\n        this.completion.cm.removeKeyMap(this.keyMap);\n        var t = this;\n        this.keyMap = { Enter: function() {\n          t.picked = !0;\n        } }, this.completion.cm.addKeyMap(this.keyMap);\n      },\n      pick: function() {\n        this.completion.pick(this.data, this.selectedHint);\n      },\n      changeActive: function(t, e) {\n        if (t >= this.data.list.length ? t = e ? this.data.list.length - 1 : 0 : t < 0 && (t = e ? 0 : this.data.list.length - 1), this.selectedHint != t) {\n          var i = this.hints.childNodes[this.selectedHint];\n          i && (i.className = i.className.replace(\" \" + v, \"\"), i.removeAttribute(\"aria-selected\")), i = this.hints.childNodes[this.selectedHint = t], i.className += \" \" + v, i.setAttribute(\"aria-selected\", \"true\"), this.completion.cm.getInputField().setAttribute(\"aria-activedescendant\", i.id), this.scrollToActive(), r.signal(this.data, \"select\", this.data.list[this.selectedHint], i);\n        }\n      },\n      scrollToActive: function() {\n        var t = this.getSelectedHintRange(), e = this.hints.childNodes[t.from], i = this.hints.childNodes[t.to], n = this.hints.firstChild;\n        e.offsetTop < this.hints.scrollTop ? this.hints.scrollTop = e.offsetTop - n.offsetTop : i.offsetTop + i.offsetHeight > this.hints.scrollTop + this.hints.clientHeight && (this.hints.scrollTop = i.offsetTop + i.offsetHeight - this.hints.clientHeight + n.offsetTop);\n      },\n      screenAmount: function() {\n        return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n      },\n      getSelectedHintRange: function() {\n        var t = this.completion.options.scrollMargin || 0;\n        return {\n          from: Math.max(0, this.selectedHint - t),\n          to: Math.min(this.data.list.length - 1, this.selectedHint + t)\n        };\n      }\n    };\n    function et(t, e) {\n      if (!t.somethingSelected())\n        return e;\n      for (var i = [], n = 0; n < e.length; n++)\n        e[n].supportsSelection && i.push(e[n]);\n      return i;\n    }\n    p(et, \"applicableHelpers\");\n    function U(t, e, i, n) {\n      if (t.async)\n        t(e, n, i);\n      else {\n        var s = t(e, i);\n        s && s.then ? s.then(n) : n(s);\n      }\n    }\n    p(U, \"fetchHints\");\n    function it(t, e) {\n      var i = t.getHelpers(e, \"hint\"), n;\n      if (i.length) {\n        var s = /* @__PURE__ */ p(function(c, o, f) {\n          var h = et(c, i);\n          function u(l) {\n            if (l == h.length)\n              return o(null);\n            U(h[l], c, f, function(a) {\n              a && a.list.length > 0 ? o(a) : u(l + 1);\n            });\n          }\n          p(u, \"run\"), u(0);\n        }, \"resolved\");\n        return s.async = !0, s.supportsSelection = !0, s;\n      } else\n        return (n = t.getHelper(t.getCursor(), \"hintWords\")) ? function(c) {\n          return r.hint.fromList(c, { words: n });\n        } : r.hint.anyword ? function(c, o) {\n          return r.hint.anyword(c, o);\n        } : function() {\n        };\n    }\n    p(it, \"resolveAutoHints\"), r.registerHelper(\"hint\", \"auto\", {\n      resolve: it\n    }), r.registerHelper(\"hint\", \"fromList\", function(t, e) {\n      var i = t.getCursor(), n = t.getTokenAt(i), s, c = r.Pos(i.line, n.start), o = i;\n      n.start < i.ch && /\\w/.test(n.string.charAt(i.ch - n.start - 1)) ? s = n.string.substr(0, i.ch - n.start) : (s = \"\", c = i);\n      for (var f = [], h = 0; h < e.words.length; h++) {\n        var u = e.words[h];\n        u.slice(0, s.length) == s && f.push(u);\n      }\n      if (f.length)\n        return { list: f, from: c, to: o };\n    }), r.commands.autocomplete = r.showHint;\n    var D = {\n      hint: r.hint.auto,\n      completeSingle: !0,\n      alignWithWord: !0,\n      closeCharacters: /[\\s()\\[\\]{};:>,]/,\n      closeOnPick: !0,\n      closeOnUnfocus: !0,\n      updateOnCursorActivity: !0,\n      completeOnSingleClick: !0,\n      container: null,\n      customKeys: null,\n      extraKeys: null,\n      paddingForScrollbar: !0,\n      moveOnOverlap: !0\n    };\n    r.defineOption(\"hintOptions\", null);\n  });\n})();\nvar G = at.exports;\nconst ft = /* @__PURE__ */ (0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.g)(G), dt = /* @__PURE__ */ ht({\n  __proto__: null,\n  default: ft\n}, [G]);\n\n//# sourceMappingURL=show-hint.es.js.map\n\n\n//# sourceURL=webpack://www/./node_modules/@graphiql/react/dist/show-hint.es.js?");

/***/ })

}]);