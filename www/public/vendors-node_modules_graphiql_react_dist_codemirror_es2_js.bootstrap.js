"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwww"] = self["webpackChunkwww"] || []).push([["vendors-node_modules_graphiql_react_dist_codemirror_es2_js"],{

/***/ "./node_modules/@graphiql/react/dist/codemirror.es2.js":
/*!*************************************************************!*\
  !*** ./node_modules/@graphiql/react/dist/codemirror.es2.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: () => (/* binding */ hu),\n/* harmony export */   r: () => (/* binding */ cu)\n/* harmony export */ });\nvar su = Object.defineProperty;\nvar u = (He, Dn) => su(He, \"name\", { value: Dn, configurable: !0 });\nvar uu = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof __webpack_require__.g < \"u\" ? __webpack_require__.g : typeof self < \"u\" ? self : {};\nfunction hu(He) {\n  return He && He.__esModule && Object.prototype.hasOwnProperty.call(He, \"default\") ? He.default : He;\n}\nu(hu, \"getDefaultExportFromCjs\");\nvar Mn = { exports: {} }, Ko;\nfunction cu() {\n  return Ko || (Ko = 1, function(He, Dn) {\n    (function(ie, Lr) {\n      He.exports = Lr();\n    })(uu, function() {\n      var ie = navigator.userAgent, Lr = navigator.platform, Fe = /gecko\\/\\d/i.test(ie), Nn = /MSIE \\d/.test(ie), An = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(ie), kr = /Edge\\/(\\d+)/.exec(ie), O = Nn || An || kr, I = O && (Nn ? document.documentMode || 6 : +(kr || An)[1]), ne = !kr && /WebKit\\//.test(ie), _o = ne && /Qt\\/\\d+\\.\\d+/.test(ie), Tr = !kr && /Chrome\\//.test(ie), we = /Opera\\//.test(ie), Mr = /Apple Computer/.test(navigator.vendor), Xo = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(ie), Yo = /PhantomJS/.test(ie), Ut = Mr && (/Mobile\\/\\w+/.test(ie) || navigator.maxTouchPoints > 2), Dr = /Android/.test(ie), Kt = Ut || Dr || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ie), me = Ut || /Mac/.test(Lr), qo = /\\bCrOS\\b/.test(ie), Zo = /win/i.test(Lr), et = we && ie.match(/Version\\/(\\d*\\.\\d*)/);\n      et && (et = Number(et[1])), et && et >= 15 && (we = !1, ne = !0);\n      var On = me && (_o || we && (et == null || et < 12.11)), ci = Fe || O && I >= 9;\n      function mt(e) {\n        return new RegExp(\"(^|\\\\s)\" + e + \"(?:$|\\\\s)\\\\s*\");\n      }\n      u(mt, \"classTest\");\n      var tt = /* @__PURE__ */ u(function(e, t) {\n        var i = e.className, r = mt(t).exec(i);\n        if (r) {\n          var n = i.slice(r.index + r[0].length);\n          e.className = i.slice(0, r.index) + (n ? r[1] + n : \"\");\n        }\n      }, \"rmClass\");\n      function Ue(e) {\n        for (var t = e.childNodes.length; t > 0; --t)\n          e.removeChild(e.firstChild);\n        return e;\n      }\n      u(Ue, \"removeChildren\");\n      function ve(e, t) {\n        return Ue(e).appendChild(t);\n      }\n      u(ve, \"removeChildrenAndAdd\");\n      function T(e, t, i, r) {\n        var n = document.createElement(e);\n        if (i && (n.className = i), r && (n.style.cssText = r), typeof t == \"string\")\n          n.appendChild(document.createTextNode(t));\n        else if (t)\n          for (var l = 0; l < t.length; ++l)\n            n.appendChild(t[l]);\n        return n;\n      }\n      u(T, \"elt\");\n      function bt(e, t, i, r) {\n        var n = T(e, t, i, r);\n        return n.setAttribute(\"role\", \"presentation\"), n;\n      }\n      u(bt, \"eltP\");\n      var rt;\n      document.createRange ? rt = /* @__PURE__ */ u(function(e, t, i, r) {\n        var n = document.createRange();\n        return n.setEnd(r || e, i), n.setStart(e, t), n;\n      }, \"range\") : rt = /* @__PURE__ */ u(function(e, t, i) {\n        var r = document.body.createTextRange();\n        try {\n          r.moveToElementText(e.parentNode);\n        } catch {\n          return r;\n        }\n        return r.collapse(!0), r.moveEnd(\"character\", i), r.moveStart(\"character\", t), r;\n      }, \"range\");\n      function Ke(e, t) {\n        if (t.nodeType == 3 && (t = t.parentNode), e.contains)\n          return e.contains(t);\n        do\n          if (t.nodeType == 11 && (t = t.host), t == e)\n            return !0;\n        while (t = t.parentNode);\n      }\n      u(Ke, \"contains\");\n      function be() {\n        var e;\n        try {\n          e = document.activeElement;\n        } catch {\n          e = document.body || null;\n        }\n        for (; e && e.shadowRoot && e.shadowRoot.activeElement; )\n          e = e.shadowRoot.activeElement;\n        return e;\n      }\n      u(be, \"activeElt\");\n      function it(e, t) {\n        var i = e.className;\n        mt(t).test(i) || (e.className += (i ? \" \" : \"\") + t);\n      }\n      u(it, \"addClass\");\n      function di(e, t) {\n        for (var i = e.split(\" \"), r = 0; r < i.length; r++)\n          i[r] && !mt(i[r]).test(t) && (t += \" \" + i[r]);\n        return t;\n      }\n      u(di, \"joinClasses\");\n      var _t = /* @__PURE__ */ u(function(e) {\n        e.select();\n      }, \"selectInput\");\n      Ut ? _t = /* @__PURE__ */ u(function(e) {\n        e.selectionStart = 0, e.selectionEnd = e.value.length;\n      }, \"selectInput\") : O && (_t = /* @__PURE__ */ u(function(e) {\n        try {\n          e.select();\n        } catch {\n        }\n      }, \"selectInput\"));\n      function pi(e) {\n        var t = Array.prototype.slice.call(arguments, 1);\n        return function() {\n          return e.apply(null, t);\n        };\n      }\n      u(pi, \"bind\");\n      function nt(e, t, i) {\n        t || (t = {});\n        for (var r in e)\n          e.hasOwnProperty(r) && (i !== !1 || !t.hasOwnProperty(r)) && (t[r] = e[r]);\n        return t;\n      }\n      u(nt, \"copyObj\");\n      function xe(e, t, i, r, n) {\n        t == null && (t = e.search(/[^\\s\\u00a0]/), t == -1 && (t = e.length));\n        for (var l = r || 0, o = n || 0; ; ) {\n          var a = e.indexOf(\"\t\", l);\n          if (a < 0 || a >= t)\n            return o + (t - l);\n          o += a - l, o += i - o % i, l = a + 1;\n        }\n      }\n      u(xe, \"countColumn\");\n      var _e = /* @__PURE__ */ u(function() {\n        this.id = null, this.f = null, this.time = 0, this.handler = pi(this.onTimeout, this);\n      }, \"Delayed\");\n      _e.prototype.onTimeout = function(e) {\n        e.id = 0, e.time <= +/* @__PURE__ */ new Date() ? e.f() : setTimeout(e.handler, e.time - +/* @__PURE__ */ new Date());\n      }, _e.prototype.set = function(e, t) {\n        this.f = t;\n        var i = +/* @__PURE__ */ new Date() + e;\n        (!this.id || i < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, e), this.time = i);\n      };\n      function ee(e, t) {\n        for (var i = 0; i < e.length; ++i)\n          if (e[i] == t)\n            return i;\n        return -1;\n      }\n      u(ee, \"indexOf\");\n      var Wn = 50, Nr = { toString: function() {\n        return \"CodeMirror.Pass\";\n      } }, Me = { scroll: !1 }, vi = { origin: \"*mouse\" }, Xt = { origin: \"+move\" };\n      function gi(e, t, i) {\n        for (var r = 0, n = 0; ; ) {\n          var l = e.indexOf(\"\t\", r);\n          l == -1 && (l = e.length);\n          var o = l - r;\n          if (l == e.length || n + o >= t)\n            return r + Math.min(o, t - n);\n          if (n += l - r, n += i - n % i, r = l + 1, n >= t)\n            return r;\n        }\n      }\n      u(gi, \"findColumn\");\n      var Ar = [\"\"];\n      function yi(e) {\n        for (; Ar.length <= e; )\n          Ar.push(H(Ar) + \" \");\n        return Ar[e];\n      }\n      u(yi, \"spaceStr\");\n      function H(e) {\n        return e[e.length - 1];\n      }\n      u(H, \"lst\");\n      function Or(e, t) {\n        for (var i = [], r = 0; r < e.length; r++)\n          i[r] = t(e[r], r);\n        return i;\n      }\n      u(Or, \"map\");\n      function Qo(e, t, i) {\n        for (var r = 0, n = i(t); r < e.length && i(e[r]) <= n; )\n          r++;\n        e.splice(r, 0, t);\n      }\n      u(Qo, \"insertSorted\");\n      function Hn() {\n      }\n      u(Hn, \"nothing\");\n      function Fn(e, t) {\n        var i;\n        return Object.create ? i = Object.create(e) : (Hn.prototype = e, i = new Hn()), t && nt(t, i), i;\n      }\n      u(Fn, \"createObj\");\n      var Jo = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n      function mi(e) {\n        return /\\w/.test(e) || e > \"\" && (e.toUpperCase() != e.toLowerCase() || Jo.test(e));\n      }\n      u(mi, \"isWordCharBasic\");\n      function Wr(e, t) {\n        return t ? t.source.indexOf(\"\\\\w\") > -1 && mi(e) ? !0 : t.test(e) : mi(e);\n      }\n      u(Wr, \"isWordChar\");\n      function Pn(e) {\n        for (var t in e)\n          if (e.hasOwnProperty(t) && e[t])\n            return !1;\n        return !0;\n      }\n      u(Pn, \"isEmpty\");\n      var jo = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n      function bi(e) {\n        return e.charCodeAt(0) >= 768 && jo.test(e);\n      }\n      u(bi, \"isExtendingChar\");\n      function En(e, t, i) {\n        for (; (i < 0 ? t > 0 : t < e.length) && bi(e.charAt(t)); )\n          t += i;\n        return t;\n      }\n      u(En, \"skipExtendingChars\");\n      function Yt(e, t, i) {\n        for (var r = t > i ? -1 : 1; ; ) {\n          if (t == i)\n            return t;\n          var n = (t + i) / 2, l = r < 0 ? Math.ceil(n) : Math.floor(n);\n          if (l == t)\n            return e(l) ? t : i;\n          e(l) ? i = l : t = l + r;\n        }\n      }\n      u(Yt, \"findFirst\");\n      function Vo(e, t, i, r) {\n        if (!e)\n          return r(t, i, \"ltr\", 0);\n        for (var n = !1, l = 0; l < e.length; ++l) {\n          var o = e[l];\n          (o.from < i && o.to > t || t == i && o.to == t) && (r(Math.max(o.from, t), Math.min(o.to, i), o.level == 1 ? \"rtl\" : \"ltr\", l), n = !0);\n        }\n        n || r(t, i, \"ltr\");\n      }\n      u(Vo, \"iterateBidiSections\");\n      var qt = null;\n      function Zt(e, t, i) {\n        var r;\n        qt = null;\n        for (var n = 0; n < e.length; ++n) {\n          var l = e[n];\n          if (l.from < t && l.to > t)\n            return n;\n          l.to == t && (l.from != l.to && i == \"before\" ? r = n : qt = n), l.from == t && (l.from != l.to && i != \"before\" ? r = n : qt = n);\n        }\n        return r ?? qt;\n      }\n      u(Zt, \"getBidiPartAt\");\n      var $o = function() {\n        var e = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\", t = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n        function i(f) {\n          return f <= 247 ? e.charAt(f) : 1424 <= f && f <= 1524 ? \"R\" : 1536 <= f && f <= 1785 ? t.charAt(f - 1536) : 1774 <= f && f <= 2220 ? \"r\" : 8192 <= f && f <= 8203 ? \"w\" : f == 8204 ? \"b\" : \"L\";\n        }\n        u(i, \"charType\");\n        var r = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/, n = /[stwN]/, l = /[LRr]/, o = /[Lb1n]/, a = /[1n]/;\n        function s(f, h, c) {\n          this.level = f, this.from = h, this.to = c;\n        }\n        return u(s, \"BidiSpan\"), function(f, h) {\n          var c = h == \"ltr\" ? \"L\" : \"R\";\n          if (f.length == 0 || h == \"ltr\" && !r.test(f))\n            return !1;\n          for (var p = f.length, d = [], v = 0; v < p; ++v)\n            d.push(i(f.charCodeAt(v)));\n          for (var g = 0, m = c; g < p; ++g) {\n            var b = d[g];\n            b == \"m\" ? d[g] = m : m = b;\n          }\n          for (var C = 0, x = c; C < p; ++C) {\n            var w = d[C];\n            w == \"1\" && x == \"r\" ? d[C] = \"n\" : l.test(w) && (x = w, w == \"r\" && (d[C] = \"R\"));\n          }\n          for (var k = 1, L = d[0]; k < p - 1; ++k) {\n            var A = d[k];\n            A == \"+\" && L == \"1\" && d[k + 1] == \"1\" ? d[k] = \"1\" : A == \",\" && L == d[k + 1] && (L == \"1\" || L == \"n\") && (d[k] = L), L = A;\n          }\n          for (var E = 0; E < p; ++E) {\n            var j = d[E];\n            if (j == \",\")\n              d[E] = \"N\";\n            else if (j == \"%\") {\n              var B = void 0;\n              for (B = E + 1; B < p && d[B] == \"%\"; ++B)\n                ;\n              for (var pe = E && d[E - 1] == \"!\" || B < p && d[B] == \"1\" ? \"1\" : \"N\", fe = E; fe < B; ++fe)\n                d[fe] = pe;\n              E = B - 1;\n            }\n          }\n          for (var _ = 0, he = c; _ < p; ++_) {\n            var $ = d[_];\n            he == \"L\" && $ == \"1\" ? d[_] = \"L\" : l.test($) && (he = $);\n          }\n          for (var Y = 0; Y < p; ++Y)\n            if (n.test(d[Y])) {\n              var X = void 0;\n              for (X = Y + 1; X < p && n.test(d[X]); ++X)\n                ;\n              for (var z = (Y ? d[Y - 1] : c) == \"L\", ce = (X < p ? d[X] : c) == \"L\", zt = z == ce ? z ? \"L\" : \"R\" : c, $e = Y; $e < X; ++$e)\n                d[$e] = zt;\n              Y = X - 1;\n            }\n          for (var re = [], We, V = 0; V < p; )\n            if (o.test(d[V])) {\n              var kn = V;\n              for (++V; V < p && o.test(d[V]); ++V)\n                ;\n              re.push(new s(0, kn, V));\n            } else {\n              var Ge = V, gt = re.length, yt = h == \"rtl\" ? 1 : 0;\n              for (++V; V < p && d[V] != \"L\"; ++V)\n                ;\n              for (var oe = Ge; oe < V; )\n                if (a.test(d[oe])) {\n                  Ge < oe && (re.splice(gt, 0, new s(1, Ge, oe)), gt += yt);\n                  var Gt = oe;\n                  for (++oe; oe < V && a.test(d[oe]); ++oe)\n                    ;\n                  re.splice(gt, 0, new s(2, Gt, oe)), gt += yt, Ge = oe;\n                } else\n                  ++oe;\n              Ge < V && re.splice(gt, 0, new s(1, Ge, V));\n            }\n          return h == \"ltr\" && (re[0].level == 1 && (We = f.match(/^\\s+/)) && (re[0].from = We[0].length, re.unshift(new s(0, 0, We[0].length))), H(re).level == 1 && (We = f.match(/\\s+$/)) && (H(re).to -= We[0].length, re.push(new s(0, p - We[0].length, p)))), h == \"rtl\" ? re.reverse() : re;\n        };\n      }();\n      function Pe(e, t) {\n        var i = e.order;\n        return i == null && (i = e.order = $o(e.text, t)), i;\n      }\n      u(Pe, \"getOrder\");\n      var In = [], M = /* @__PURE__ */ u(function(e, t, i) {\n        if (e.addEventListener)\n          e.addEventListener(t, i, !1);\n        else if (e.attachEvent)\n          e.attachEvent(\"on\" + t, i);\n        else {\n          var r = e._handlers || (e._handlers = {});\n          r[t] = (r[t] || In).concat(i);\n        }\n      }, \"on\");\n      function xi(e, t) {\n        return e._handlers && e._handlers[t] || In;\n      }\n      u(xi, \"getHandlers\");\n      function ge(e, t, i) {\n        if (e.removeEventListener)\n          e.removeEventListener(t, i, !1);\n        else if (e.detachEvent)\n          e.detachEvent(\"on\" + t, i);\n        else {\n          var r = e._handlers, n = r && r[t];\n          if (n) {\n            var l = ee(n, i);\n            l > -1 && (r[t] = n.slice(0, l).concat(n.slice(l + 1)));\n          }\n        }\n      }\n      u(ge, \"off\");\n      function U(e, t) {\n        var i = xi(e, t);\n        if (i.length)\n          for (var r = Array.prototype.slice.call(arguments, 2), n = 0; n < i.length; ++n)\n            i[n].apply(null, r);\n      }\n      u(U, \"signal\");\n      function q(e, t, i) {\n        return typeof t == \"string\" && (t = { type: t, preventDefault: function() {\n          this.defaultPrevented = !0;\n        } }), U(e, i || t.type, e, t), Ci(t) || t.codemirrorIgnore;\n      }\n      u(q, \"signalDOMEvent\");\n      function Rn(e) {\n        var t = e._handlers && e._handlers.cursorActivity;\n        if (t)\n          for (var i = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []), r = 0; r < t.length; ++r)\n            ee(i, t[r]) == -1 && i.push(t[r]);\n      }\n      u(Rn, \"signalCursorActivity\");\n      function Ce(e, t) {\n        return xi(e, t).length > 0;\n      }\n      u(Ce, \"hasHandler\");\n      function xt(e) {\n        e.prototype.on = function(t, i) {\n          M(this, t, i);\n        }, e.prototype.off = function(t, i) {\n          ge(this, t, i);\n        };\n      }\n      u(xt, \"eventMixin\");\n      function ae(e) {\n        e.preventDefault ? e.preventDefault() : e.returnValue = !1;\n      }\n      u(ae, \"e_preventDefault\");\n      function Bn(e) {\n        e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0;\n      }\n      u(Bn, \"e_stopPropagation\");\n      function Ci(e) {\n        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == !1;\n      }\n      u(Ci, \"e_defaultPrevented\");\n      function Qt(e) {\n        ae(e), Bn(e);\n      }\n      u(Qt, \"e_stop\");\n      function wi(e) {\n        return e.target || e.srcElement;\n      }\n      u(wi, \"e_target\");\n      function zn(e) {\n        var t = e.which;\n        return t == null && (e.button & 1 ? t = 1 : e.button & 2 ? t = 3 : e.button & 4 && (t = 2)), me && e.ctrlKey && t == 1 && (t = 3), t;\n      }\n      u(zn, \"e_button\");\n      var ea = function() {\n        if (O && I < 9)\n          return !1;\n        var e = T(\"div\");\n        return \"draggable\" in e || \"dragDrop\" in e;\n      }(), Si;\n      function ta(e) {\n        if (Si == null) {\n          var t = T(\"span\", \"​\");\n          ve(e, T(\"span\", [t, document.createTextNode(\"x\")])), e.firstChild.offsetHeight != 0 && (Si = t.offsetWidth <= 1 && t.offsetHeight > 2 && !(O && I < 8));\n        }\n        var i = Si ? T(\"span\", \"​\") : T(\"span\", \" \", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n        return i.setAttribute(\"cm-text\", \"\"), i;\n      }\n      u(ta, \"zeroWidthElement\");\n      var Li;\n      function ra(e) {\n        if (Li != null)\n          return Li;\n        var t = ve(e, document.createTextNode(\"AخA\")), i = rt(t, 0, 1).getBoundingClientRect(), r = rt(t, 1, 2).getBoundingClientRect();\n        return Ue(e), !i || i.left == i.right ? !1 : Li = r.right - i.right < 3;\n      }\n      u(ra, \"hasBadBidiRects\");\n      var ki = `\n\nb`.split(/\\n/).length != 3 ? function(e) {\n        for (var t = 0, i = [], r = e.length; t <= r; ) {\n          var n = e.indexOf(`\n`, t);\n          n == -1 && (n = e.length);\n          var l = e.slice(t, e.charAt(n - 1) == \"\\r\" ? n - 1 : n), o = l.indexOf(\"\\r\");\n          o != -1 ? (i.push(l.slice(0, o)), t += o + 1) : (i.push(l), t = n + 1);\n        }\n        return i;\n      } : function(e) {\n        return e.split(/\\r\\n?|\\n/);\n      }, ia = window.getSelection ? function(e) {\n        try {\n          return e.selectionStart != e.selectionEnd;\n        } catch {\n          return !1;\n        }\n      } : function(e) {\n        var t;\n        try {\n          t = e.ownerDocument.selection.createRange();\n        } catch {\n        }\n        return !t || t.parentElement() != e ? !1 : t.compareEndPoints(\"StartToEnd\", t) != 0;\n      }, na = function() {\n        var e = T(\"div\");\n        return \"oncopy\" in e ? !0 : (e.setAttribute(\"oncopy\", \"return;\"), typeof e.oncopy == \"function\");\n      }(), Ti = null;\n      function la(e) {\n        if (Ti != null)\n          return Ti;\n        var t = ve(e, T(\"span\", \"x\")), i = t.getBoundingClientRect(), r = rt(t, 0, 1).getBoundingClientRect();\n        return Ti = Math.abs(i.left - r.left) > 1;\n      }\n      u(la, \"hasBadZoomedRects\");\n      var Mi = {}, Ct = {};\n      function oa(e, t) {\n        arguments.length > 2 && (t.dependencies = Array.prototype.slice.call(arguments, 2)), Mi[e] = t;\n      }\n      u(oa, \"defineMode\");\n      function aa(e, t) {\n        Ct[e] = t;\n      }\n      u(aa, \"defineMIME\");\n      function Hr(e) {\n        if (typeof e == \"string\" && Ct.hasOwnProperty(e))\n          e = Ct[e];\n        else if (e && typeof e.name == \"string\" && Ct.hasOwnProperty(e.name)) {\n          var t = Ct[e.name];\n          typeof t == \"string\" && (t = { name: t }), e = Fn(t, e), e.name = t.name;\n        } else {\n          if (typeof e == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(e))\n            return Hr(\"application/xml\");\n          if (typeof e == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(e))\n            return Hr(\"application/json\");\n        }\n        return typeof e == \"string\" ? { name: e } : e || { name: \"null\" };\n      }\n      u(Hr, \"resolveMode\");\n      function Di(e, t) {\n        t = Hr(t);\n        var i = Mi[t.name];\n        if (!i)\n          return Di(e, \"text/plain\");\n        var r = i(e, t);\n        if (wt.hasOwnProperty(t.name)) {\n          var n = wt[t.name];\n          for (var l in n)\n            n.hasOwnProperty(l) && (r.hasOwnProperty(l) && (r[\"_\" + l] = r[l]), r[l] = n[l]);\n        }\n        if (r.name = t.name, t.helperType && (r.helperType = t.helperType), t.modeProps)\n          for (var o in t.modeProps)\n            r[o] = t.modeProps[o];\n        return r;\n      }\n      u(Di, \"getMode\");\n      var wt = {};\n      function sa(e, t) {\n        var i = wt.hasOwnProperty(e) ? wt[e] : wt[e] = {};\n        nt(t, i);\n      }\n      u(sa, \"extendMode\");\n      function lt(e, t) {\n        if (t === !0)\n          return t;\n        if (e.copyState)\n          return e.copyState(t);\n        var i = {};\n        for (var r in t) {\n          var n = t[r];\n          n instanceof Array && (n = n.concat([])), i[r] = n;\n        }\n        return i;\n      }\n      u(lt, \"copyState\");\n      function Ni(e, t) {\n        for (var i; e.innerMode && (i = e.innerMode(t), !(!i || i.mode == e)); )\n          t = i.state, e = i.mode;\n        return i || { mode: e, state: t };\n      }\n      u(Ni, \"innerMode\");\n      function Gn(e, t, i) {\n        return e.startState ? e.startState(t, i) : !0;\n      }\n      u(Gn, \"startState\");\n      var K = /* @__PURE__ */ u(function(e, t, i) {\n        this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = i;\n      }, \"StringStream\");\n      K.prototype.eol = function() {\n        return this.pos >= this.string.length;\n      }, K.prototype.sol = function() {\n        return this.pos == this.lineStart;\n      }, K.prototype.peek = function() {\n        return this.string.charAt(this.pos) || void 0;\n      }, K.prototype.next = function() {\n        if (this.pos < this.string.length)\n          return this.string.charAt(this.pos++);\n      }, K.prototype.eat = function(e) {\n        var t = this.string.charAt(this.pos), i;\n        if (typeof e == \"string\" ? i = t == e : i = t && (e.test ? e.test(t) : e(t)), i)\n          return ++this.pos, t;\n      }, K.prototype.eatWhile = function(e) {\n        for (var t = this.pos; this.eat(e); )\n          ;\n        return this.pos > t;\n      }, K.prototype.eatSpace = function() {\n        for (var e = this.pos; /[\\s\\u00a0]/.test(this.string.charAt(this.pos)); )\n          ++this.pos;\n        return this.pos > e;\n      }, K.prototype.skipToEnd = function() {\n        this.pos = this.string.length;\n      }, K.prototype.skipTo = function(e) {\n        var t = this.string.indexOf(e, this.pos);\n        if (t > -1)\n          return this.pos = t, !0;\n      }, K.prototype.backUp = function(e) {\n        this.pos -= e;\n      }, K.prototype.column = function() {\n        return this.lastColumnPos < this.start && (this.lastColumnValue = xe(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? xe(this.string, this.lineStart, this.tabSize) : 0);\n      }, K.prototype.indentation = function() {\n        return xe(this.string, null, this.tabSize) - (this.lineStart ? xe(this.string, this.lineStart, this.tabSize) : 0);\n      }, K.prototype.match = function(e, t, i) {\n        if (typeof e == \"string\") {\n          var r = /* @__PURE__ */ u(function(o) {\n            return i ? o.toLowerCase() : o;\n          }, \"cased\"), n = this.string.substr(this.pos, e.length);\n          if (r(n) == r(e))\n            return t !== !1 && (this.pos += e.length), !0;\n        } else {\n          var l = this.string.slice(this.pos).match(e);\n          return l && l.index > 0 ? null : (l && t !== !1 && (this.pos += l[0].length), l);\n        }\n      }, K.prototype.current = function() {\n        return this.string.slice(this.start, this.pos);\n      }, K.prototype.hideFirstChars = function(e, t) {\n        this.lineStart += e;\n        try {\n          return t();\n        } finally {\n          this.lineStart -= e;\n        }\n      }, K.prototype.lookAhead = function(e) {\n        var t = this.lineOracle;\n        return t && t.lookAhead(e);\n      }, K.prototype.baseToken = function() {\n        var e = this.lineOracle;\n        return e && e.baseToken(this.pos);\n      };\n      function S(e, t) {\n        if (t -= e.first, t < 0 || t >= e.size)\n          throw new Error(\"There is no line \" + (t + e.first) + \" in the document.\");\n        for (var i = e; !i.lines; )\n          for (var r = 0; ; ++r) {\n            var n = i.children[r], l = n.chunkSize();\n            if (t < l) {\n              i = n;\n              break;\n            }\n            t -= l;\n          }\n        return i.lines[t];\n      }\n      u(S, \"getLine\");\n      function ot(e, t, i) {\n        var r = [], n = t.line;\n        return e.iter(t.line, i.line + 1, function(l) {\n          var o = l.text;\n          n == i.line && (o = o.slice(0, i.ch)), n == t.line && (o = o.slice(t.ch)), r.push(o), ++n;\n        }), r;\n      }\n      u(ot, \"getBetween\");\n      function Ai(e, t, i) {\n        var r = [];\n        return e.iter(t, i, function(n) {\n          r.push(n.text);\n        }), r;\n      }\n      u(Ai, \"getLines\");\n      function De(e, t) {\n        var i = t - e.height;\n        if (i)\n          for (var r = e; r; r = r.parent)\n            r.height += i;\n      }\n      u(De, \"updateLineHeight\");\n      function F(e) {\n        if (e.parent == null)\n          return null;\n        for (var t = e.parent, i = ee(t.lines, e), r = t.parent; r; t = r, r = r.parent)\n          for (var n = 0; r.children[n] != t; ++n)\n            i += r.children[n].chunkSize();\n        return i + t.first;\n      }\n      u(F, \"lineNo\");\n      function at(e, t) {\n        var i = e.first;\n        e:\n          do {\n            for (var r = 0; r < e.children.length; ++r) {\n              var n = e.children[r], l = n.height;\n              if (t < l) {\n                e = n;\n                continue e;\n              }\n              t -= l, i += n.chunkSize();\n            }\n            return i;\n          } while (!e.lines);\n        for (var o = 0; o < e.lines.length; ++o) {\n          var a = e.lines[o], s = a.height;\n          if (t < s)\n            break;\n          t -= s;\n        }\n        return i + o;\n      }\n      u(at, \"lineAtHeight\");\n      function Jt(e, t) {\n        return t >= e.first && t < e.first + e.size;\n      }\n      u(Jt, \"isLine\");\n      function Oi(e, t) {\n        return String(e.lineNumberFormatter(t + e.firstLineNumber));\n      }\n      u(Oi, \"lineNumberFor\");\n      function y(e, t, i) {\n        if (i === void 0 && (i = null), !(this instanceof y))\n          return new y(e, t, i);\n        this.line = e, this.ch = t, this.sticky = i;\n      }\n      u(y, \"Pos\");\n      function D(e, t) {\n        return e.line - t.line || e.ch - t.ch;\n      }\n      u(D, \"cmp\");\n      function Wi(e, t) {\n        return e.sticky == t.sticky && D(e, t) == 0;\n      }\n      u(Wi, \"equalCursorPos\");\n      function Hi(e) {\n        return y(e.line, e.ch);\n      }\n      u(Hi, \"copyPos\");\n      function Fr(e, t) {\n        return D(e, t) < 0 ? t : e;\n      }\n      u(Fr, \"maxPos\");\n      function Pr(e, t) {\n        return D(e, t) < 0 ? e : t;\n      }\n      u(Pr, \"minPos\");\n      function Un(e, t) {\n        return Math.max(e.first, Math.min(t, e.first + e.size - 1));\n      }\n      u(Un, \"clipLine\");\n      function N(e, t) {\n        if (t.line < e.first)\n          return y(e.first, 0);\n        var i = e.first + e.size - 1;\n        return t.line > i ? y(i, S(e, i).text.length) : ua(t, S(e, t.line).text.length);\n      }\n      u(N, \"clipPos\");\n      function ua(e, t) {\n        var i = e.ch;\n        return i == null || i > t ? y(e.line, t) : i < 0 ? y(e.line, 0) : e;\n      }\n      u(ua, \"clipToLen\");\n      function Kn(e, t) {\n        for (var i = [], r = 0; r < t.length; r++)\n          i[r] = N(e, t[r]);\n        return i;\n      }\n      u(Kn, \"clipPosArray\");\n      var Er = /* @__PURE__ */ u(function(e, t) {\n        this.state = e, this.lookAhead = t;\n      }, \"SavedContext\"), Ne = /* @__PURE__ */ u(function(e, t, i, r) {\n        this.state = t, this.doc = e, this.line = i, this.maxLookAhead = r || 0, this.baseTokens = null, this.baseTokenPos = 1;\n      }, \"Context\");\n      Ne.prototype.lookAhead = function(e) {\n        var t = this.doc.getLine(this.line + e);\n        return t != null && e > this.maxLookAhead && (this.maxLookAhead = e), t;\n      }, Ne.prototype.baseToken = function(e) {\n        if (!this.baseTokens)\n          return null;\n        for (; this.baseTokens[this.baseTokenPos] <= e; )\n          this.baseTokenPos += 2;\n        var t = this.baseTokens[this.baseTokenPos + 1];\n        return {\n          type: t && t.replace(/( |^)overlay .*/, \"\"),\n          size: this.baseTokens[this.baseTokenPos] - e\n        };\n      }, Ne.prototype.nextLine = function() {\n        this.line++, this.maxLookAhead > 0 && this.maxLookAhead--;\n      }, Ne.fromSaved = function(e, t, i) {\n        return t instanceof Er ? new Ne(e, lt(e.mode, t.state), i, t.lookAhead) : new Ne(e, lt(e.mode, t), i);\n      }, Ne.prototype.save = function(e) {\n        var t = e !== !1 ? lt(this.doc.mode, this.state) : this.state;\n        return this.maxLookAhead > 0 ? new Er(t, this.maxLookAhead) : t;\n      };\n      function _n(e, t, i, r) {\n        var n = [e.state.modeGen], l = {};\n        Jn(\n          e,\n          t.text,\n          e.doc.mode,\n          i,\n          function(f, h) {\n            return n.push(f, h);\n          },\n          l,\n          r\n        );\n        for (var o = i.state, a = /* @__PURE__ */ u(function(f) {\n          i.baseTokens = n;\n          var h = e.state.overlays[f], c = 1, p = 0;\n          i.state = !0, Jn(e, t.text, h.mode, i, function(d, v) {\n            for (var g = c; p < d; ) {\n              var m = n[c];\n              m > d && n.splice(c, 1, d, n[c + 1], m), c += 2, p = Math.min(d, m);\n            }\n            if (v)\n              if (h.opaque)\n                n.splice(g, c - g, d, \"overlay \" + v), c = g + 2;\n              else\n                for (; g < c; g += 2) {\n                  var b = n[g + 1];\n                  n[g + 1] = (b ? b + \" \" : \"\") + \"overlay \" + v;\n                }\n          }, l), i.state = o, i.baseTokens = null, i.baseTokenPos = 1;\n        }, \"loop\"), s = 0; s < e.state.overlays.length; ++s)\n          a(s);\n        return { styles: n, classes: l.bgClass || l.textClass ? l : null };\n      }\n      u(_n, \"highlightLine\");\n      function Xn(e, t, i) {\n        if (!t.styles || t.styles[0] != e.state.modeGen) {\n          var r = jt(e, F(t)), n = t.text.length > e.options.maxHighlightLength && lt(e.doc.mode, r.state), l = _n(e, t, r);\n          n && (r.state = n), t.stateAfter = r.save(!n), t.styles = l.styles, l.classes ? t.styleClasses = l.classes : t.styleClasses && (t.styleClasses = null), i === e.doc.highlightFrontier && (e.doc.modeFrontier = Math.max(e.doc.modeFrontier, ++e.doc.highlightFrontier));\n        }\n        return t.styles;\n      }\n      u(Xn, \"getLineStyles\");\n      function jt(e, t, i) {\n        var r = e.doc, n = e.display;\n        if (!r.mode.startState)\n          return new Ne(r, !0, t);\n        var l = fa(e, t, i), o = l > r.first && S(r, l - 1).stateAfter, a = o ? Ne.fromSaved(r, o, l) : new Ne(r, Gn(r.mode), l);\n        return r.iter(l, t, function(s) {\n          Fi(e, s.text, a);\n          var f = a.line;\n          s.stateAfter = f == t - 1 || f % 5 == 0 || f >= n.viewFrom && f < n.viewTo ? a.save() : null, a.nextLine();\n        }), i && (r.modeFrontier = a.line), a;\n      }\n      u(jt, \"getContextBefore\");\n      function Fi(e, t, i, r) {\n        var n = e.doc.mode, l = new K(t, e.options.tabSize, i);\n        for (l.start = l.pos = r || 0, t == \"\" && Yn(n, i.state); !l.eol(); )\n          Pi(n, l, i.state), l.start = l.pos;\n      }\n      u(Fi, \"processLine\");\n      function Yn(e, t) {\n        if (e.blankLine)\n          return e.blankLine(t);\n        if (e.innerMode) {\n          var i = Ni(e, t);\n          if (i.mode.blankLine)\n            return i.mode.blankLine(i.state);\n        }\n      }\n      u(Yn, \"callBlankLine\");\n      function Pi(e, t, i, r) {\n        for (var n = 0; n < 10; n++) {\n          r && (r[0] = Ni(e, i).mode);\n          var l = e.token(t, i);\n          if (t.pos > t.start)\n            return l;\n        }\n        throw new Error(\"Mode \" + e.name + \" failed to advance stream.\");\n      }\n      u(Pi, \"readToken\");\n      var qn = /* @__PURE__ */ u(function(e, t, i) {\n        this.start = e.start, this.end = e.pos, this.string = e.current(), this.type = t || null, this.state = i;\n      }, \"Token\");\n      function Zn(e, t, i, r) {\n        var n = e.doc, l = n.mode, o;\n        t = N(n, t);\n        var a = S(n, t.line), s = jt(e, t.line, i), f = new K(a.text, e.options.tabSize, s), h;\n        for (r && (h = []); (r || f.pos < t.ch) && !f.eol(); )\n          f.start = f.pos, o = Pi(l, f, s.state), r && h.push(new qn(f, o, lt(n.mode, s.state)));\n        return r ? h : new qn(f, o, s.state);\n      }\n      u(Zn, \"takeToken\");\n      function Qn(e, t) {\n        if (e)\n          for (; ; ) {\n            var i = e.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n            if (!i)\n              break;\n            e = e.slice(0, i.index) + e.slice(i.index + i[0].length);\n            var r = i[1] ? \"bgClass\" : \"textClass\";\n            t[r] == null ? t[r] = i[2] : new RegExp(\"(?:^|\\\\s)\" + i[2] + \"(?:$|\\\\s)\").test(t[r]) || (t[r] += \" \" + i[2]);\n          }\n        return e;\n      }\n      u(Qn, \"extractLineClasses\");\n      function Jn(e, t, i, r, n, l, o) {\n        var a = i.flattenSpans;\n        a == null && (a = e.options.flattenSpans);\n        var s = 0, f = null, h = new K(t, e.options.tabSize, r), c, p = e.options.addModeClass && [null];\n        for (t == \"\" && Qn(Yn(i, r.state), l); !h.eol(); ) {\n          if (h.pos > e.options.maxHighlightLength ? (a = !1, o && Fi(e, t, r, h.pos), h.pos = t.length, c = null) : c = Qn(Pi(i, h, r.state, p), l), p) {\n            var d = p[0].name;\n            d && (c = \"m-\" + (c ? d + \" \" + c : d));\n          }\n          if (!a || f != c) {\n            for (; s < h.start; )\n              s = Math.min(h.start, s + 5e3), n(s, f);\n            f = c;\n          }\n          h.start = h.pos;\n        }\n        for (; s < h.pos; ) {\n          var v = Math.min(h.pos, s + 5e3);\n          n(v, f), s = v;\n        }\n      }\n      u(Jn, \"runMode\");\n      function fa(e, t, i) {\n        for (var r, n, l = e.doc, o = i ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100), a = t; a > o; --a) {\n          if (a <= l.first)\n            return l.first;\n          var s = S(l, a - 1), f = s.stateAfter;\n          if (f && (!i || a + (f instanceof Er ? f.lookAhead : 0) <= l.modeFrontier))\n            return a;\n          var h = xe(s.text, null, e.options.tabSize);\n          (n == null || r > h) && (n = a - 1, r = h);\n        }\n        return n;\n      }\n      u(fa, \"findStartLine\");\n      function ha(e, t) {\n        if (e.modeFrontier = Math.min(e.modeFrontier, t), !(e.highlightFrontier < t - 10)) {\n          for (var i = e.first, r = t - 1; r > i; r--) {\n            var n = S(e, r).stateAfter;\n            if (n && (!(n instanceof Er) || r + n.lookAhead < t)) {\n              i = r + 1;\n              break;\n            }\n          }\n          e.highlightFrontier = Math.min(e.highlightFrontier, i);\n        }\n      }\n      u(ha, \"retreatFrontier\");\n      var jn = !1, Ee = !1;\n      function ca() {\n        jn = !0;\n      }\n      u(ca, \"seeReadOnlySpans\");\n      function da() {\n        Ee = !0;\n      }\n      u(da, \"seeCollapsedSpans\");\n      function Ir(e, t, i) {\n        this.marker = e, this.from = t, this.to = i;\n      }\n      u(Ir, \"MarkedSpan\");\n      function Vt(e, t) {\n        if (e)\n          for (var i = 0; i < e.length; ++i) {\n            var r = e[i];\n            if (r.marker == t)\n              return r;\n          }\n      }\n      u(Vt, \"getMarkedSpanFor\");\n      function pa(e, t) {\n        for (var i, r = 0; r < e.length; ++r)\n          e[r] != t && (i || (i = [])).push(e[r]);\n        return i;\n      }\n      u(pa, \"removeMarkedSpan\");\n      function va(e, t, i) {\n        var r = i && window.WeakSet && (i.markedSpans || (i.markedSpans = /* @__PURE__ */ new WeakSet()));\n        r && e.markedSpans && r.has(e.markedSpans) ? e.markedSpans.push(t) : (e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], r && r.add(e.markedSpans)), t.marker.attachLine(e);\n      }\n      u(va, \"addMarkedSpan\");\n      function ga(e, t, i) {\n        var r;\n        if (e)\n          for (var n = 0; n < e.length; ++n) {\n            var l = e[n], o = l.marker, a = l.from == null || (o.inclusiveLeft ? l.from <= t : l.from < t);\n            if (a || l.from == t && o.type == \"bookmark\" && (!i || !l.marker.insertLeft)) {\n              var s = l.to == null || (o.inclusiveRight ? l.to >= t : l.to > t);\n              (r || (r = [])).push(new Ir(o, l.from, s ? null : l.to));\n            }\n          }\n        return r;\n      }\n      u(ga, \"markedSpansBefore\");\n      function ya(e, t, i) {\n        var r;\n        if (e)\n          for (var n = 0; n < e.length; ++n) {\n            var l = e[n], o = l.marker, a = l.to == null || (o.inclusiveRight ? l.to >= t : l.to > t);\n            if (a || l.from == t && o.type == \"bookmark\" && (!i || l.marker.insertLeft)) {\n              var s = l.from == null || (o.inclusiveLeft ? l.from <= t : l.from < t);\n              (r || (r = [])).push(new Ir(\n                o,\n                s ? null : l.from - t,\n                l.to == null ? null : l.to - t\n              ));\n            }\n          }\n        return r;\n      }\n      u(ya, \"markedSpansAfter\");\n      function Ei(e, t) {\n        if (t.full)\n          return null;\n        var i = Jt(e, t.from.line) && S(e, t.from.line).markedSpans, r = Jt(e, t.to.line) && S(e, t.to.line).markedSpans;\n        if (!i && !r)\n          return null;\n        var n = t.from.ch, l = t.to.ch, o = D(t.from, t.to) == 0, a = ga(i, n, o), s = ya(r, l, o), f = t.text.length == 1, h = H(t.text).length + (f ? n : 0);\n        if (a)\n          for (var c = 0; c < a.length; ++c) {\n            var p = a[c];\n            if (p.to == null) {\n              var d = Vt(s, p.marker);\n              d ? f && (p.to = d.to == null ? null : d.to + h) : p.to = n;\n            }\n          }\n        if (s)\n          for (var v = 0; v < s.length; ++v) {\n            var g = s[v];\n            if (g.to != null && (g.to += h), g.from == null) {\n              var m = Vt(a, g.marker);\n              m || (g.from = h, f && (a || (a = [])).push(g));\n            } else\n              g.from += h, f && (a || (a = [])).push(g);\n          }\n        a && (a = Vn(a)), s && s != a && (s = Vn(s));\n        var b = [a];\n        if (!f) {\n          var C = t.text.length - 2, x;\n          if (C > 0 && a)\n            for (var w = 0; w < a.length; ++w)\n              a[w].to == null && (x || (x = [])).push(new Ir(a[w].marker, null, null));\n          for (var k = 0; k < C; ++k)\n            b.push(x);\n          b.push(s);\n        }\n        return b;\n      }\n      u(Ei, \"stretchSpansOverChange\");\n      function Vn(e) {\n        for (var t = 0; t < e.length; ++t) {\n          var i = e[t];\n          i.from != null && i.from == i.to && i.marker.clearWhenEmpty !== !1 && e.splice(t--, 1);\n        }\n        return e.length ? e : null;\n      }\n      u(Vn, \"clearEmptySpans\");\n      function ma(e, t, i) {\n        var r = null;\n        if (e.iter(t.line, i.line + 1, function(d) {\n          if (d.markedSpans)\n            for (var v = 0; v < d.markedSpans.length; ++v) {\n              var g = d.markedSpans[v].marker;\n              g.readOnly && (!r || ee(r, g) == -1) && (r || (r = [])).push(g);\n            }\n        }), !r)\n          return null;\n        for (var n = [{ from: t, to: i }], l = 0; l < r.length; ++l)\n          for (var o = r[l], a = o.find(0), s = 0; s < n.length; ++s) {\n            var f = n[s];\n            if (!(D(f.to, a.from) < 0 || D(f.from, a.to) > 0)) {\n              var h = [s, 1], c = D(f.from, a.from), p = D(f.to, a.to);\n              (c < 0 || !o.inclusiveLeft && !c) && h.push({ from: f.from, to: a.from }), (p > 0 || !o.inclusiveRight && !p) && h.push({ from: a.to, to: f.to }), n.splice.apply(n, h), s += h.length - 3;\n            }\n          }\n        return n;\n      }\n      u(ma, \"removeReadOnlyRanges\");\n      function $n(e) {\n        var t = e.markedSpans;\n        if (t) {\n          for (var i = 0; i < t.length; ++i)\n            t[i].marker.detachLine(e);\n          e.markedSpans = null;\n        }\n      }\n      u($n, \"detachMarkedSpans\");\n      function el(e, t) {\n        if (t) {\n          for (var i = 0; i < t.length; ++i)\n            t[i].marker.attachLine(e);\n          e.markedSpans = t;\n        }\n      }\n      u(el, \"attachMarkedSpans\");\n      function Rr(e) {\n        return e.inclusiveLeft ? -1 : 0;\n      }\n      u(Rr, \"extraLeft\");\n      function Br(e) {\n        return e.inclusiveRight ? 1 : 0;\n      }\n      u(Br, \"extraRight\");\n      function Ii(e, t) {\n        var i = e.lines.length - t.lines.length;\n        if (i != 0)\n          return i;\n        var r = e.find(), n = t.find(), l = D(r.from, n.from) || Rr(e) - Rr(t);\n        if (l)\n          return -l;\n        var o = D(r.to, n.to) || Br(e) - Br(t);\n        return o || t.id - e.id;\n      }\n      u(Ii, \"compareCollapsedMarkers\");\n      function tl(e, t) {\n        var i = Ee && e.markedSpans, r;\n        if (i)\n          for (var n = void 0, l = 0; l < i.length; ++l)\n            n = i[l], n.marker.collapsed && (t ? n.from : n.to) == null && (!r || Ii(r, n.marker) < 0) && (r = n.marker);\n        return r;\n      }\n      u(tl, \"collapsedSpanAtSide\");\n      function rl(e) {\n        return tl(e, !0);\n      }\n      u(rl, \"collapsedSpanAtStart\");\n      function zr(e) {\n        return tl(e, !1);\n      }\n      u(zr, \"collapsedSpanAtEnd\");\n      function ba(e, t) {\n        var i = Ee && e.markedSpans, r;\n        if (i)\n          for (var n = 0; n < i.length; ++n) {\n            var l = i[n];\n            l.marker.collapsed && (l.from == null || l.from < t) && (l.to == null || l.to > t) && (!r || Ii(r, l.marker) < 0) && (r = l.marker);\n          }\n        return r;\n      }\n      u(ba, \"collapsedSpanAround\");\n      function il(e, t, i, r, n) {\n        var l = S(e, t), o = Ee && l.markedSpans;\n        if (o)\n          for (var a = 0; a < o.length; ++a) {\n            var s = o[a];\n            if (s.marker.collapsed) {\n              var f = s.marker.find(0), h = D(f.from, i) || Rr(s.marker) - Rr(n), c = D(f.to, r) || Br(s.marker) - Br(n);\n              if (!(h >= 0 && c <= 0 || h <= 0 && c >= 0) && (h <= 0 && (s.marker.inclusiveRight && n.inclusiveLeft ? D(f.to, i) >= 0 : D(f.to, i) > 0) || h >= 0 && (s.marker.inclusiveRight && n.inclusiveLeft ? D(f.from, r) <= 0 : D(f.from, r) < 0)))\n                return !0;\n            }\n          }\n      }\n      u(il, \"conflictingCollapsedRange\");\n      function Se(e) {\n        for (var t; t = rl(e); )\n          e = t.find(-1, !0).line;\n        return e;\n      }\n      u(Se, \"visualLine\");\n      function xa(e) {\n        for (var t; t = zr(e); )\n          e = t.find(1, !0).line;\n        return e;\n      }\n      u(xa, \"visualLineEnd\");\n      function Ca(e) {\n        for (var t, i; t = zr(e); )\n          e = t.find(1, !0).line, (i || (i = [])).push(e);\n        return i;\n      }\n      u(Ca, \"visualLineContinued\");\n      function Ri(e, t) {\n        var i = S(e, t), r = Se(i);\n        return i == r ? t : F(r);\n      }\n      u(Ri, \"visualLineNo\");\n      function nl(e, t) {\n        if (t > e.lastLine())\n          return t;\n        var i = S(e, t), r;\n        if (!Xe(e, i))\n          return t;\n        for (; r = zr(i); )\n          i = r.find(1, !0).line;\n        return F(i) + 1;\n      }\n      u(nl, \"visualLineEndNo\");\n      function Xe(e, t) {\n        var i = Ee && t.markedSpans;\n        if (i) {\n          for (var r = void 0, n = 0; n < i.length; ++n)\n            if (r = i[n], !!r.marker.collapsed) {\n              if (r.from == null)\n                return !0;\n              if (!r.marker.widgetNode && r.from == 0 && r.marker.inclusiveLeft && Bi(e, t, r))\n                return !0;\n            }\n        }\n      }\n      u(Xe, \"lineIsHidden\");\n      function Bi(e, t, i) {\n        if (i.to == null) {\n          var r = i.marker.find(1, !0);\n          return Bi(e, r.line, Vt(r.line.markedSpans, i.marker));\n        }\n        if (i.marker.inclusiveRight && i.to == t.text.length)\n          return !0;\n        for (var n = void 0, l = 0; l < t.markedSpans.length; ++l)\n          if (n = t.markedSpans[l], n.marker.collapsed && !n.marker.widgetNode && n.from == i.to && (n.to == null || n.to != i.from) && (n.marker.inclusiveLeft || i.marker.inclusiveRight) && Bi(e, t, n))\n            return !0;\n      }\n      u(Bi, \"lineIsHiddenInner\");\n      function Ie(e) {\n        e = Se(e);\n        for (var t = 0, i = e.parent, r = 0; r < i.lines.length; ++r) {\n          var n = i.lines[r];\n          if (n == e)\n            break;\n          t += n.height;\n        }\n        for (var l = i.parent; l; i = l, l = i.parent)\n          for (var o = 0; o < l.children.length; ++o) {\n            var a = l.children[o];\n            if (a == i)\n              break;\n            t += a.height;\n          }\n        return t;\n      }\n      u(Ie, \"heightAtLine\");\n      function Gr(e) {\n        if (e.height == 0)\n          return 0;\n        for (var t = e.text.length, i, r = e; i = rl(r); ) {\n          var n = i.find(0, !0);\n          r = n.from.line, t += n.from.ch - n.to.ch;\n        }\n        for (r = e; i = zr(r); ) {\n          var l = i.find(0, !0);\n          t -= r.text.length - l.from.ch, r = l.to.line, t += r.text.length - l.to.ch;\n        }\n        return t;\n      }\n      u(Gr, \"lineLength\");\n      function zi(e) {\n        var t = e.display, i = e.doc;\n        t.maxLine = S(i, i.first), t.maxLineLength = Gr(t.maxLine), t.maxLineChanged = !0, i.iter(function(r) {\n          var n = Gr(r);\n          n > t.maxLineLength && (t.maxLineLength = n, t.maxLine = r);\n        });\n      }\n      u(zi, \"findMaxLine\");\n      var St = /* @__PURE__ */ u(function(e, t, i) {\n        this.text = e, el(this, t), this.height = i ? i(this) : 1;\n      }, \"Line\");\n      St.prototype.lineNo = function() {\n        return F(this);\n      }, xt(St);\n      function wa(e, t, i, r) {\n        e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), e.order != null && (e.order = null), $n(e), el(e, i);\n        var n = r ? r(e) : 1;\n        n != e.height && De(e, n);\n      }\n      u(wa, \"updateLine\");\n      function Sa(e) {\n        e.parent = null, $n(e);\n      }\n      u(Sa, \"cleanUpLine\");\n      var La = {}, ka = {};\n      function ll(e, t) {\n        if (!e || /^\\s*$/.test(e))\n          return null;\n        var i = t.addModeClass ? ka : La;\n        return i[e] || (i[e] = e.replace(/\\S+/g, \"cm-$&\"));\n      }\n      u(ll, \"interpretTokenStyle\");\n      function ol(e, t) {\n        var i = bt(\"span\", null, null, ne ? \"padding-right: .1px\" : null), r = {\n          pre: bt(\"pre\", [i], \"CodeMirror-line\"),\n          content: i,\n          col: 0,\n          pos: 0,\n          cm: e,\n          trailingSpace: !1,\n          splitSpaces: e.getOption(\"lineWrapping\")\n        };\n        t.measure = {};\n        for (var n = 0; n <= (t.rest ? t.rest.length : 0); n++) {\n          var l = n ? t.rest[n - 1] : t.line, o = void 0;\n          r.pos = 0, r.addToken = Ma, ra(e.display.measure) && (o = Pe(l, e.doc.direction)) && (r.addToken = Na(r.addToken, o)), r.map = [];\n          var a = t != e.display.externalMeasured && F(l);\n          Aa(l, r, Xn(e, l, a)), l.styleClasses && (l.styleClasses.bgClass && (r.bgClass = di(l.styleClasses.bgClass, r.bgClass || \"\")), l.styleClasses.textClass && (r.textClass = di(l.styleClasses.textClass, r.textClass || \"\"))), r.map.length == 0 && r.map.push(0, 0, r.content.appendChild(ta(e.display.measure))), n == 0 ? (t.measure.map = r.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(r.map), (t.measure.caches || (t.measure.caches = [])).push({}));\n        }\n        if (ne) {\n          var s = r.content.lastChild;\n          (/\\bcm-tab\\b/.test(s.className) || s.querySelector && s.querySelector(\".cm-tab\")) && (r.content.className = \"cm-tab-wrap-hack\");\n        }\n        return U(e, \"renderLine\", e, t.line, r.pre), r.pre.className && (r.textClass = di(r.pre.className, r.textClass || \"\")), r;\n      }\n      u(ol, \"buildLineContent\");\n      function Ta(e) {\n        var t = T(\"span\", \"•\", \"cm-invalidchar\");\n        return t.title = \"\\\\u\" + e.charCodeAt(0).toString(16), t.setAttribute(\"aria-label\", t.title), t;\n      }\n      u(Ta, \"defaultSpecialCharPlaceholder\");\n      function Ma(e, t, i, r, n, l, o) {\n        if (t) {\n          var a = e.splitSpaces ? Da(t, e.trailingSpace) : t, s = e.cm.state.specialChars, f = !1, h;\n          if (!s.test(t))\n            e.col += t.length, h = document.createTextNode(a), e.map.push(e.pos, e.pos + t.length, h), O && I < 9 && (f = !0), e.pos += t.length;\n          else {\n            h = document.createDocumentFragment();\n            for (var c = 0; ; ) {\n              s.lastIndex = c;\n              var p = s.exec(t), d = p ? p.index - c : t.length - c;\n              if (d) {\n                var v = document.createTextNode(a.slice(c, c + d));\n                O && I < 9 ? h.appendChild(T(\"span\", [v])) : h.appendChild(v), e.map.push(e.pos, e.pos + d, v), e.col += d, e.pos += d;\n              }\n              if (!p)\n                break;\n              c += d + 1;\n              var g = void 0;\n              if (p[0] == \"\t\") {\n                var m = e.cm.options.tabSize, b = m - e.col % m;\n                g = h.appendChild(T(\"span\", yi(b), \"cm-tab\")), g.setAttribute(\"role\", \"presentation\"), g.setAttribute(\"cm-text\", \"\t\"), e.col += b;\n              } else\n                p[0] == \"\\r\" || p[0] == `\n` ? (g = h.appendChild(T(\"span\", p[0] == \"\\r\" ? \"␍\" : \"␤\", \"cm-invalidchar\")), g.setAttribute(\"cm-text\", p[0]), e.col += 1) : (g = e.cm.options.specialCharPlaceholder(p[0]), g.setAttribute(\"cm-text\", p[0]), O && I < 9 ? h.appendChild(T(\"span\", [g])) : h.appendChild(g), e.col += 1);\n              e.map.push(e.pos, e.pos + 1, g), e.pos++;\n            }\n          }\n          if (e.trailingSpace = a.charCodeAt(t.length - 1) == 32, i || r || n || f || l || o) {\n            var C = i || \"\";\n            r && (C += r), n && (C += n);\n            var x = T(\"span\", [h], C, l);\n            if (o)\n              for (var w in o)\n                o.hasOwnProperty(w) && w != \"style\" && w != \"class\" && x.setAttribute(w, o[w]);\n            return e.content.appendChild(x);\n          }\n          e.content.appendChild(h);\n        }\n      }\n      u(Ma, \"buildToken\");\n      function Da(e, t) {\n        if (e.length > 1 && !/  /.test(e))\n          return e;\n        for (var i = t, r = \"\", n = 0; n < e.length; n++) {\n          var l = e.charAt(n);\n          l == \" \" && i && (n == e.length - 1 || e.charCodeAt(n + 1) == 32) && (l = \" \"), r += l, i = l == \" \";\n        }\n        return r;\n      }\n      u(Da, \"splitSpaces\");\n      function Na(e, t) {\n        return function(i, r, n, l, o, a, s) {\n          n = n ? n + \" cm-force-border\" : \"cm-force-border\";\n          for (var f = i.pos, h = f + r.length; ; ) {\n            for (var c = void 0, p = 0; p < t.length && (c = t[p], !(c.to > f && c.from <= f)); p++)\n              ;\n            if (c.to >= h)\n              return e(i, r, n, l, o, a, s);\n            e(i, r.slice(0, c.to - f), n, l, null, a, s), l = null, r = r.slice(c.to - f), f = c.to;\n          }\n        };\n      }\n      u(Na, \"buildTokenBadBidi\");\n      function al(e, t, i, r) {\n        var n = !r && i.widgetNode;\n        n && e.map.push(e.pos, e.pos + t, n), !r && e.cm.display.input.needsContentAttribute && (n || (n = e.content.appendChild(document.createElement(\"span\"))), n.setAttribute(\"cm-marker\", i.id)), n && (e.cm.display.input.setUneditable(n), e.content.appendChild(n)), e.pos += t, e.trailingSpace = !1;\n      }\n      u(al, \"buildCollapsedSpan\");\n      function Aa(e, t, i) {\n        var r = e.markedSpans, n = e.text, l = 0;\n        if (!r) {\n          for (var o = 1; o < i.length; o += 2)\n            t.addToken(t, n.slice(l, l = i[o]), ll(i[o + 1], t.cm.options));\n          return;\n        }\n        for (var a = n.length, s = 0, f = 1, h = \"\", c, p, d = 0, v, g, m, b, C; ; ) {\n          if (d == s) {\n            v = g = m = p = \"\", C = null, b = null, d = 1 / 0;\n            for (var x = [], w = void 0, k = 0; k < r.length; ++k) {\n              var L = r[k], A = L.marker;\n              if (A.type == \"bookmark\" && L.from == s && A.widgetNode)\n                x.push(A);\n              else if (L.from <= s && (L.to == null || L.to > s || A.collapsed && L.to == s && L.from == s)) {\n                if (L.to != null && L.to != s && d > L.to && (d = L.to, g = \"\"), A.className && (v += \" \" + A.className), A.css && (p = (p ? p + \";\" : \"\") + A.css), A.startStyle && L.from == s && (m += \" \" + A.startStyle), A.endStyle && L.to == d && (w || (w = [])).push(A.endStyle, L.to), A.title && ((C || (C = {})).title = A.title), A.attributes)\n                  for (var E in A.attributes)\n                    (C || (C = {}))[E] = A.attributes[E];\n                A.collapsed && (!b || Ii(b.marker, A) < 0) && (b = L);\n              } else\n                L.from > s && d > L.from && (d = L.from);\n            }\n            if (w)\n              for (var j = 0; j < w.length; j += 2)\n                w[j + 1] == d && (g += \" \" + w[j]);\n            if (!b || b.from == s)\n              for (var B = 0; B < x.length; ++B)\n                al(t, 0, x[B]);\n            if (b && (b.from || 0) == s) {\n              if (al(\n                t,\n                (b.to == null ? a + 1 : b.to) - s,\n                b.marker,\n                b.from == null\n              ), b.to == null)\n                return;\n              b.to == s && (b = !1);\n            }\n          }\n          if (s >= a)\n            break;\n          for (var pe = Math.min(a, d); ; ) {\n            if (h) {\n              var fe = s + h.length;\n              if (!b) {\n                var _ = fe > pe ? h.slice(0, pe - s) : h;\n                t.addToken(\n                  t,\n                  _,\n                  c ? c + v : v,\n                  m,\n                  s + _.length == d ? g : \"\",\n                  p,\n                  C\n                );\n              }\n              if (fe >= pe) {\n                h = h.slice(pe - s), s = pe;\n                break;\n              }\n              s = fe, m = \"\";\n            }\n            h = n.slice(l, l = i[f++]), c = ll(i[f++], t.cm.options);\n          }\n        }\n      }\n      u(Aa, \"insertLineContent\");\n      function sl(e, t, i) {\n        this.line = t, this.rest = Ca(t), this.size = this.rest ? F(H(this.rest)) - i + 1 : 1, this.node = this.text = null, this.hidden = Xe(e, t);\n      }\n      u(sl, \"LineView\");\n      function Ur(e, t, i) {\n        for (var r = [], n, l = t; l < i; l = n) {\n          var o = new sl(e.doc, S(e.doc, l), l);\n          n = l + o.size, r.push(o);\n        }\n        return r;\n      }\n      u(Ur, \"buildViewArray\");\n      var Lt = null;\n      function Oa(e) {\n        Lt ? Lt.ops.push(e) : e.ownsGroup = Lt = {\n          ops: [e],\n          delayedCallbacks: []\n        };\n      }\n      u(Oa, \"pushOperation\");\n      function Wa(e) {\n        var t = e.delayedCallbacks, i = 0;\n        do {\n          for (; i < t.length; i++)\n            t[i].call(null);\n          for (var r = 0; r < e.ops.length; r++) {\n            var n = e.ops[r];\n            if (n.cursorActivityHandlers)\n              for (; n.cursorActivityCalled < n.cursorActivityHandlers.length; )\n                n.cursorActivityHandlers[n.cursorActivityCalled++].call(null, n.cm);\n          }\n        } while (i < t.length);\n      }\n      u(Wa, \"fireCallbacksForOps\");\n      function Ha(e, t) {\n        var i = e.ownsGroup;\n        if (i)\n          try {\n            Wa(i);\n          } finally {\n            Lt = null, t(i);\n          }\n      }\n      u(Ha, \"finishOperation\");\n      var $t = null;\n      function Z(e, t) {\n        var i = xi(e, t);\n        if (i.length) {\n          var r = Array.prototype.slice.call(arguments, 2), n;\n          Lt ? n = Lt.delayedCallbacks : $t ? n = $t : (n = $t = [], setTimeout(Fa, 0));\n          for (var l = /* @__PURE__ */ u(function(a) {\n            n.push(function() {\n              return i[a].apply(null, r);\n            });\n          }, \"loop\"), o = 0; o < i.length; ++o)\n            l(o);\n        }\n      }\n      u(Z, \"signalLater\");\n      function Fa() {\n        var e = $t;\n        $t = null;\n        for (var t = 0; t < e.length; ++t)\n          e[t]();\n      }\n      u(Fa, \"fireOrphanDelayed\");\n      function ul(e, t, i, r) {\n        for (var n = 0; n < t.changes.length; n++) {\n          var l = t.changes[n];\n          l == \"text\" ? Ea(e, t) : l == \"gutter\" ? hl(e, t, i, r) : l == \"class\" ? Gi(e, t) : l == \"widget\" && Ia(e, t, r);\n        }\n        t.changes = null;\n      }\n      u(ul, \"updateLineForChanges\");\n      function er(e) {\n        return e.node == e.text && (e.node = T(\"div\", null, null, \"position: relative\"), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), O && I < 8 && (e.node.style.zIndex = 2)), e.node;\n      }\n      u(er, \"ensureLineWrapped\");\n      function Pa(e, t) {\n        var i = t.bgClass ? t.bgClass + \" \" + (t.line.bgClass || \"\") : t.line.bgClass;\n        if (i && (i += \" CodeMirror-linebackground\"), t.background)\n          i ? t.background.className = i : (t.background.parentNode.removeChild(t.background), t.background = null);\n        else if (i) {\n          var r = er(t);\n          t.background = r.insertBefore(T(\"div\", null, i), r.firstChild), e.display.input.setUneditable(t.background);\n        }\n      }\n      u(Pa, \"updateLineBackground\");\n      function fl(e, t) {\n        var i = e.display.externalMeasured;\n        return i && i.line == t.line ? (e.display.externalMeasured = null, t.measure = i.measure, i.built) : ol(e, t);\n      }\n      u(fl, \"getLineContent\");\n      function Ea(e, t) {\n        var i = t.text.className, r = fl(e, t);\n        t.text == t.node && (t.node = r.pre), t.text.parentNode.replaceChild(r.pre, t.text), t.text = r.pre, r.bgClass != t.bgClass || r.textClass != t.textClass ? (t.bgClass = r.bgClass, t.textClass = r.textClass, Gi(e, t)) : i && (t.text.className = i);\n      }\n      u(Ea, \"updateLineText\");\n      function Gi(e, t) {\n        Pa(e, t), t.line.wrapClass ? er(t).className = t.line.wrapClass : t.node != t.text && (t.node.className = \"\");\n        var i = t.textClass ? t.textClass + \" \" + (t.line.textClass || \"\") : t.line.textClass;\n        t.text.className = i || \"\";\n      }\n      u(Gi, \"updateLineClasses\");\n      function hl(e, t, i, r) {\n        if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass) {\n          var n = er(t);\n          t.gutterBackground = T(\n            \"div\",\n            null,\n            \"CodeMirror-gutter-background \" + t.line.gutterClass,\n            \"left: \" + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + \"px; width: \" + r.gutterTotalWidth + \"px\"\n          ), e.display.input.setUneditable(t.gutterBackground), n.insertBefore(t.gutterBackground, t.text);\n        }\n        var l = t.line.gutterMarkers;\n        if (e.options.lineNumbers || l) {\n          var o = er(t), a = t.gutter = T(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + \"px\");\n          if (a.setAttribute(\"aria-hidden\", \"true\"), e.display.input.setUneditable(a), o.insertBefore(a, t.text), t.line.gutterClass && (a.className += \" \" + t.line.gutterClass), e.options.lineNumbers && (!l || !l[\"CodeMirror-linenumbers\"]) && (t.lineNumber = a.appendChild(\n            T(\n              \"div\",\n              Oi(e.options, i),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + r.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \" + e.display.lineNumInnerWidth + \"px\"\n            )\n          )), l)\n            for (var s = 0; s < e.display.gutterSpecs.length; ++s) {\n              var f = e.display.gutterSpecs[s].className, h = l.hasOwnProperty(f) && l[f];\n              h && a.appendChild(T(\n                \"div\",\n                [h],\n                \"CodeMirror-gutter-elt\",\n                \"left: \" + r.gutterLeft[f] + \"px; width: \" + r.gutterWidth[f] + \"px\"\n              ));\n            }\n        }\n      }\n      u(hl, \"updateLineGutter\");\n      function Ia(e, t, i) {\n        t.alignable && (t.alignable = null);\n        for (var r = mt(\"CodeMirror-linewidget\"), n = t.node.firstChild, l = void 0; n; n = l)\n          l = n.nextSibling, r.test(n.className) && t.node.removeChild(n);\n        cl(e, t, i);\n      }\n      u(Ia, \"updateLineWidgets\");\n      function Ra(e, t, i, r) {\n        var n = fl(e, t);\n        return t.text = t.node = n.pre, n.bgClass && (t.bgClass = n.bgClass), n.textClass && (t.textClass = n.textClass), Gi(e, t), hl(e, t, i, r), cl(e, t, r), t.node;\n      }\n      u(Ra, \"buildLineElement\");\n      function cl(e, t, i) {\n        if (dl(e, t.line, t, i, !0), t.rest)\n          for (var r = 0; r < t.rest.length; r++)\n            dl(e, t.rest[r], t, i, !1);\n      }\n      u(cl, \"insertLineWidgets\");\n      function dl(e, t, i, r, n) {\n        if (t.widgets)\n          for (var l = er(i), o = 0, a = t.widgets; o < a.length; ++o) {\n            var s = a[o], f = T(\"div\", [s.node], \"CodeMirror-linewidget\" + (s.className ? \" \" + s.className : \"\"));\n            s.handleMouseEvents || f.setAttribute(\"cm-ignore-events\", \"true\"), Ba(s, f, i, r), e.display.input.setUneditable(f), n && s.above ? l.insertBefore(f, i.gutter || i.text) : l.appendChild(f), Z(s, \"redraw\");\n          }\n      }\n      u(dl, \"insertLineWidgetsFor\");\n      function Ba(e, t, i, r) {\n        if (e.noHScroll) {\n          (i.alignable || (i.alignable = [])).push(t);\n          var n = r.wrapperWidth;\n          t.style.left = r.fixedPos + \"px\", e.coverGutter || (n -= r.gutterTotalWidth, t.style.paddingLeft = r.gutterTotalWidth + \"px\"), t.style.width = n + \"px\";\n        }\n        e.coverGutter && (t.style.zIndex = 5, t.style.position = \"relative\", e.noHScroll || (t.style.marginLeft = -r.gutterTotalWidth + \"px\"));\n      }\n      u(Ba, \"positionLineWidget\");\n      function tr(e) {\n        if (e.height != null)\n          return e.height;\n        var t = e.doc.cm;\n        if (!t)\n          return 0;\n        if (!Ke(document.body, e.node)) {\n          var i = \"position: relative;\";\n          e.coverGutter && (i += \"margin-left: -\" + t.display.gutters.offsetWidth + \"px;\"), e.noHScroll && (i += \"width: \" + t.display.wrapper.clientWidth + \"px;\"), ve(t.display.measure, T(\"div\", [e.node], null, i));\n        }\n        return e.height = e.node.parentNode.offsetHeight;\n      }\n      u(tr, \"widgetHeight\");\n      function Re(e, t) {\n        for (var i = wi(t); i != e.wrapper; i = i.parentNode)\n          if (!i || i.nodeType == 1 && i.getAttribute(\"cm-ignore-events\") == \"true\" || i.parentNode == e.sizer && i != e.mover)\n            return !0;\n      }\n      u(Re, \"eventInWidget\");\n      function Kr(e) {\n        return e.lineSpace.offsetTop;\n      }\n      u(Kr, \"paddingTop\");\n      function Ui(e) {\n        return e.mover.offsetHeight - e.lineSpace.offsetHeight;\n      }\n      u(Ui, \"paddingVert\");\n      function pl(e) {\n        if (e.cachedPaddingH)\n          return e.cachedPaddingH;\n        var t = ve(e.measure, T(\"pre\", \"x\", \"CodeMirror-line-like\")), i = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle, r = { left: parseInt(i.paddingLeft), right: parseInt(i.paddingRight) };\n        return !isNaN(r.left) && !isNaN(r.right) && (e.cachedPaddingH = r), r;\n      }\n      u(pl, \"paddingH\");\n      function Ae(e) {\n        return Wn - e.display.nativeBarWidth;\n      }\n      u(Ae, \"scrollGap\");\n      function st(e) {\n        return e.display.scroller.clientWidth - Ae(e) - e.display.barWidth;\n      }\n      u(st, \"displayWidth\");\n      function Ki(e) {\n        return e.display.scroller.clientHeight - Ae(e) - e.display.barHeight;\n      }\n      u(Ki, \"displayHeight\");\n      function za(e, t, i) {\n        var r = e.options.lineWrapping, n = r && st(e);\n        if (!t.measure.heights || r && t.measure.width != n) {\n          var l = t.measure.heights = [];\n          if (r) {\n            t.measure.width = n;\n            for (var o = t.text.firstChild.getClientRects(), a = 0; a < o.length - 1; a++) {\n              var s = o[a], f = o[a + 1];\n              Math.abs(s.bottom - f.bottom) > 2 && l.push((s.bottom + f.top) / 2 - i.top);\n            }\n          }\n          l.push(i.bottom - i.top);\n        }\n      }\n      u(za, \"ensureLineHeights\");\n      function vl(e, t, i) {\n        if (e.line == t)\n          return { map: e.measure.map, cache: e.measure.cache };\n        if (e.rest) {\n          for (var r = 0; r < e.rest.length; r++)\n            if (e.rest[r] == t)\n              return { map: e.measure.maps[r], cache: e.measure.caches[r] };\n          for (var n = 0; n < e.rest.length; n++)\n            if (F(e.rest[n]) > i)\n              return { map: e.measure.maps[n], cache: e.measure.caches[n], before: !0 };\n        }\n      }\n      u(vl, \"mapFromLineView\");\n      function Ga(e, t) {\n        t = Se(t);\n        var i = F(t), r = e.display.externalMeasured = new sl(e.doc, t, i);\n        r.lineN = i;\n        var n = r.built = ol(e, r);\n        return r.text = n.pre, ve(e.display.lineMeasure, n.pre), r;\n      }\n      u(Ga, \"updateExternalMeasurement\");\n      function gl(e, t, i, r) {\n        return Oe(e, kt(e, t), i, r);\n      }\n      u(gl, \"measureChar\");\n      function _i(e, t) {\n        if (t >= e.display.viewFrom && t < e.display.viewTo)\n          return e.display.view[ht(e, t)];\n        var i = e.display.externalMeasured;\n        if (i && t >= i.lineN && t < i.lineN + i.size)\n          return i;\n      }\n      u(_i, \"findViewForLine\");\n      function kt(e, t) {\n        var i = F(t), r = _i(e, i);\n        r && !r.text ? r = null : r && r.changes && (ul(e, r, i, Qi(e)), e.curOp.forceUpdate = !0), r || (r = Ga(e, t));\n        var n = vl(r, t, i);\n        return {\n          line: t,\n          view: r,\n          rect: null,\n          map: n.map,\n          cache: n.cache,\n          before: n.before,\n          hasHeights: !1\n        };\n      }\n      u(kt, \"prepareMeasureForLine\");\n      function Oe(e, t, i, r, n) {\n        t.before && (i = -1);\n        var l = i + (r || \"\"), o;\n        return t.cache.hasOwnProperty(l) ? o = t.cache[l] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (za(e, t.view, t.rect), t.hasHeights = !0), o = Ka(e, t, i, r), o.bogus || (t.cache[l] = o)), {\n          left: o.left,\n          right: o.right,\n          top: n ? o.rtop : o.top,\n          bottom: n ? o.rbottom : o.bottom\n        };\n      }\n      u(Oe, \"measureCharPrepared\");\n      var yl = { left: 0, right: 0, top: 0, bottom: 0 };\n      function ml(e, t, i) {\n        for (var r, n, l, o, a, s, f = 0; f < e.length; f += 3)\n          if (a = e[f], s = e[f + 1], t < a ? (n = 0, l = 1, o = \"left\") : t < s ? (n = t - a, l = n + 1) : (f == e.length - 3 || t == s && e[f + 3] > t) && (l = s - a, n = l - 1, t >= s && (o = \"right\")), n != null) {\n            if (r = e[f + 2], a == s && i == (r.insertLeft ? \"left\" : \"right\") && (o = i), i == \"left\" && n == 0)\n              for (; f && e[f - 2] == e[f - 3] && e[f - 1].insertLeft; )\n                r = e[(f -= 3) + 2], o = \"left\";\n            if (i == \"right\" && n == s - a)\n              for (; f < e.length - 3 && e[f + 3] == e[f + 4] && !e[f + 5].insertLeft; )\n                r = e[(f += 3) + 2], o = \"right\";\n            break;\n          }\n        return { node: r, start: n, end: l, collapse: o, coverStart: a, coverEnd: s };\n      }\n      u(ml, \"nodeAndOffsetInLineMap\");\n      function Ua(e, t) {\n        var i = yl;\n        if (t == \"left\")\n          for (var r = 0; r < e.length && (i = e[r]).left == i.right; r++)\n            ;\n        else\n          for (var n = e.length - 1; n >= 0 && (i = e[n]).left == i.right; n--)\n            ;\n        return i;\n      }\n      u(Ua, \"getUsefulRect\");\n      function Ka(e, t, i, r) {\n        var n = ml(t.map, i, r), l = n.node, o = n.start, a = n.end, s = n.collapse, f;\n        if (l.nodeType == 3) {\n          for (var h = 0; h < 4; h++) {\n            for (; o && bi(t.line.text.charAt(n.coverStart + o)); )\n              --o;\n            for (; n.coverStart + a < n.coverEnd && bi(t.line.text.charAt(n.coverStart + a)); )\n              ++a;\n            if (O && I < 9 && o == 0 && a == n.coverEnd - n.coverStart ? f = l.parentNode.getBoundingClientRect() : f = Ua(rt(l, o, a).getClientRects(), r), f.left || f.right || o == 0)\n              break;\n            a = o, o = o - 1, s = \"right\";\n          }\n          O && I < 11 && (f = _a(e.display.measure, f));\n        } else {\n          o > 0 && (s = r = \"right\");\n          var c;\n          e.options.lineWrapping && (c = l.getClientRects()).length > 1 ? f = c[r == \"right\" ? c.length - 1 : 0] : f = l.getBoundingClientRect();\n        }\n        if (O && I < 9 && !o && (!f || !f.left && !f.right)) {\n          var p = l.parentNode.getClientRects()[0];\n          p ? f = { left: p.left, right: p.left + Mt(e.display), top: p.top, bottom: p.bottom } : f = yl;\n        }\n        for (var d = f.top - t.rect.top, v = f.bottom - t.rect.top, g = (d + v) / 2, m = t.view.measure.heights, b = 0; b < m.length - 1 && !(g < m[b]); b++)\n          ;\n        var C = b ? m[b - 1] : 0, x = m[b], w = {\n          left: (s == \"right\" ? f.right : f.left) - t.rect.left,\n          right: (s == \"left\" ? f.left : f.right) - t.rect.left,\n          top: C,\n          bottom: x\n        };\n        return !f.left && !f.right && (w.bogus = !0), e.options.singleCursorHeightPerLine || (w.rtop = d, w.rbottom = v), w;\n      }\n      u(Ka, \"measureCharInner\");\n      function _a(e, t) {\n        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !la(e))\n          return t;\n        var i = screen.logicalXDPI / screen.deviceXDPI, r = screen.logicalYDPI / screen.deviceYDPI;\n        return {\n          left: t.left * i,\n          right: t.right * i,\n          top: t.top * r,\n          bottom: t.bottom * r\n        };\n      }\n      u(_a, \"maybeUpdateRectForZooming\");\n      function bl(e) {\n        if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest))\n          for (var t = 0; t < e.rest.length; t++)\n            e.measure.caches[t] = {};\n      }\n      u(bl, \"clearLineMeasurementCacheFor\");\n      function xl(e) {\n        e.display.externalMeasure = null, Ue(e.display.lineMeasure);\n        for (var t = 0; t < e.display.view.length; t++)\n          bl(e.display.view[t]);\n      }\n      u(xl, \"clearLineMeasurementCache\");\n      function rr(e) {\n        xl(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null;\n      }\n      u(rr, \"clearCaches\");\n      function Cl() {\n        return Tr && Dr ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft;\n      }\n      u(Cl, \"pageScrollX\");\n      function wl() {\n        return Tr && Dr ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop;\n      }\n      u(wl, \"pageScrollY\");\n      function Xi(e) {\n        var t = Se(e), i = t.widgets, r = 0;\n        if (i)\n          for (var n = 0; n < i.length; ++n)\n            i[n].above && (r += tr(i[n]));\n        return r;\n      }\n      u(Xi, \"widgetTopHeight\");\n      function _r(e, t, i, r, n) {\n        if (!n) {\n          var l = Xi(t);\n          i.top += l, i.bottom += l;\n        }\n        if (r == \"line\")\n          return i;\n        r || (r = \"local\");\n        var o = Ie(t);\n        if (r == \"local\" ? o += Kr(e.display) : o -= e.display.viewOffset, r == \"page\" || r == \"window\") {\n          var a = e.display.lineSpace.getBoundingClientRect();\n          o += a.top + (r == \"window\" ? 0 : wl());\n          var s = a.left + (r == \"window\" ? 0 : Cl());\n          i.left += s, i.right += s;\n        }\n        return i.top += o, i.bottom += o, i;\n      }\n      u(_r, \"intoCoordSystem\");\n      function Sl(e, t, i) {\n        if (i == \"div\")\n          return t;\n        var r = t.left, n = t.top;\n        if (i == \"page\")\n          r -= Cl(), n -= wl();\n        else if (i == \"local\" || !i) {\n          var l = e.display.sizer.getBoundingClientRect();\n          r += l.left, n += l.top;\n        }\n        var o = e.display.lineSpace.getBoundingClientRect();\n        return { left: r - o.left, top: n - o.top };\n      }\n      u(Sl, \"fromCoordSystem\");\n      function Xr(e, t, i, r, n) {\n        return r || (r = S(e.doc, t.line)), _r(e, r, gl(e, r, t.ch, n), i);\n      }\n      u(Xr, \"charCoords\");\n      function Le(e, t, i, r, n, l) {\n        r = r || S(e.doc, t.line), n || (n = kt(e, r));\n        function o(v, g) {\n          var m = Oe(e, n, v, g ? \"right\" : \"left\", l);\n          return g ? m.left = m.right : m.right = m.left, _r(e, r, m, i);\n        }\n        u(o, \"get\");\n        var a = Pe(r, e.doc.direction), s = t.ch, f = t.sticky;\n        if (s >= r.text.length ? (s = r.text.length, f = \"before\") : s <= 0 && (s = 0, f = \"after\"), !a)\n          return o(f == \"before\" ? s - 1 : s, f == \"before\");\n        function h(v, g, m) {\n          var b = a[g], C = b.level == 1;\n          return o(m ? v - 1 : v, C != m);\n        }\n        u(h, \"getBidi\");\n        var c = Zt(a, s, f), p = qt, d = h(s, c, f == \"before\");\n        return p != null && (d.other = h(s, p, f != \"before\")), d;\n      }\n      u(Le, \"cursorCoords\");\n      function Ll(e, t) {\n        var i = 0;\n        t = N(e.doc, t), e.options.lineWrapping || (i = Mt(e.display) * t.ch);\n        var r = S(e.doc, t.line), n = Ie(r) + Kr(e.display);\n        return { left: i, right: i, top: n, bottom: n + r.height };\n      }\n      u(Ll, \"estimateCoords\");\n      function Yi(e, t, i, r, n) {\n        var l = y(e, t, i);\n        return l.xRel = n, r && (l.outside = r), l;\n      }\n      u(Yi, \"PosWithInfo\");\n      function qi(e, t, i) {\n        var r = e.doc;\n        if (i += e.display.viewOffset, i < 0)\n          return Yi(r.first, 0, null, -1, -1);\n        var n = at(r, i), l = r.first + r.size - 1;\n        if (n > l)\n          return Yi(r.first + r.size - 1, S(r, l).text.length, null, 1, 1);\n        t < 0 && (t = 0);\n        for (var o = S(r, n); ; ) {\n          var a = Xa(e, o, n, t, i), s = ba(o, a.ch + (a.xRel > 0 || a.outside > 0 ? 1 : 0));\n          if (!s)\n            return a;\n          var f = s.find(1);\n          if (f.line == n)\n            return f;\n          o = S(r, n = f.line);\n        }\n      }\n      u(qi, \"coordsChar\");\n      function kl(e, t, i, r) {\n        r -= Xi(t);\n        var n = t.text.length, l = Yt(function(o) {\n          return Oe(e, i, o - 1).bottom <= r;\n        }, n, 0);\n        return n = Yt(function(o) {\n          return Oe(e, i, o).top > r;\n        }, l, n), { begin: l, end: n };\n      }\n      u(kl, \"wrappedLineExtent\");\n      function Tl(e, t, i, r) {\n        i || (i = kt(e, t));\n        var n = _r(e, t, Oe(e, i, r), \"line\").top;\n        return kl(e, t, i, n);\n      }\n      u(Tl, \"wrappedLineExtentChar\");\n      function Zi(e, t, i, r) {\n        return e.bottom <= i ? !1 : e.top > i ? !0 : (r ? e.left : e.right) > t;\n      }\n      u(Zi, \"boxIsAfter\");\n      function Xa(e, t, i, r, n) {\n        n -= Ie(t);\n        var l = kt(e, t), o = Xi(t), a = 0, s = t.text.length, f = !0, h = Pe(t, e.doc.direction);\n        if (h) {\n          var c = (e.options.lineWrapping ? qa : Ya)(e, t, i, l, h, r, n);\n          f = c.level != 1, a = f ? c.from : c.to - 1, s = f ? c.to : c.from - 1;\n        }\n        var p = null, d = null, v = Yt(function(k) {\n          var L = Oe(e, l, k);\n          return L.top += o, L.bottom += o, Zi(L, r, n, !1) ? (L.top <= n && L.left <= r && (p = k, d = L), !0) : !1;\n        }, a, s), g, m, b = !1;\n        if (d) {\n          var C = r - d.left < d.right - r, x = C == f;\n          v = p + (x ? 0 : 1), m = x ? \"after\" : \"before\", g = C ? d.left : d.right;\n        } else {\n          !f && (v == s || v == a) && v++, m = v == 0 ? \"after\" : v == t.text.length ? \"before\" : Oe(e, l, v - (f ? 1 : 0)).bottom + o <= n == f ? \"after\" : \"before\";\n          var w = Le(e, y(i, v, m), \"line\", t, l);\n          g = w.left, b = n < w.top ? -1 : n >= w.bottom ? 1 : 0;\n        }\n        return v = En(t.text, v, 1), Yi(i, v, m, b, r - g);\n      }\n      u(Xa, \"coordsCharInner\");\n      function Ya(e, t, i, r, n, l, o) {\n        var a = Yt(function(c) {\n          var p = n[c], d = p.level != 1;\n          return Zi(Le(\n            e,\n            y(i, d ? p.to : p.from, d ? \"before\" : \"after\"),\n            \"line\",\n            t,\n            r\n          ), l, o, !0);\n        }, 0, n.length - 1), s = n[a];\n        if (a > 0) {\n          var f = s.level != 1, h = Le(\n            e,\n            y(i, f ? s.from : s.to, f ? \"after\" : \"before\"),\n            \"line\",\n            t,\n            r\n          );\n          Zi(h, l, o, !0) && h.top > o && (s = n[a - 1]);\n        }\n        return s;\n      }\n      u(Ya, \"coordsBidiPart\");\n      function qa(e, t, i, r, n, l, o) {\n        var a = kl(e, t, r, o), s = a.begin, f = a.end;\n        /\\s/.test(t.text.charAt(f - 1)) && f--;\n        for (var h = null, c = null, p = 0; p < n.length; p++) {\n          var d = n[p];\n          if (!(d.from >= f || d.to <= s)) {\n            var v = d.level != 1, g = Oe(e, r, v ? Math.min(f, d.to) - 1 : Math.max(s, d.from)).right, m = g < l ? l - g + 1e9 : g - l;\n            (!h || c > m) && (h = d, c = m);\n          }\n        }\n        return h || (h = n[n.length - 1]), h.from < s && (h = { from: s, to: h.to, level: h.level }), h.to > f && (h = { from: h.from, to: f, level: h.level }), h;\n      }\n      u(qa, \"coordsBidiPartWrapped\");\n      var ut;\n      function Tt(e) {\n        if (e.cachedTextHeight != null)\n          return e.cachedTextHeight;\n        if (ut == null) {\n          ut = T(\"pre\", null, \"CodeMirror-line-like\");\n          for (var t = 0; t < 49; ++t)\n            ut.appendChild(document.createTextNode(\"x\")), ut.appendChild(T(\"br\"));\n          ut.appendChild(document.createTextNode(\"x\"));\n        }\n        ve(e.measure, ut);\n        var i = ut.offsetHeight / 50;\n        return i > 3 && (e.cachedTextHeight = i), Ue(e.measure), i || 1;\n      }\n      u(Tt, \"textHeight\");\n      function Mt(e) {\n        if (e.cachedCharWidth != null)\n          return e.cachedCharWidth;\n        var t = T(\"span\", \"xxxxxxxxxx\"), i = T(\"pre\", [t], \"CodeMirror-line-like\");\n        ve(e.measure, i);\n        var r = t.getBoundingClientRect(), n = (r.right - r.left) / 10;\n        return n > 2 && (e.cachedCharWidth = n), n || 10;\n      }\n      u(Mt, \"charWidth\");\n      function Qi(e) {\n        for (var t = e.display, i = {}, r = {}, n = t.gutters.clientLeft, l = t.gutters.firstChild, o = 0; l; l = l.nextSibling, ++o) {\n          var a = e.display.gutterSpecs[o].className;\n          i[a] = l.offsetLeft + l.clientLeft + n, r[a] = l.clientWidth;\n        }\n        return {\n          fixedPos: Ji(t),\n          gutterTotalWidth: t.gutters.offsetWidth,\n          gutterLeft: i,\n          gutterWidth: r,\n          wrapperWidth: t.wrapper.clientWidth\n        };\n      }\n      u(Qi, \"getDimensions\");\n      function Ji(e) {\n        return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left;\n      }\n      u(Ji, \"compensateForHScroll\");\n      function Ml(e) {\n        var t = Tt(e.display), i = e.options.lineWrapping, r = i && Math.max(5, e.display.scroller.clientWidth / Mt(e.display) - 3);\n        return function(n) {\n          if (Xe(e.doc, n))\n            return 0;\n          var l = 0;\n          if (n.widgets)\n            for (var o = 0; o < n.widgets.length; o++)\n              n.widgets[o].height && (l += n.widgets[o].height);\n          return i ? l + (Math.ceil(n.text.length / r) || 1) * t : l + t;\n        };\n      }\n      u(Ml, \"estimateHeight\");\n      function ji(e) {\n        var t = e.doc, i = Ml(e);\n        t.iter(function(r) {\n          var n = i(r);\n          n != r.height && De(r, n);\n        });\n      }\n      u(ji, \"estimateLineHeights\");\n      function ft(e, t, i, r) {\n        var n = e.display;\n        if (!i && wi(t).getAttribute(\"cm-not-content\") == \"true\")\n          return null;\n        var l, o, a = n.lineSpace.getBoundingClientRect();\n        try {\n          l = t.clientX - a.left, o = t.clientY - a.top;\n        } catch {\n          return null;\n        }\n        var s = qi(e, l, o), f;\n        if (r && s.xRel > 0 && (f = S(e.doc, s.line).text).length == s.ch) {\n          var h = xe(f, f.length, e.options.tabSize) - f.length;\n          s = y(s.line, Math.max(0, Math.round((l - pl(e.display).left) / Mt(e.display)) - h));\n        }\n        return s;\n      }\n      u(ft, \"posFromMouse\");\n      function ht(e, t) {\n        if (t >= e.display.viewTo || (t -= e.display.viewFrom, t < 0))\n          return null;\n        for (var i = e.display.view, r = 0; r < i.length; r++)\n          if (t -= i[r].size, t < 0)\n            return r;\n      }\n      u(ht, \"findViewIndex\");\n      function se(e, t, i, r) {\n        t == null && (t = e.doc.first), i == null && (i = e.doc.first + e.doc.size), r || (r = 0);\n        var n = e.display;\n        if (r && i < n.viewTo && (n.updateLineNumbers == null || n.updateLineNumbers > t) && (n.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= n.viewTo)\n          Ee && Ri(e.doc, t) < n.viewTo && qe(e);\n        else if (i <= n.viewFrom)\n          Ee && nl(e.doc, i + r) > n.viewFrom ? qe(e) : (n.viewFrom += r, n.viewTo += r);\n        else if (t <= n.viewFrom && i >= n.viewTo)\n          qe(e);\n        else if (t <= n.viewFrom) {\n          var l = Yr(e, i, i + r, 1);\n          l ? (n.view = n.view.slice(l.index), n.viewFrom = l.lineN, n.viewTo += r) : qe(e);\n        } else if (i >= n.viewTo) {\n          var o = Yr(e, t, t, -1);\n          o ? (n.view = n.view.slice(0, o.index), n.viewTo = o.lineN) : qe(e);\n        } else {\n          var a = Yr(e, t, t, -1), s = Yr(e, i, i + r, 1);\n          a && s ? (n.view = n.view.slice(0, a.index).concat(Ur(e, a.lineN, s.lineN)).concat(n.view.slice(s.index)), n.viewTo += r) : qe(e);\n        }\n        var f = n.externalMeasured;\n        f && (i < f.lineN ? f.lineN += r : t < f.lineN + f.size && (n.externalMeasured = null));\n      }\n      u(se, \"regChange\");\n      function Ye(e, t, i) {\n        e.curOp.viewChanged = !0;\n        var r = e.display, n = e.display.externalMeasured;\n        if (n && t >= n.lineN && t < n.lineN + n.size && (r.externalMeasured = null), !(t < r.viewFrom || t >= r.viewTo)) {\n          var l = r.view[ht(e, t)];\n          if (l.node != null) {\n            var o = l.changes || (l.changes = []);\n            ee(o, i) == -1 && o.push(i);\n          }\n        }\n      }\n      u(Ye, \"regLineChange\");\n      function qe(e) {\n        e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0;\n      }\n      u(qe, \"resetView\");\n      function Yr(e, t, i, r) {\n        var n = ht(e, t), l, o = e.display.view;\n        if (!Ee || i == e.doc.first + e.doc.size)\n          return { index: n, lineN: i };\n        for (var a = e.display.viewFrom, s = 0; s < n; s++)\n          a += o[s].size;\n        if (a != t) {\n          if (r > 0) {\n            if (n == o.length - 1)\n              return null;\n            l = a + o[n].size - t, n++;\n          } else\n            l = a - t;\n          t += l, i += l;\n        }\n        for (; Ri(e.doc, i) != i; ) {\n          if (n == (r < 0 ? 0 : o.length - 1))\n            return null;\n          i += r * o[n - (r < 0 ? 1 : 0)].size, n += r;\n        }\n        return { index: n, lineN: i };\n      }\n      u(Yr, \"viewCuttingPoint\");\n      function Za(e, t, i) {\n        var r = e.display, n = r.view;\n        n.length == 0 || t >= r.viewTo || i <= r.viewFrom ? (r.view = Ur(e, t, i), r.viewFrom = t) : (r.viewFrom > t ? r.view = Ur(e, t, r.viewFrom).concat(r.view) : r.viewFrom < t && (r.view = r.view.slice(ht(e, t))), r.viewFrom = t, r.viewTo < i ? r.view = r.view.concat(Ur(e, r.viewTo, i)) : r.viewTo > i && (r.view = r.view.slice(0, ht(e, i)))), r.viewTo = i;\n      }\n      u(Za, \"adjustView\");\n      function Dl(e) {\n        for (var t = e.display.view, i = 0, r = 0; r < t.length; r++) {\n          var n = t[r];\n          !n.hidden && (!n.node || n.changes) && ++i;\n        }\n        return i;\n      }\n      u(Dl, \"countDirtyView\");\n      function ir(e) {\n        e.display.input.showSelection(e.display.input.prepareSelection());\n      }\n      u(ir, \"updateSelection\");\n      function Nl(e, t) {\n        t === void 0 && (t = !0);\n        var i = e.doc, r = {}, n = r.cursors = document.createDocumentFragment(), l = r.selection = document.createDocumentFragment(), o = e.options.$customCursor;\n        o && (t = !0);\n        for (var a = 0; a < i.sel.ranges.length; a++)\n          if (!(!t && a == i.sel.primIndex)) {\n            var s = i.sel.ranges[a];\n            if (!(s.from().line >= e.display.viewTo || s.to().line < e.display.viewFrom)) {\n              var f = s.empty();\n              if (o) {\n                var h = o(e, s);\n                h && Vi(e, h, n);\n              } else\n                (f || e.options.showCursorWhenSelecting) && Vi(e, s.head, n);\n              f || Qa(e, s, l);\n            }\n          }\n        return r;\n      }\n      u(Nl, \"prepareSelection\");\n      function Vi(e, t, i) {\n        var r = Le(e, t, \"div\", null, null, !e.options.singleCursorHeightPerLine), n = i.appendChild(T(\"div\", \" \", \"CodeMirror-cursor\"));\n        if (n.style.left = r.left + \"px\", n.style.top = r.top + \"px\", n.style.height = Math.max(0, r.bottom - r.top) * e.options.cursorHeight + \"px\", /\\bcm-fat-cursor\\b/.test(e.getWrapperElement().className)) {\n          var l = Xr(e, t, \"div\", null, null), o = l.right - l.left;\n          n.style.width = (o > 0 ? o : e.defaultCharWidth()) + \"px\";\n        }\n        if (r.other) {\n          var a = i.appendChild(T(\"div\", \" \", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n          a.style.display = \"\", a.style.left = r.other.left + \"px\", a.style.top = r.other.top + \"px\", a.style.height = (r.other.bottom - r.other.top) * 0.85 + \"px\";\n        }\n      }\n      u(Vi, \"drawSelectionCursor\");\n      function qr(e, t) {\n        return e.top - t.top || e.left - t.left;\n      }\n      u(qr, \"cmpCoords\");\n      function Qa(e, t, i) {\n        var r = e.display, n = e.doc, l = document.createDocumentFragment(), o = pl(e.display), a = o.left, s = Math.max(r.sizerWidth, st(e) - r.sizer.offsetLeft) - o.right, f = n.direction == \"ltr\";\n        function h(x, w, k, L) {\n          w < 0 && (w = 0), w = Math.round(w), L = Math.round(L), l.appendChild(T(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + x + `px;\n                             top: ` + w + \"px; width: \" + (k ?? s - x) + `px;\n                             height: ` + (L - w) + \"px\"));\n        }\n        u(h, \"add\");\n        function c(x, w, k) {\n          var L = S(n, x), A = L.text.length, E, j;\n          function B(_, he) {\n            return Xr(e, y(x, _), \"div\", L, he);\n          }\n          u(B, \"coords\");\n          function pe(_, he, $) {\n            var Y = Tl(e, L, null, _), X = he == \"ltr\" == ($ == \"after\") ? \"left\" : \"right\", z = $ == \"after\" ? Y.begin : Y.end - (/\\s/.test(L.text.charAt(Y.end - 1)) ? 2 : 1);\n            return B(z, X)[X];\n          }\n          u(pe, \"wrapX\");\n          var fe = Pe(L, n.direction);\n          return Vo(fe, w || 0, k ?? A, function(_, he, $, Y) {\n            var X = $ == \"ltr\", z = B(_, X ? \"left\" : \"right\"), ce = B(he - 1, X ? \"right\" : \"left\"), zt = w == null && _ == 0, $e = k == null && he == A, re = Y == 0, We = !fe || Y == fe.length - 1;\n            if (ce.top - z.top <= 3) {\n              var V = (f ? zt : $e) && re, kn = (f ? $e : zt) && We, Ge = V ? a : (X ? z : ce).left, gt = kn ? s : (X ? ce : z).right;\n              h(Ge, z.top, gt - Ge, z.bottom);\n            } else {\n              var yt, oe, Gt, Tn;\n              X ? (yt = f && zt && re ? a : z.left, oe = f ? s : pe(_, $, \"before\"), Gt = f ? a : pe(he, $, \"after\"), Tn = f && $e && We ? s : ce.right) : (yt = f ? pe(_, $, \"before\") : a, oe = !f && zt && re ? s : z.right, Gt = !f && $e && We ? a : ce.left, Tn = f ? pe(he, $, \"after\") : s), h(yt, z.top, oe - yt, z.bottom), z.bottom < ce.top && h(a, z.bottom, null, ce.top), h(Gt, ce.top, Tn - Gt, ce.bottom);\n            }\n            (!E || qr(z, E) < 0) && (E = z), qr(ce, E) < 0 && (E = ce), (!j || qr(z, j) < 0) && (j = z), qr(ce, j) < 0 && (j = ce);\n          }), { start: E, end: j };\n        }\n        u(c, \"drawForLine\");\n        var p = t.from(), d = t.to();\n        if (p.line == d.line)\n          c(p.line, p.ch, d.ch);\n        else {\n          var v = S(n, p.line), g = S(n, d.line), m = Se(v) == Se(g), b = c(p.line, p.ch, m ? v.text.length + 1 : null).end, C = c(d.line, m ? 0 : null, d.ch).start;\n          m && (b.top < C.top - 2 ? (h(b.right, b.top, null, b.bottom), h(a, C.top, C.left, C.bottom)) : h(b.right, b.top, C.left - b.right, b.bottom)), b.bottom < C.top && h(a, b.bottom, null, C.top);\n        }\n        i.appendChild(l);\n      }\n      u(Qa, \"drawSelectionRange\");\n      function $i(e) {\n        if (e.state.focused) {\n          var t = e.display;\n          clearInterval(t.blinker);\n          var i = !0;\n          t.cursorDiv.style.visibility = \"\", e.options.cursorBlinkRate > 0 ? t.blinker = setInterval(function() {\n            e.hasFocus() || Dt(e), t.cursorDiv.style.visibility = (i = !i) ? \"\" : \"hidden\";\n          }, e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = \"hidden\");\n        }\n      }\n      u($i, \"restartBlink\");\n      function Al(e) {\n        e.hasFocus() || (e.display.input.focus(), e.state.focused || tn(e));\n      }\n      u(Al, \"ensureFocus\");\n      function en(e) {\n        e.state.delayingBlurEvent = !0, setTimeout(function() {\n          e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, e.state.focused && Dt(e));\n        }, 100);\n      }\n      u(en, \"delayBlurEvent\");\n      function tn(e, t) {\n        e.state.delayingBlurEvent && !e.state.draggingText && (e.state.delayingBlurEvent = !1), e.options.readOnly != \"nocursor\" && (e.state.focused || (U(e, \"focus\", e, t), e.state.focused = !0, it(e.display.wrapper, \"CodeMirror-focused\"), !e.curOp && e.display.selForContextMenu != e.doc.sel && (e.display.input.reset(), ne && setTimeout(function() {\n          return e.display.input.reset(!0);\n        }, 20)), e.display.input.receivedFocus()), $i(e));\n      }\n      u(tn, \"onFocus\");\n      function Dt(e, t) {\n        e.state.delayingBlurEvent || (e.state.focused && (U(e, \"blur\", e, t), e.state.focused = !1, tt(e.display.wrapper, \"CodeMirror-focused\")), clearInterval(e.display.blinker), setTimeout(function() {\n          e.state.focused || (e.display.shift = !1);\n        }, 150));\n      }\n      u(Dt, \"onBlur\");\n      function Zr(e) {\n        for (var t = e.display, i = t.lineDiv.offsetTop, r = Math.max(0, t.scroller.getBoundingClientRect().top), n = t.lineDiv.getBoundingClientRect().top, l = 0, o = 0; o < t.view.length; o++) {\n          var a = t.view[o], s = e.options.lineWrapping, f = void 0, h = 0;\n          if (!a.hidden) {\n            if (n += a.line.height, O && I < 8) {\n              var c = a.node.offsetTop + a.node.offsetHeight;\n              f = c - i, i = c;\n            } else {\n              var p = a.node.getBoundingClientRect();\n              f = p.bottom - p.top, !s && a.text.firstChild && (h = a.text.firstChild.getBoundingClientRect().right - p.left - 1);\n            }\n            var d = a.line.height - f;\n            if ((d > 5e-3 || d < -5e-3) && (n < r && (l -= d), De(a.line, f), Ol(a.line), a.rest))\n              for (var v = 0; v < a.rest.length; v++)\n                Ol(a.rest[v]);\n            if (h > e.display.sizerWidth) {\n              var g = Math.ceil(h / Mt(e.display));\n              g > e.display.maxLineLength && (e.display.maxLineLength = g, e.display.maxLine = a.line, e.display.maxLineChanged = !0);\n            }\n          }\n        }\n        Math.abs(l) > 2 && (t.scroller.scrollTop += l);\n      }\n      u(Zr, \"updateHeightsInViewport\");\n      function Ol(e) {\n        if (e.widgets)\n          for (var t = 0; t < e.widgets.length; ++t) {\n            var i = e.widgets[t], r = i.node.parentNode;\n            r && (i.height = r.offsetHeight);\n          }\n      }\n      u(Ol, \"updateWidgetHeight\");\n      function Qr(e, t, i) {\n        var r = i && i.top != null ? Math.max(0, i.top) : e.scroller.scrollTop;\n        r = Math.floor(r - Kr(e));\n        var n = i && i.bottom != null ? i.bottom : r + e.wrapper.clientHeight, l = at(t, r), o = at(t, n);\n        if (i && i.ensure) {\n          var a = i.ensure.from.line, s = i.ensure.to.line;\n          a < l ? (l = a, o = at(t, Ie(S(t, a)) + e.wrapper.clientHeight)) : Math.min(s, t.lastLine()) >= o && (l = at(t, Ie(S(t, s)) - e.wrapper.clientHeight), o = s);\n        }\n        return { from: l, to: Math.max(o, l + 1) };\n      }\n      u(Qr, \"visibleLines\");\n      function Ja(e, t) {\n        if (!q(e, \"scrollCursorIntoView\")) {\n          var i = e.display, r = i.sizer.getBoundingClientRect(), n = null;\n          if (t.top + r.top < 0 ? n = !0 : t.bottom + r.top > (window.innerHeight || document.documentElement.clientHeight) && (n = !1), n != null && !Yo) {\n            var l = T(\"div\", \"​\", null, `position: absolute;\n                         top: ` + (t.top - i.viewOffset - Kr(e.display)) + `px;\n                         height: ` + (t.bottom - t.top + Ae(e) + i.barHeight) + `px;\n                         left: ` + t.left + \"px; width: \" + Math.max(2, t.right - t.left) + \"px;\");\n            e.display.lineSpace.appendChild(l), l.scrollIntoView(n), e.display.lineSpace.removeChild(l);\n          }\n        }\n      }\n      u(Ja, \"maybeScrollWindow\");\n      function ja(e, t, i, r) {\n        r == null && (r = 0);\n        var n;\n        !e.options.lineWrapping && t == i && (i = t.sticky == \"before\" ? y(t.line, t.ch + 1, \"before\") : t, t = t.ch ? y(t.line, t.sticky == \"before\" ? t.ch - 1 : t.ch, \"after\") : t);\n        for (var l = 0; l < 5; l++) {\n          var o = !1, a = Le(e, t), s = !i || i == t ? a : Le(e, i);\n          n = {\n            left: Math.min(a.left, s.left),\n            top: Math.min(a.top, s.top) - r,\n            right: Math.max(a.left, s.left),\n            bottom: Math.max(a.bottom, s.bottom) + r\n          };\n          var f = rn(e, n), h = e.doc.scrollTop, c = e.doc.scrollLeft;\n          if (f.scrollTop != null && (lr(e, f.scrollTop), Math.abs(e.doc.scrollTop - h) > 1 && (o = !0)), f.scrollLeft != null && (ct(e, f.scrollLeft), Math.abs(e.doc.scrollLeft - c) > 1 && (o = !0)), !o)\n            break;\n        }\n        return n;\n      }\n      u(ja, \"scrollPosIntoView\");\n      function Va(e, t) {\n        var i = rn(e, t);\n        i.scrollTop != null && lr(e, i.scrollTop), i.scrollLeft != null && ct(e, i.scrollLeft);\n      }\n      u(Va, \"scrollIntoView\");\n      function rn(e, t) {\n        var i = e.display, r = Tt(e.display);\n        t.top < 0 && (t.top = 0);\n        var n = e.curOp && e.curOp.scrollTop != null ? e.curOp.scrollTop : i.scroller.scrollTop, l = Ki(e), o = {};\n        t.bottom - t.top > l && (t.bottom = t.top + l);\n        var a = e.doc.height + Ui(i), s = t.top < r, f = t.bottom > a - r;\n        if (t.top < n)\n          o.scrollTop = s ? 0 : t.top;\n        else if (t.bottom > n + l) {\n          var h = Math.min(t.top, (f ? a : t.bottom) - l);\n          h != n && (o.scrollTop = h);\n        }\n        var c = e.options.fixedGutter ? 0 : i.gutters.offsetWidth, p = e.curOp && e.curOp.scrollLeft != null ? e.curOp.scrollLeft : i.scroller.scrollLeft - c, d = st(e) - i.gutters.offsetWidth, v = t.right - t.left > d;\n        return v && (t.right = t.left + d), t.left < 10 ? o.scrollLeft = 0 : t.left < p ? o.scrollLeft = Math.max(0, t.left + c - (v ? 0 : 10)) : t.right > d + p - 3 && (o.scrollLeft = t.right + (v ? 0 : 10) - d), o;\n      }\n      u(rn, \"calculateScrollPos\");\n      function nn(e, t) {\n        t != null && (Jr(e), e.curOp.scrollTop = (e.curOp.scrollTop == null ? e.doc.scrollTop : e.curOp.scrollTop) + t);\n      }\n      u(nn, \"addToScrollTop\");\n      function Nt(e) {\n        Jr(e);\n        var t = e.getCursor();\n        e.curOp.scrollToPos = { from: t, to: t, margin: e.options.cursorScrollMargin };\n      }\n      u(Nt, \"ensureCursorVisible\");\n      function nr(e, t, i) {\n        (t != null || i != null) && Jr(e), t != null && (e.curOp.scrollLeft = t), i != null && (e.curOp.scrollTop = i);\n      }\n      u(nr, \"scrollToCoords\");\n      function $a(e, t) {\n        Jr(e), e.curOp.scrollToPos = t;\n      }\n      u($a, \"scrollToRange\");\n      function Jr(e) {\n        var t = e.curOp.scrollToPos;\n        if (t) {\n          e.curOp.scrollToPos = null;\n          var i = Ll(e, t.from), r = Ll(e, t.to);\n          Wl(e, i, r, t.margin);\n        }\n      }\n      u(Jr, \"resolveScrollToPos\");\n      function Wl(e, t, i, r) {\n        var n = rn(e, {\n          left: Math.min(t.left, i.left),\n          top: Math.min(t.top, i.top) - r,\n          right: Math.max(t.right, i.right),\n          bottom: Math.max(t.bottom, i.bottom) + r\n        });\n        nr(e, n.scrollLeft, n.scrollTop);\n      }\n      u(Wl, \"scrollToCoordsRange\");\n      function lr(e, t) {\n        Math.abs(e.doc.scrollTop - t) < 2 || (Fe || on(e, { top: t }), Hl(e, t, !0), Fe && on(e), sr(e, 100));\n      }\n      u(lr, \"updateScrollTop\");\n      function Hl(e, t, i) {\n        t = Math.max(0, Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, t)), !(e.display.scroller.scrollTop == t && !i) && (e.doc.scrollTop = t, e.display.scrollbars.setScrollTop(t), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t));\n      }\n      u(Hl, \"setScrollTop\");\n      function ct(e, t, i, r) {\n        t = Math.max(0, Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth)), !((i ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) && !r) && (e.doc.scrollLeft = t, Rl(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t));\n      }\n      u(ct, \"setScrollLeft\");\n      function or(e) {\n        var t = e.display, i = t.gutters.offsetWidth, r = Math.round(e.doc.height + Ui(e.display));\n        return {\n          clientHeight: t.scroller.clientHeight,\n          viewHeight: t.wrapper.clientHeight,\n          scrollWidth: t.scroller.scrollWidth,\n          clientWidth: t.scroller.clientWidth,\n          viewWidth: t.wrapper.clientWidth,\n          barLeft: e.options.fixedGutter ? i : 0,\n          docHeight: r,\n          scrollHeight: r + Ae(e) + t.barHeight,\n          nativeBarWidth: t.nativeBarWidth,\n          gutterWidth: i\n        };\n      }\n      u(or, \"measureForScrollbars\");\n      var dt = /* @__PURE__ */ u(function(e, t, i) {\n        this.cm = i;\n        var r = this.vert = T(\"div\", [T(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\"), n = this.horiz = T(\"div\", [T(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n        r.tabIndex = n.tabIndex = -1, e(r), e(n), M(r, \"scroll\", function() {\n          r.clientHeight && t(r.scrollTop, \"vertical\");\n        }), M(n, \"scroll\", function() {\n          n.clientWidth && t(n.scrollLeft, \"horizontal\");\n        }), this.checkedZeroWidth = !1, O && I < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\");\n      }, \"NativeScrollbars\");\n      dt.prototype.update = function(e) {\n        var t = e.scrollWidth > e.clientWidth + 1, i = e.scrollHeight > e.clientHeight + 1, r = e.nativeBarWidth;\n        if (i) {\n          this.vert.style.display = \"block\", this.vert.style.bottom = t ? r + \"px\" : \"0\";\n          var n = e.viewHeight - (t ? r : 0);\n          this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + n) + \"px\";\n        } else\n          this.vert.scrollTop = 0, this.vert.style.display = \"\", this.vert.firstChild.style.height = \"0\";\n        if (t) {\n          this.horiz.style.display = \"block\", this.horiz.style.right = i ? r + \"px\" : \"0\", this.horiz.style.left = e.barLeft + \"px\";\n          var l = e.viewWidth - e.barLeft - (i ? r : 0);\n          this.horiz.firstChild.style.width = Math.max(0, e.scrollWidth - e.clientWidth + l) + \"px\";\n        } else\n          this.horiz.style.display = \"\", this.horiz.firstChild.style.width = \"0\";\n        return !this.checkedZeroWidth && e.clientHeight > 0 && (r == 0 && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: i ? r : 0, bottom: t ? r : 0 };\n      }, dt.prototype.setScrollLeft = function(e) {\n        this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\");\n      }, dt.prototype.setScrollTop = function(e) {\n        this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\");\n      }, dt.prototype.zeroWidthHack = function() {\n        var e = me && !Xo ? \"12px\" : \"18px\";\n        this.horiz.style.height = this.vert.style.width = e, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\", this.disableHoriz = new _e(), this.disableVert = new _e();\n      }, dt.prototype.enableZeroWidthBar = function(e, t, i) {\n        e.style.pointerEvents = \"auto\";\n        function r() {\n          var n = e.getBoundingClientRect(), l = i == \"vert\" ? document.elementFromPoint(n.right - 1, (n.top + n.bottom) / 2) : document.elementFromPoint((n.right + n.left) / 2, n.bottom - 1);\n          l != e ? e.style.pointerEvents = \"none\" : t.set(1e3, r);\n        }\n        u(r, \"maybeDisable\"), t.set(1e3, r);\n      }, dt.prototype.clear = function() {\n        var e = this.horiz.parentNode;\n        e.removeChild(this.horiz), e.removeChild(this.vert);\n      };\n      var ar = /* @__PURE__ */ u(function() {\n      }, \"NullScrollbars\");\n      ar.prototype.update = function() {\n        return { bottom: 0, right: 0 };\n      }, ar.prototype.setScrollLeft = function() {\n      }, ar.prototype.setScrollTop = function() {\n      }, ar.prototype.clear = function() {\n      };\n      function At(e, t) {\n        t || (t = or(e));\n        var i = e.display.barWidth, r = e.display.barHeight;\n        Fl(e, t);\n        for (var n = 0; n < 4 && i != e.display.barWidth || r != e.display.barHeight; n++)\n          i != e.display.barWidth && e.options.lineWrapping && Zr(e), Fl(e, or(e)), i = e.display.barWidth, r = e.display.barHeight;\n      }\n      u(At, \"updateScrollbars\");\n      function Fl(e, t) {\n        var i = e.display, r = i.scrollbars.update(t);\n        i.sizer.style.paddingRight = (i.barWidth = r.right) + \"px\", i.sizer.style.paddingBottom = (i.barHeight = r.bottom) + \"px\", i.heightForcer.style.borderBottom = r.bottom + \"px solid transparent\", r.right && r.bottom ? (i.scrollbarFiller.style.display = \"block\", i.scrollbarFiller.style.height = r.bottom + \"px\", i.scrollbarFiller.style.width = r.right + \"px\") : i.scrollbarFiller.style.display = \"\", r.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (i.gutterFiller.style.display = \"block\", i.gutterFiller.style.height = r.bottom + \"px\", i.gutterFiller.style.width = t.gutterWidth + \"px\") : i.gutterFiller.style.display = \"\";\n      }\n      u(Fl, \"updateScrollbarsInner\");\n      var Pl = { native: dt, null: ar };\n      function El(e) {\n        e.display.scrollbars && (e.display.scrollbars.clear(), e.display.scrollbars.addClass && tt(e.display.wrapper, e.display.scrollbars.addClass)), e.display.scrollbars = new Pl[e.options.scrollbarStyle](function(t) {\n          e.display.wrapper.insertBefore(t, e.display.scrollbarFiller), M(t, \"mousedown\", function() {\n            e.state.focused && setTimeout(function() {\n              return e.display.input.focus();\n            }, 0);\n          }), t.setAttribute(\"cm-not-content\", \"true\");\n        }, function(t, i) {\n          i == \"horizontal\" ? ct(e, t) : lr(e, t);\n        }, e), e.display.scrollbars.addClass && it(e.display.wrapper, e.display.scrollbars.addClass);\n      }\n      u(El, \"initScrollbars\");\n      var es = 0;\n      function pt(e) {\n        e.curOp = {\n          cm: e,\n          viewChanged: !1,\n          // Flag that indicates that lines might need to be redrawn\n          startHeight: e.doc.height,\n          // Used to detect need to update scrollbar\n          forceUpdate: !1,\n          // Used to force a redraw\n          updateInput: 0,\n          // Whether to reset the input textarea\n          typing: !1,\n          // Whether this reset should be careful to leave existing text (for compositing)\n          changeObjs: null,\n          // Accumulated changes, for firing change events\n          cursorActivityHandlers: null,\n          // Set of handlers to fire cursorActivity on\n          cursorActivityCalled: 0,\n          // Tracks which cursorActivity handlers have been called already\n          selectionChanged: !1,\n          // Whether the selection needs to be redrawn\n          updateMaxLine: !1,\n          // Set when the widest line needs to be determined anew\n          scrollLeft: null,\n          scrollTop: null,\n          // Intermediate scroll position, not pushed to DOM yet\n          scrollToPos: null,\n          // Used to scroll to a specific position\n          focus: !1,\n          id: ++es,\n          // Unique ID\n          markArrays: null\n          // Used by addMarkedSpan\n        }, Oa(e.curOp);\n      }\n      u(pt, \"startOperation\");\n      function vt(e) {\n        var t = e.curOp;\n        t && Ha(t, function(i) {\n          for (var r = 0; r < i.ops.length; r++)\n            i.ops[r].cm.curOp = null;\n          ts(i);\n        });\n      }\n      u(vt, \"endOperation\");\n      function ts(e) {\n        for (var t = e.ops, i = 0; i < t.length; i++)\n          rs(t[i]);\n        for (var r = 0; r < t.length; r++)\n          is(t[r]);\n        for (var n = 0; n < t.length; n++)\n          ns(t[n]);\n        for (var l = 0; l < t.length; l++)\n          ls(t[l]);\n        for (var o = 0; o < t.length; o++)\n          os(t[o]);\n      }\n      u(ts, \"endOperations\");\n      function rs(e) {\n        var t = e.cm, i = t.display;\n        ss(t), e.updateMaxLine && zi(t), e.mustUpdate = e.viewChanged || e.forceUpdate || e.scrollTop != null || e.scrollToPos && (e.scrollToPos.from.line < i.viewFrom || e.scrollToPos.to.line >= i.viewTo) || i.maxLineChanged && t.options.lineWrapping, e.update = e.mustUpdate && new jr(t, e.mustUpdate && { top: e.scrollTop, ensure: e.scrollToPos }, e.forceUpdate);\n      }\n      u(rs, \"endOperation_R1\");\n      function is(e) {\n        e.updatedDisplay = e.mustUpdate && ln(e.cm, e.update);\n      }\n      u(is, \"endOperation_W1\");\n      function ns(e) {\n        var t = e.cm, i = t.display;\n        e.updatedDisplay && Zr(t), e.barMeasure = or(t), i.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = gl(t, i.maxLine, i.maxLine.text.length).left + 3, t.display.sizerWidth = e.adjustWidthTo, e.barMeasure.scrollWidth = Math.max(i.scroller.clientWidth, i.sizer.offsetLeft + e.adjustWidthTo + Ae(t) + t.display.barWidth), e.maxScrollLeft = Math.max(0, i.sizer.offsetLeft + e.adjustWidthTo - st(t))), (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = i.input.prepareSelection());\n      }\n      u(ns, \"endOperation_R2\");\n      function ls(e) {\n        var t = e.cm;\n        e.adjustWidthTo != null && (t.display.sizer.style.minWidth = e.adjustWidthTo + \"px\", e.maxScrollLeft < t.doc.scrollLeft && ct(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0), t.display.maxLineChanged = !1);\n        var i = e.focus && e.focus == be();\n        e.preparedSelection && t.display.input.showSelection(e.preparedSelection, i), (e.updatedDisplay || e.startHeight != t.doc.height) && At(t, e.barMeasure), e.updatedDisplay && sn(t, e.barMeasure), e.selectionChanged && $i(t), t.state.focused && e.updateInput && t.display.input.reset(e.typing), i && Al(e.cm);\n      }\n      u(ls, \"endOperation_W2\");\n      function os(e) {\n        var t = e.cm, i = t.display, r = t.doc;\n        if (e.updatedDisplay && Il(t, e.update), i.wheelStartX != null && (e.scrollTop != null || e.scrollLeft != null || e.scrollToPos) && (i.wheelStartX = i.wheelStartY = null), e.scrollTop != null && Hl(t, e.scrollTop, e.forceScroll), e.scrollLeft != null && ct(t, e.scrollLeft, !0, !0), e.scrollToPos) {\n          var n = ja(\n            t,\n            N(r, e.scrollToPos.from),\n            N(r, e.scrollToPos.to),\n            e.scrollToPos.margin\n          );\n          Ja(t, n);\n        }\n        var l = e.maybeHiddenMarkers, o = e.maybeUnhiddenMarkers;\n        if (l)\n          for (var a = 0; a < l.length; ++a)\n            l[a].lines.length || U(l[a], \"hide\");\n        if (o)\n          for (var s = 0; s < o.length; ++s)\n            o[s].lines.length && U(o[s], \"unhide\");\n        i.wrapper.offsetHeight && (r.scrollTop = t.display.scroller.scrollTop), e.changeObjs && U(t, \"changes\", t, e.changeObjs), e.update && e.update.finish();\n      }\n      u(os, \"endOperation_finish\");\n      function de(e, t) {\n        if (e.curOp)\n          return t();\n        pt(e);\n        try {\n          return t();\n        } finally {\n          vt(e);\n        }\n      }\n      u(de, \"runInOp\");\n      function Q(e, t) {\n        return function() {\n          if (e.curOp)\n            return t.apply(e, arguments);\n          pt(e);\n          try {\n            return t.apply(e, arguments);\n          } finally {\n            vt(e);\n          }\n        };\n      }\n      u(Q, \"operation\");\n      function le(e) {\n        return function() {\n          if (this.curOp)\n            return e.apply(this, arguments);\n          pt(this);\n          try {\n            return e.apply(this, arguments);\n          } finally {\n            vt(this);\n          }\n        };\n      }\n      u(le, \"methodOp\");\n      function J(e) {\n        return function() {\n          var t = this.cm;\n          if (!t || t.curOp)\n            return e.apply(this, arguments);\n          pt(t);\n          try {\n            return e.apply(this, arguments);\n          } finally {\n            vt(t);\n          }\n        };\n      }\n      u(J, \"docMethodOp\");\n      function sr(e, t) {\n        e.doc.highlightFrontier < e.display.viewTo && e.state.highlight.set(t, pi(as, e));\n      }\n      u(sr, \"startWorker\");\n      function as(e) {\n        var t = e.doc;\n        if (!(t.highlightFrontier >= e.display.viewTo)) {\n          var i = +/* @__PURE__ */ new Date() + e.options.workTime, r = jt(e, t.highlightFrontier), n = [];\n          t.iter(r.line, Math.min(t.first + t.size, e.display.viewTo + 500), function(l) {\n            if (r.line >= e.display.viewFrom) {\n              var o = l.styles, a = l.text.length > e.options.maxHighlightLength ? lt(t.mode, r.state) : null, s = _n(e, l, r, !0);\n              a && (r.state = a), l.styles = s.styles;\n              var f = l.styleClasses, h = s.classes;\n              h ? l.styleClasses = h : f && (l.styleClasses = null);\n              for (var c = !o || o.length != l.styles.length || f != h && (!f || !h || f.bgClass != h.bgClass || f.textClass != h.textClass), p = 0; !c && p < o.length; ++p)\n                c = o[p] != l.styles[p];\n              c && n.push(r.line), l.stateAfter = r.save(), r.nextLine();\n            } else\n              l.text.length <= e.options.maxHighlightLength && Fi(e, l.text, r), l.stateAfter = r.line % 5 == 0 ? r.save() : null, r.nextLine();\n            if (+/* @__PURE__ */ new Date() > i)\n              return sr(e, e.options.workDelay), !0;\n          }), t.highlightFrontier = r.line, t.modeFrontier = Math.max(t.modeFrontier, r.line), n.length && de(e, function() {\n            for (var l = 0; l < n.length; l++)\n              Ye(e, n[l], \"text\");\n          });\n        }\n      }\n      u(as, \"highlightWorker\");\n      var jr = /* @__PURE__ */ u(function(e, t, i) {\n        var r = e.display;\n        this.viewport = t, this.visible = Qr(r, e.doc, t), this.editorIsHidden = !r.wrapper.offsetWidth, this.wrapperHeight = r.wrapper.clientHeight, this.wrapperWidth = r.wrapper.clientWidth, this.oldDisplayWidth = st(e), this.force = i, this.dims = Qi(e), this.events = [];\n      }, \"DisplayUpdate\");\n      jr.prototype.signal = function(e, t) {\n        Ce(e, t) && this.events.push(arguments);\n      }, jr.prototype.finish = function() {\n        for (var e = 0; e < this.events.length; e++)\n          U.apply(null, this.events[e]);\n      };\n      function ss(e) {\n        var t = e.display;\n        !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = Ae(e) + \"px\", t.sizer.style.marginBottom = -t.nativeBarWidth + \"px\", t.sizer.style.borderRightWidth = Ae(e) + \"px\", t.scrollbarsClipped = !0);\n      }\n      u(ss, \"maybeClipScrollbars\");\n      function us(e) {\n        if (e.hasFocus())\n          return null;\n        var t = be();\n        if (!t || !Ke(e.display.lineDiv, t))\n          return null;\n        var i = { activeElt: t };\n        if (window.getSelection) {\n          var r = window.getSelection();\n          r.anchorNode && r.extend && Ke(e.display.lineDiv, r.anchorNode) && (i.anchorNode = r.anchorNode, i.anchorOffset = r.anchorOffset, i.focusNode = r.focusNode, i.focusOffset = r.focusOffset);\n        }\n        return i;\n      }\n      u(us, \"selectionSnapshot\");\n      function fs(e) {\n        if (!(!e || !e.activeElt || e.activeElt == be()) && (e.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(e.activeElt.nodeName) && e.anchorNode && Ke(document.body, e.anchorNode) && Ke(document.body, e.focusNode))) {\n          var t = window.getSelection(), i = document.createRange();\n          i.setEnd(e.anchorNode, e.anchorOffset), i.collapse(!1), t.removeAllRanges(), t.addRange(i), t.extend(e.focusNode, e.focusOffset);\n        }\n      }\n      u(fs, \"restoreSelection\");\n      function ln(e, t) {\n        var i = e.display, r = e.doc;\n        if (t.editorIsHidden)\n          return qe(e), !1;\n        if (!t.force && t.visible.from >= i.viewFrom && t.visible.to <= i.viewTo && (i.updateLineNumbers == null || i.updateLineNumbers >= i.viewTo) && i.renderedView == i.view && Dl(e) == 0)\n          return !1;\n        Bl(e) && (qe(e), t.dims = Qi(e));\n        var n = r.first + r.size, l = Math.max(t.visible.from - e.options.viewportMargin, r.first), o = Math.min(n, t.visible.to + e.options.viewportMargin);\n        i.viewFrom < l && l - i.viewFrom < 20 && (l = Math.max(r.first, i.viewFrom)), i.viewTo > o && i.viewTo - o < 20 && (o = Math.min(n, i.viewTo)), Ee && (l = Ri(e.doc, l), o = nl(e.doc, o));\n        var a = l != i.viewFrom || o != i.viewTo || i.lastWrapHeight != t.wrapperHeight || i.lastWrapWidth != t.wrapperWidth;\n        Za(e, l, o), i.viewOffset = Ie(S(e.doc, i.viewFrom)), e.display.mover.style.top = i.viewOffset + \"px\";\n        var s = Dl(e);\n        if (!a && s == 0 && !t.force && i.renderedView == i.view && (i.updateLineNumbers == null || i.updateLineNumbers >= i.viewTo))\n          return !1;\n        var f = us(e);\n        return s > 4 && (i.lineDiv.style.display = \"none\"), hs(e, i.updateLineNumbers, t.dims), s > 4 && (i.lineDiv.style.display = \"\"), i.renderedView = i.view, fs(f), Ue(i.cursorDiv), Ue(i.selectionDiv), i.gutters.style.height = i.sizer.style.minHeight = 0, a && (i.lastWrapHeight = t.wrapperHeight, i.lastWrapWidth = t.wrapperWidth, sr(e, 400)), i.updateLineNumbers = null, !0;\n      }\n      u(ln, \"updateDisplayIfNeeded\");\n      function Il(e, t) {\n        for (var i = t.viewport, r = !0; ; r = !1) {\n          if (!r || !e.options.lineWrapping || t.oldDisplayWidth == st(e)) {\n            if (i && i.top != null && (i = { top: Math.min(e.doc.height + Ui(e.display) - Ki(e), i.top) }), t.visible = Qr(e.display, e.doc, i), t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo)\n              break;\n          } else\n            r && (t.visible = Qr(e.display, e.doc, i));\n          if (!ln(e, t))\n            break;\n          Zr(e);\n          var n = or(e);\n          ir(e), At(e, n), sn(e, n), t.force = !1;\n        }\n        t.signal(e, \"update\", e), (e.display.viewFrom != e.display.reportedViewFrom || e.display.viewTo != e.display.reportedViewTo) && (t.signal(e, \"viewportChange\", e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo);\n      }\n      u(Il, \"postUpdateDisplay\");\n      function on(e, t) {\n        var i = new jr(e, t);\n        if (ln(e, i)) {\n          Zr(e), Il(e, i);\n          var r = or(e);\n          ir(e), At(e, r), sn(e, r), i.finish();\n        }\n      }\n      u(on, \"updateDisplaySimple\");\n      function hs(e, t, i) {\n        var r = e.display, n = e.options.lineNumbers, l = r.lineDiv, o = l.firstChild;\n        function a(v) {\n          var g = v.nextSibling;\n          return ne && me && e.display.currentWheelTarget == v ? v.style.display = \"none\" : v.parentNode.removeChild(v), g;\n        }\n        u(a, \"rm\");\n        for (var s = r.view, f = r.viewFrom, h = 0; h < s.length; h++) {\n          var c = s[h];\n          if (!c.hidden)\n            if (!c.node || c.node.parentNode != l) {\n              var p = Ra(e, c, f, i);\n              l.insertBefore(p, o);\n            } else {\n              for (; o != c.node; )\n                o = a(o);\n              var d = n && t != null && t <= f && c.lineNumber;\n              c.changes && (ee(c.changes, \"gutter\") > -1 && (d = !1), ul(e, c, f, i)), d && (Ue(c.lineNumber), c.lineNumber.appendChild(document.createTextNode(Oi(e.options, f)))), o = c.node.nextSibling;\n            }\n          f += c.size;\n        }\n        for (; o; )\n          o = a(o);\n      }\n      u(hs, \"patchDisplay\");\n      function an(e) {\n        var t = e.gutters.offsetWidth;\n        e.sizer.style.marginLeft = t + \"px\", Z(e, \"gutterChanged\", e);\n      }\n      u(an, \"updateGutterSpace\");\n      function sn(e, t) {\n        e.display.sizer.style.minHeight = t.docHeight + \"px\", e.display.heightForcer.style.top = t.docHeight + \"px\", e.display.gutters.style.height = t.docHeight + e.display.barHeight + Ae(e) + \"px\";\n      }\n      u(sn, \"setDocumentHeight\");\n      function Rl(e) {\n        var t = e.display, i = t.view;\n        if (!(!t.alignWidgets && (!t.gutters.firstChild || !e.options.fixedGutter))) {\n          for (var r = Ji(t) - t.scroller.scrollLeft + e.doc.scrollLeft, n = t.gutters.offsetWidth, l = r + \"px\", o = 0; o < i.length; o++)\n            if (!i[o].hidden) {\n              e.options.fixedGutter && (i[o].gutter && (i[o].gutter.style.left = l), i[o].gutterBackground && (i[o].gutterBackground.style.left = l));\n              var a = i[o].alignable;\n              if (a)\n                for (var s = 0; s < a.length; s++)\n                  a[s].style.left = l;\n            }\n          e.options.fixedGutter && (t.gutters.style.left = r + n + \"px\");\n        }\n      }\n      u(Rl, \"alignHorizontally\");\n      function Bl(e) {\n        if (!e.options.lineNumbers)\n          return !1;\n        var t = e.doc, i = Oi(e.options, t.first + t.size - 1), r = e.display;\n        if (i.length != r.lineNumChars) {\n          var n = r.measure.appendChild(T(\n            \"div\",\n            [T(\"div\", i)],\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\"\n          )), l = n.firstChild.offsetWidth, o = n.offsetWidth - l;\n          return r.lineGutter.style.width = \"\", r.lineNumInnerWidth = Math.max(l, r.lineGutter.offsetWidth - o) + 1, r.lineNumWidth = r.lineNumInnerWidth + o, r.lineNumChars = r.lineNumInnerWidth ? i.length : -1, r.lineGutter.style.width = r.lineNumWidth + \"px\", an(e.display), !0;\n        }\n        return !1;\n      }\n      u(Bl, \"maybeUpdateLineNumberWidth\");\n      function un(e, t) {\n        for (var i = [], r = !1, n = 0; n < e.length; n++) {\n          var l = e[n], o = null;\n          if (typeof l != \"string\" && (o = l.style, l = l.className), l == \"CodeMirror-linenumbers\")\n            if (t)\n              r = !0;\n            else\n              continue;\n          i.push({ className: l, style: o });\n        }\n        return t && !r && i.push({ className: \"CodeMirror-linenumbers\", style: null }), i;\n      }\n      u(un, \"getGutters\");\n      function zl(e) {\n        var t = e.gutters, i = e.gutterSpecs;\n        Ue(t), e.lineGutter = null;\n        for (var r = 0; r < i.length; ++r) {\n          var n = i[r], l = n.className, o = n.style, a = t.appendChild(T(\"div\", null, \"CodeMirror-gutter \" + l));\n          o && (a.style.cssText = o), l == \"CodeMirror-linenumbers\" && (e.lineGutter = a, a.style.width = (e.lineNumWidth || 1) + \"px\");\n        }\n        t.style.display = i.length ? \"\" : \"none\", an(e);\n      }\n      u(zl, \"renderGutters\");\n      function ur(e) {\n        zl(e.display), se(e), Rl(e);\n      }\n      u(ur, \"updateGutters\");\n      function cs(e, t, i, r) {\n        var n = this;\n        this.input = i, n.scrollbarFiller = T(\"div\", null, \"CodeMirror-scrollbar-filler\"), n.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\"), n.gutterFiller = T(\"div\", null, \"CodeMirror-gutter-filler\"), n.gutterFiller.setAttribute(\"cm-not-content\", \"true\"), n.lineDiv = bt(\"div\", null, \"CodeMirror-code\"), n.selectionDiv = T(\"div\", null, null, \"position: relative; z-index: 1\"), n.cursorDiv = T(\"div\", null, \"CodeMirror-cursors\"), n.measure = T(\"div\", null, \"CodeMirror-measure\"), n.lineMeasure = T(\"div\", null, \"CodeMirror-measure\"), n.lineSpace = bt(\n          \"div\",\n          [n.measure, n.lineMeasure, n.selectionDiv, n.cursorDiv, n.lineDiv],\n          null,\n          \"position: relative; outline: none\"\n        );\n        var l = bt(\"div\", [n.lineSpace], \"CodeMirror-lines\");\n        n.mover = T(\"div\", [l], null, \"position: relative\"), n.sizer = T(\"div\", [n.mover], \"CodeMirror-sizer\"), n.sizerWidth = null, n.heightForcer = T(\"div\", null, null, \"position: absolute; height: \" + Wn + \"px; width: 1px;\"), n.gutters = T(\"div\", null, \"CodeMirror-gutters\"), n.lineGutter = null, n.scroller = T(\"div\", [n.sizer, n.heightForcer, n.gutters], \"CodeMirror-scroll\"), n.scroller.setAttribute(\"tabIndex\", \"-1\"), n.wrapper = T(\"div\", [n.scrollbarFiller, n.gutterFiller, n.scroller], \"CodeMirror\"), n.wrapper.setAttribute(\"translate\", \"no\"), O && I < 8 && (n.gutters.style.zIndex = -1, n.scroller.style.paddingRight = 0), !ne && !(Fe && Kt) && (n.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(n.wrapper) : e(n.wrapper)), n.viewFrom = n.viewTo = t.first, n.reportedViewFrom = n.reportedViewTo = t.first, n.view = [], n.renderedView = null, n.externalMeasured = null, n.viewOffset = 0, n.lastWrapHeight = n.lastWrapWidth = 0, n.updateLineNumbers = null, n.nativeBarWidth = n.barHeight = n.barWidth = 0, n.scrollbarsClipped = !1, n.lineNumWidth = n.lineNumInnerWidth = n.lineNumChars = null, n.alignWidgets = !1, n.cachedCharWidth = n.cachedTextHeight = n.cachedPaddingH = null, n.maxLine = null, n.maxLineLength = 0, n.maxLineChanged = !1, n.wheelDX = n.wheelDY = n.wheelStartX = n.wheelStartY = null, n.shift = !1, n.selForContextMenu = null, n.activeTouch = null, n.gutterSpecs = un(r.gutters, r.lineNumbers), zl(n), i.init(n);\n      }\n      u(cs, \"Display\");\n      var Vr = 0, Be = null;\n      O ? Be = -0.53 : Fe ? Be = 15 : Tr ? Be = -0.7 : Mr && (Be = -1 / 3);\n      function Gl(e) {\n        var t = e.wheelDeltaX, i = e.wheelDeltaY;\n        return t == null && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), i == null && e.detail && e.axis == e.VERTICAL_AXIS ? i = e.detail : i == null && (i = e.wheelDelta), { x: t, y: i };\n      }\n      u(Gl, \"wheelEventDelta\");\n      function ds(e) {\n        var t = Gl(e);\n        return t.x *= Be, t.y *= Be, t;\n      }\n      u(ds, \"wheelEventPixels\");\n      function Ul(e, t) {\n        var i = Gl(t), r = i.x, n = i.y, l = Be;\n        t.deltaMode === 0 && (r = t.deltaX, n = t.deltaY, l = 1);\n        var o = e.display, a = o.scroller, s = a.scrollWidth > a.clientWidth, f = a.scrollHeight > a.clientHeight;\n        if (r && s || n && f) {\n          if (n && me && ne) {\n            e:\n              for (var h = t.target, c = o.view; h != a; h = h.parentNode)\n                for (var p = 0; p < c.length; p++)\n                  if (c[p].node == h) {\n                    e.display.currentWheelTarget = h;\n                    break e;\n                  }\n          }\n          if (r && !Fe && !we && l != null) {\n            n && f && lr(e, Math.max(0, a.scrollTop + n * l)), ct(e, Math.max(0, a.scrollLeft + r * l)), (!n || n && f) && ae(t), o.wheelStartX = null;\n            return;\n          }\n          if (n && l != null) {\n            var d = n * l, v = e.doc.scrollTop, g = v + o.wrapper.clientHeight;\n            d < 0 ? v = Math.max(0, v + d - 50) : g = Math.min(e.doc.height, g + d + 50), on(e, { top: v, bottom: g });\n          }\n          Vr < 20 && t.deltaMode !== 0 && (o.wheelStartX == null ? (o.wheelStartX = a.scrollLeft, o.wheelStartY = a.scrollTop, o.wheelDX = r, o.wheelDY = n, setTimeout(function() {\n            if (o.wheelStartX != null) {\n              var m = a.scrollLeft - o.wheelStartX, b = a.scrollTop - o.wheelStartY, C = b && o.wheelDY && b / o.wheelDY || m && o.wheelDX && m / o.wheelDX;\n              o.wheelStartX = o.wheelStartY = null, C && (Be = (Be * Vr + C) / (Vr + 1), ++Vr);\n            }\n          }, 200)) : (o.wheelDX += r, o.wheelDY += n));\n        }\n      }\n      u(Ul, \"onScrollWheel\");\n      var ye = /* @__PURE__ */ u(function(e, t) {\n        this.ranges = e, this.primIndex = t;\n      }, \"Selection\");\n      ye.prototype.primary = function() {\n        return this.ranges[this.primIndex];\n      }, ye.prototype.equals = function(e) {\n        if (e == this)\n          return !0;\n        if (e.primIndex != this.primIndex || e.ranges.length != this.ranges.length)\n          return !1;\n        for (var t = 0; t < this.ranges.length; t++) {\n          var i = this.ranges[t], r = e.ranges[t];\n          if (!Wi(i.anchor, r.anchor) || !Wi(i.head, r.head))\n            return !1;\n        }\n        return !0;\n      }, ye.prototype.deepCopy = function() {\n        for (var e = [], t = 0; t < this.ranges.length; t++)\n          e[t] = new W(Hi(this.ranges[t].anchor), Hi(this.ranges[t].head));\n        return new ye(e, this.primIndex);\n      }, ye.prototype.somethingSelected = function() {\n        for (var e = 0; e < this.ranges.length; e++)\n          if (!this.ranges[e].empty())\n            return !0;\n        return !1;\n      }, ye.prototype.contains = function(e, t) {\n        t || (t = e);\n        for (var i = 0; i < this.ranges.length; i++) {\n          var r = this.ranges[i];\n          if (D(t, r.from()) >= 0 && D(e, r.to()) <= 0)\n            return i;\n        }\n        return -1;\n      };\n      var W = /* @__PURE__ */ u(function(e, t) {\n        this.anchor = e, this.head = t;\n      }, \"Range\");\n      W.prototype.from = function() {\n        return Pr(this.anchor, this.head);\n      }, W.prototype.to = function() {\n        return Fr(this.anchor, this.head);\n      }, W.prototype.empty = function() {\n        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n      };\n      function ke(e, t, i) {\n        var r = e && e.options.selectionsMayTouch, n = t[i];\n        t.sort(function(p, d) {\n          return D(p.from(), d.from());\n        }), i = ee(t, n);\n        for (var l = 1; l < t.length; l++) {\n          var o = t[l], a = t[l - 1], s = D(a.to(), o.from());\n          if (r && !o.empty() ? s > 0 : s >= 0) {\n            var f = Pr(a.from(), o.from()), h = Fr(a.to(), o.to()), c = a.empty() ? o.from() == o.head : a.from() == a.head;\n            l <= i && --i, t.splice(--l, 2, new W(c ? h : f, c ? f : h));\n          }\n        }\n        return new ye(t, i);\n      }\n      u(ke, \"normalizeSelection\");\n      function Ze(e, t) {\n        return new ye([new W(e, t || e)], 0);\n      }\n      u(Ze, \"simpleSelection\");\n      function Qe(e) {\n        return e.text ? y(\n          e.from.line + e.text.length - 1,\n          H(e.text).length + (e.text.length == 1 ? e.from.ch : 0)\n        ) : e.to;\n      }\n      u(Qe, \"changeEnd\");\n      function Kl(e, t) {\n        if (D(e, t.from) < 0)\n          return e;\n        if (D(e, t.to) <= 0)\n          return Qe(t);\n        var i = e.line + t.text.length - (t.to.line - t.from.line) - 1, r = e.ch;\n        return e.line == t.to.line && (r += Qe(t).ch - t.to.ch), y(i, r);\n      }\n      u(Kl, \"adjustForChange\");\n      function fn(e, t) {\n        for (var i = [], r = 0; r < e.sel.ranges.length; r++) {\n          var n = e.sel.ranges[r];\n          i.push(new W(\n            Kl(n.anchor, t),\n            Kl(n.head, t)\n          ));\n        }\n        return ke(e.cm, i, e.sel.primIndex);\n      }\n      u(fn, \"computeSelAfterChange\");\n      function _l(e, t, i) {\n        return e.line == t.line ? y(i.line, e.ch - t.ch + i.ch) : y(i.line + (e.line - t.line), e.ch);\n      }\n      u(_l, \"offsetPos\");\n      function ps(e, t, i) {\n        for (var r = [], n = y(e.first, 0), l = n, o = 0; o < t.length; o++) {\n          var a = t[o], s = _l(a.from, n, l), f = _l(Qe(a), n, l);\n          if (n = a.to, l = f, i == \"around\") {\n            var h = e.sel.ranges[o], c = D(h.head, h.anchor) < 0;\n            r[o] = new W(c ? f : s, c ? s : f);\n          } else\n            r[o] = new W(s, s);\n        }\n        return new ye(r, e.sel.primIndex);\n      }\n      u(ps, \"computeReplacedSel\");\n      function hn(e) {\n        e.doc.mode = Di(e.options, e.doc.modeOption), fr(e);\n      }\n      u(hn, \"loadMode\");\n      function fr(e) {\n        e.doc.iter(function(t) {\n          t.stateAfter && (t.stateAfter = null), t.styles && (t.styles = null);\n        }), e.doc.modeFrontier = e.doc.highlightFrontier = e.doc.first, sr(e, 100), e.state.modeGen++, e.curOp && se(e);\n      }\n      u(fr, \"resetModeState\");\n      function Xl(e, t) {\n        return t.from.ch == 0 && t.to.ch == 0 && H(t.text) == \"\" && (!e.cm || e.cm.options.wholeLineUpdateBefore);\n      }\n      u(Xl, \"isWholeLineUpdate\");\n      function cn(e, t, i, r) {\n        function n(C) {\n          return i ? i[C] : null;\n        }\n        u(n, \"spansFor\");\n        function l(C, x, w) {\n          wa(C, x, w, r), Z(C, \"change\", C, t);\n        }\n        u(l, \"update\");\n        function o(C, x) {\n          for (var w = [], k = C; k < x; ++k)\n            w.push(new St(f[k], n(k), r));\n          return w;\n        }\n        u(o, \"linesFor\");\n        var a = t.from, s = t.to, f = t.text, h = S(e, a.line), c = S(e, s.line), p = H(f), d = n(f.length - 1), v = s.line - a.line;\n        if (t.full)\n          e.insert(0, o(0, f.length)), e.remove(f.length, e.size - f.length);\n        else if (Xl(e, t)) {\n          var g = o(0, f.length - 1);\n          l(c, c.text, d), v && e.remove(a.line, v), g.length && e.insert(a.line, g);\n        } else if (h == c)\n          if (f.length == 1)\n            l(h, h.text.slice(0, a.ch) + p + h.text.slice(s.ch), d);\n          else {\n            var m = o(1, f.length - 1);\n            m.push(new St(p + h.text.slice(s.ch), d, r)), l(h, h.text.slice(0, a.ch) + f[0], n(0)), e.insert(a.line + 1, m);\n          }\n        else if (f.length == 1)\n          l(h, h.text.slice(0, a.ch) + f[0] + c.text.slice(s.ch), n(0)), e.remove(a.line + 1, v);\n        else {\n          l(h, h.text.slice(0, a.ch) + f[0], n(0)), l(c, p + c.text.slice(s.ch), d);\n          var b = o(1, f.length - 1);\n          v > 1 && e.remove(a.line + 1, v - 1), e.insert(a.line + 1, b);\n        }\n        Z(e, \"change\", e, t);\n      }\n      u(cn, \"updateDoc\");\n      function Je(e, t, i) {\n        function r(n, l, o) {\n          if (n.linked)\n            for (var a = 0; a < n.linked.length; ++a) {\n              var s = n.linked[a];\n              if (s.doc != l) {\n                var f = o && s.sharedHist;\n                i && !f || (t(s.doc, f), r(s.doc, n, f));\n              }\n            }\n        }\n        u(r, \"propagate\"), r(e, null, !0);\n      }\n      u(Je, \"linkedDocs\");\n      function Yl(e, t) {\n        if (t.cm)\n          throw new Error(\"This document is already in use.\");\n        e.doc = t, t.cm = e, ji(e), hn(e), ql(e), e.options.direction = t.direction, e.options.lineWrapping || zi(e), e.options.mode = t.modeOption, se(e);\n      }\n      u(Yl, \"attachDoc\");\n      function ql(e) {\n        (e.doc.direction == \"rtl\" ? it : tt)(e.display.lineDiv, \"CodeMirror-rtl\");\n      }\n      u(ql, \"setDirectionClass\");\n      function vs(e) {\n        de(e, function() {\n          ql(e), se(e);\n        });\n      }\n      u(vs, \"directionChanged\");\n      function $r(e) {\n        this.done = [], this.undone = [], this.undoDepth = e ? e.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e ? e.maxGeneration : 1;\n      }\n      u($r, \"History\");\n      function dn(e, t) {\n        var i = { from: Hi(t.from), to: Qe(t), text: ot(e, t.from, t.to) };\n        return Jl(e, i, t.from.line, t.to.line + 1), Je(e, function(r) {\n          return Jl(r, i, t.from.line, t.to.line + 1);\n        }, !0), i;\n      }\n      u(dn, \"historyChangeFromChange\");\n      function Zl(e) {\n        for (; e.length; ) {\n          var t = H(e);\n          if (t.ranges)\n            e.pop();\n          else\n            break;\n        }\n      }\n      u(Zl, \"clearSelectionEvents\");\n      function gs(e, t) {\n        if (t)\n          return Zl(e.done), H(e.done);\n        if (e.done.length && !H(e.done).ranges)\n          return H(e.done);\n        if (e.done.length > 1 && !e.done[e.done.length - 2].ranges)\n          return e.done.pop(), H(e.done);\n      }\n      u(gs, \"lastChangeEvent\");\n      function Ql(e, t, i, r) {\n        var n = e.history;\n        n.undone.length = 0;\n        var l = +/* @__PURE__ */ new Date(), o, a;\n        if ((n.lastOp == r || n.lastOrigin == t.origin && t.origin && (t.origin.charAt(0) == \"+\" && n.lastModTime > l - (e.cm ? e.cm.options.historyEventDelay : 500) || t.origin.charAt(0) == \"*\")) && (o = gs(n, n.lastOp == r)))\n          a = H(o.changes), D(t.from, t.to) == 0 && D(t.from, a.to) == 0 ? a.to = Qe(t) : o.changes.push(dn(e, t));\n        else {\n          var s = H(n.done);\n          for ((!s || !s.ranges) && ei(e.sel, n.done), o = {\n            changes: [dn(e, t)],\n            generation: n.generation\n          }, n.done.push(o); n.done.length > n.undoDepth; )\n            n.done.shift(), n.done[0].ranges || n.done.shift();\n        }\n        n.done.push(i), n.generation = ++n.maxGeneration, n.lastModTime = n.lastSelTime = l, n.lastOp = n.lastSelOp = r, n.lastOrigin = n.lastSelOrigin = t.origin, a || U(e, \"historyAdded\");\n      }\n      u(Ql, \"addChangeToHistory\");\n      function ys(e, t, i, r) {\n        var n = t.charAt(0);\n        return n == \"*\" || n == \"+\" && i.ranges.length == r.ranges.length && i.somethingSelected() == r.somethingSelected() && /* @__PURE__ */ new Date() - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500);\n      }\n      u(ys, \"selectionEventCanBeMerged\");\n      function ms(e, t, i, r) {\n        var n = e.history, l = r && r.origin;\n        i == n.lastSelOp || l && n.lastSelOrigin == l && (n.lastModTime == n.lastSelTime && n.lastOrigin == l || ys(e, l, H(n.done), t)) ? n.done[n.done.length - 1] = t : ei(t, n.done), n.lastSelTime = +/* @__PURE__ */ new Date(), n.lastSelOrigin = l, n.lastSelOp = i, r && r.clearRedo !== !1 && Zl(n.undone);\n      }\n      u(ms, \"addSelectionToHistory\");\n      function ei(e, t) {\n        var i = H(t);\n        i && i.ranges && i.equals(e) || t.push(e);\n      }\n      u(ei, \"pushSelectionToHistory\");\n      function Jl(e, t, i, r) {\n        var n = t[\"spans_\" + e.id], l = 0;\n        e.iter(Math.max(e.first, i), Math.min(e.first + e.size, r), function(o) {\n          o.markedSpans && ((n || (n = t[\"spans_\" + e.id] = {}))[l] = o.markedSpans), ++l;\n        });\n      }\n      u(Jl, \"attachLocalSpans\");\n      function bs(e) {\n        if (!e)\n          return null;\n        for (var t, i = 0; i < e.length; ++i)\n          e[i].marker.explicitlyCleared ? t || (t = e.slice(0, i)) : t && t.push(e[i]);\n        return t ? t.length ? t : null : e;\n      }\n      u(bs, \"removeClearedSpans\");\n      function xs(e, t) {\n        var i = t[\"spans_\" + e.id];\n        if (!i)\n          return null;\n        for (var r = [], n = 0; n < t.text.length; ++n)\n          r.push(bs(i[n]));\n        return r;\n      }\n      u(xs, \"getOldSpans\");\n      function jl(e, t) {\n        var i = xs(e, t), r = Ei(e, t);\n        if (!i)\n          return r;\n        if (!r)\n          return i;\n        for (var n = 0; n < i.length; ++n) {\n          var l = i[n], o = r[n];\n          if (l && o)\n            e:\n              for (var a = 0; a < o.length; ++a) {\n                for (var s = o[a], f = 0; f < l.length; ++f)\n                  if (l[f].marker == s.marker)\n                    continue e;\n                l.push(s);\n              }\n          else\n            o && (i[n] = o);\n        }\n        return i;\n      }\n      u(jl, \"mergeOldSpans\");\n      function Ot(e, t, i) {\n        for (var r = [], n = 0; n < e.length; ++n) {\n          var l = e[n];\n          if (l.ranges) {\n            r.push(i ? ye.prototype.deepCopy.call(l) : l);\n            continue;\n          }\n          var o = l.changes, a = [];\n          r.push({ changes: a });\n          for (var s = 0; s < o.length; ++s) {\n            var f = o[s], h = void 0;\n            if (a.push({ from: f.from, to: f.to, text: f.text }), t)\n              for (var c in f)\n                (h = c.match(/^spans_(\\d+)$/)) && ee(t, Number(h[1])) > -1 && (H(a)[c] = f[c], delete f[c]);\n          }\n        }\n        return r;\n      }\n      u(Ot, \"copyHistoryArray\");\n      function pn(e, t, i, r) {\n        if (r) {\n          var n = e.anchor;\n          if (i) {\n            var l = D(t, n) < 0;\n            l != D(i, n) < 0 ? (n = t, t = i) : l != D(t, i) < 0 && (t = i);\n          }\n          return new W(n, t);\n        } else\n          return new W(i || t, t);\n      }\n      u(pn, \"extendRange\");\n      function ti(e, t, i, r, n) {\n        n == null && (n = e.cm && (e.cm.display.shift || e.extend)), te(e, new ye([pn(e.sel.primary(), t, i, n)], 0), r);\n      }\n      u(ti, \"extendSelection\");\n      function Vl(e, t, i) {\n        for (var r = [], n = e.cm && (e.cm.display.shift || e.extend), l = 0; l < e.sel.ranges.length; l++)\n          r[l] = pn(e.sel.ranges[l], t[l], null, n);\n        var o = ke(e.cm, r, e.sel.primIndex);\n        te(e, o, i);\n      }\n      u(Vl, \"extendSelections\");\n      function vn(e, t, i, r) {\n        var n = e.sel.ranges.slice(0);\n        n[t] = i, te(e, ke(e.cm, n, e.sel.primIndex), r);\n      }\n      u(vn, \"replaceOneSelection\");\n      function $l(e, t, i, r) {\n        te(e, Ze(t, i), r);\n      }\n      u($l, \"setSimpleSelection\");\n      function Cs(e, t, i) {\n        var r = {\n          ranges: t.ranges,\n          update: function(n) {\n            this.ranges = [];\n            for (var l = 0; l < n.length; l++)\n              this.ranges[l] = new W(\n                N(e, n[l].anchor),\n                N(e, n[l].head)\n              );\n          },\n          origin: i && i.origin\n        };\n        return U(e, \"beforeSelectionChange\", e, r), e.cm && U(e.cm, \"beforeSelectionChange\", e.cm, r), r.ranges != t.ranges ? ke(e.cm, r.ranges, r.ranges.length - 1) : t;\n      }\n      u(Cs, \"filterSelectionChange\");\n      function eo(e, t, i) {\n        var r = e.history.done, n = H(r);\n        n && n.ranges ? (r[r.length - 1] = t, ri(e, t, i)) : te(e, t, i);\n      }\n      u(eo, \"setSelectionReplaceHistory\");\n      function te(e, t, i) {\n        ri(e, t, i), ms(e, e.sel, e.cm ? e.cm.curOp.id : NaN, i);\n      }\n      u(te, \"setSelection\");\n      function ri(e, t, i) {\n        (Ce(e, \"beforeSelectionChange\") || e.cm && Ce(e.cm, \"beforeSelectionChange\")) && (t = Cs(e, t, i));\n        var r = i && i.bias || (D(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1);\n        to(e, io(e, t, r, !0)), !(i && i.scroll === !1) && e.cm && e.cm.getOption(\"readOnly\") != \"nocursor\" && Nt(e.cm);\n      }\n      u(ri, \"setSelectionNoUndo\");\n      function to(e, t) {\n        t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = 1, e.cm.curOp.selectionChanged = !0, Rn(e.cm)), Z(e, \"cursorActivity\", e));\n      }\n      u(to, \"setSelectionInner\");\n      function ro(e) {\n        to(e, io(e, e.sel, null, !1));\n      }\n      u(ro, \"reCheckSelection\");\n      function io(e, t, i, r) {\n        for (var n, l = 0; l < t.ranges.length; l++) {\n          var o = t.ranges[l], a = t.ranges.length == e.sel.ranges.length && e.sel.ranges[l], s = ii(e, o.anchor, a && a.anchor, i, r), f = ii(e, o.head, a && a.head, i, r);\n          (n || s != o.anchor || f != o.head) && (n || (n = t.ranges.slice(0, l)), n[l] = new W(s, f));\n        }\n        return n ? ke(e.cm, n, t.primIndex) : t;\n      }\n      u(io, \"skipAtomicInSelection\");\n      function Wt(e, t, i, r, n) {\n        var l = S(e, t.line);\n        if (l.markedSpans)\n          for (var o = 0; o < l.markedSpans.length; ++o) {\n            var a = l.markedSpans[o], s = a.marker, f = \"selectLeft\" in s ? !s.selectLeft : s.inclusiveLeft, h = \"selectRight\" in s ? !s.selectRight : s.inclusiveRight;\n            if ((a.from == null || (f ? a.from <= t.ch : a.from < t.ch)) && (a.to == null || (h ? a.to >= t.ch : a.to > t.ch))) {\n              if (n && (U(s, \"beforeCursorEnter\"), s.explicitlyCleared))\n                if (l.markedSpans) {\n                  --o;\n                  continue;\n                } else\n                  break;\n              if (!s.atomic)\n                continue;\n              if (i) {\n                var c = s.find(r < 0 ? 1 : -1), p = void 0;\n                if ((r < 0 ? h : f) && (c = no(e, c, -r, c && c.line == t.line ? l : null)), c && c.line == t.line && (p = D(c, i)) && (r < 0 ? p < 0 : p > 0))\n                  return Wt(e, c, t, r, n);\n              }\n              var d = s.find(r < 0 ? -1 : 1);\n              return (r < 0 ? f : h) && (d = no(e, d, r, d.line == t.line ? l : null)), d ? Wt(e, d, t, r, n) : null;\n            }\n          }\n        return t;\n      }\n      u(Wt, \"skipAtomicInner\");\n      function ii(e, t, i, r, n) {\n        var l = r || 1, o = Wt(e, t, i, l, n) || !n && Wt(e, t, i, l, !0) || Wt(e, t, i, -l, n) || !n && Wt(e, t, i, -l, !0);\n        return o || (e.cantEdit = !0, y(e.first, 0));\n      }\n      u(ii, \"skipAtomic\");\n      function no(e, t, i, r) {\n        return i < 0 && t.ch == 0 ? t.line > e.first ? N(e, y(t.line - 1)) : null : i > 0 && t.ch == (r || S(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? y(t.line + 1, 0) : null : new y(t.line, t.ch + i);\n      }\n      u(no, \"movePos\");\n      function lo(e) {\n        e.setSelection(y(e.firstLine(), 0), y(e.lastLine()), Me);\n      }\n      u(lo, \"selectAll\");\n      function oo(e, t, i) {\n        var r = {\n          canceled: !1,\n          from: t.from,\n          to: t.to,\n          text: t.text,\n          origin: t.origin,\n          cancel: function() {\n            return r.canceled = !0;\n          }\n        };\n        return i && (r.update = function(n, l, o, a) {\n          n && (r.from = N(e, n)), l && (r.to = N(e, l)), o && (r.text = o), a !== void 0 && (r.origin = a);\n        }), U(e, \"beforeChange\", e, r), e.cm && U(e.cm, \"beforeChange\", e.cm, r), r.canceled ? (e.cm && (e.cm.curOp.updateInput = 2), null) : { from: r.from, to: r.to, text: r.text, origin: r.origin };\n      }\n      u(oo, \"filterChange\");\n      function Ht(e, t, i) {\n        if (e.cm) {\n          if (!e.cm.curOp)\n            return Q(e.cm, Ht)(e, t, i);\n          if (e.cm.state.suppressEdits)\n            return;\n        }\n        if (!((Ce(e, \"beforeChange\") || e.cm && Ce(e.cm, \"beforeChange\")) && (t = oo(e, t, !0), !t))) {\n          var r = jn && !i && ma(e, t.from, t.to);\n          if (r)\n            for (var n = r.length - 1; n >= 0; --n)\n              ao(e, { from: r[n].from, to: r[n].to, text: n ? [\"\"] : t.text, origin: t.origin });\n          else\n            ao(e, t);\n        }\n      }\n      u(Ht, \"makeChange\");\n      function ao(e, t) {\n        if (!(t.text.length == 1 && t.text[0] == \"\" && D(t.from, t.to) == 0)) {\n          var i = fn(e, t);\n          Ql(e, t, i, e.cm ? e.cm.curOp.id : NaN), hr(e, t, i, Ei(e, t));\n          var r = [];\n          Je(e, function(n, l) {\n            !l && ee(r, n.history) == -1 && (ho(n.history, t), r.push(n.history)), hr(n, t, null, Ei(n, t));\n          });\n        }\n      }\n      u(ao, \"makeChangeInner\");\n      function ni(e, t, i) {\n        var r = e.cm && e.cm.state.suppressEdits;\n        if (!(r && !i)) {\n          for (var n = e.history, l, o = e.sel, a = t == \"undo\" ? n.done : n.undone, s = t == \"undo\" ? n.undone : n.done, f = 0; f < a.length && (l = a[f], !(i ? l.ranges && !l.equals(e.sel) : !l.ranges)); f++)\n            ;\n          if (f != a.length) {\n            for (n.lastOrigin = n.lastSelOrigin = null; ; )\n              if (l = a.pop(), l.ranges) {\n                if (ei(l, s), i && !l.equals(e.sel)) {\n                  te(e, l, { clearRedo: !1 });\n                  return;\n                }\n                o = l;\n              } else if (r) {\n                a.push(l);\n                return;\n              } else\n                break;\n            var h = [];\n            ei(o, s), s.push({ changes: h, generation: n.generation }), n.generation = l.generation || ++n.maxGeneration;\n            for (var c = Ce(e, \"beforeChange\") || e.cm && Ce(e.cm, \"beforeChange\"), p = /* @__PURE__ */ u(function(g) {\n              var m = l.changes[g];\n              if (m.origin = t, c && !oo(e, m, !1))\n                return a.length = 0, {};\n              h.push(dn(e, m));\n              var b = g ? fn(e, m) : H(a);\n              hr(e, m, b, jl(e, m)), !g && e.cm && e.cm.scrollIntoView({ from: m.from, to: Qe(m) });\n              var C = [];\n              Je(e, function(x, w) {\n                !w && ee(C, x.history) == -1 && (ho(x.history, m), C.push(x.history)), hr(x, m, null, jl(x, m));\n              });\n            }, \"loop\"), d = l.changes.length - 1; d >= 0; --d) {\n              var v = p(d);\n              if (v)\n                return v.v;\n            }\n          }\n        }\n      }\n      u(ni, \"makeChangeFromHistory\");\n      function so(e, t) {\n        if (t != 0 && (e.first += t, e.sel = new ye(Or(e.sel.ranges, function(n) {\n          return new W(\n            y(n.anchor.line + t, n.anchor.ch),\n            y(n.head.line + t, n.head.ch)\n          );\n        }), e.sel.primIndex), e.cm)) {\n          se(e.cm, e.first, e.first - t, t);\n          for (var i = e.cm.display, r = i.viewFrom; r < i.viewTo; r++)\n            Ye(e.cm, r, \"gutter\");\n        }\n      }\n      u(so, \"shiftDoc\");\n      function hr(e, t, i, r) {\n        if (e.cm && !e.cm.curOp)\n          return Q(e.cm, hr)(e, t, i, r);\n        if (t.to.line < e.first) {\n          so(e, t.text.length - 1 - (t.to.line - t.from.line));\n          return;\n        }\n        if (!(t.from.line > e.lastLine())) {\n          if (t.from.line < e.first) {\n            var n = t.text.length - 1 - (e.first - t.from.line);\n            so(e, n), t = {\n              from: y(e.first, 0),\n              to: y(t.to.line + n, t.to.ch),\n              text: [H(t.text)],\n              origin: t.origin\n            };\n          }\n          var l = e.lastLine();\n          t.to.line > l && (t = {\n            from: t.from,\n            to: y(l, S(e, l).text.length),\n            text: [t.text[0]],\n            origin: t.origin\n          }), t.removed = ot(e, t.from, t.to), i || (i = fn(e, t)), e.cm ? ws(e.cm, t, r) : cn(e, t, r), ri(e, i, Me), e.cantEdit && ii(e, y(e.firstLine(), 0)) && (e.cantEdit = !1);\n        }\n      }\n      u(hr, \"makeChangeSingleDoc\");\n      function ws(e, t, i) {\n        var r = e.doc, n = e.display, l = t.from, o = t.to, a = !1, s = l.line;\n        e.options.lineWrapping || (s = F(Se(S(r, l.line))), r.iter(s, o.line + 1, function(d) {\n          if (d == n.maxLine)\n            return a = !0, !0;\n        })), r.sel.contains(t.from, t.to) > -1 && Rn(e), cn(r, t, i, Ml(e)), e.options.lineWrapping || (r.iter(s, l.line + t.text.length, function(d) {\n          var v = Gr(d);\n          v > n.maxLineLength && (n.maxLine = d, n.maxLineLength = v, n.maxLineChanged = !0, a = !1);\n        }), a && (e.curOp.updateMaxLine = !0)), ha(r, l.line), sr(e, 400);\n        var f = t.text.length - (o.line - l.line) - 1;\n        t.full ? se(e) : l.line == o.line && t.text.length == 1 && !Xl(e.doc, t) ? Ye(e, l.line, \"text\") : se(e, l.line, o.line + 1, f);\n        var h = Ce(e, \"changes\"), c = Ce(e, \"change\");\n        if (c || h) {\n          var p = {\n            from: l,\n            to: o,\n            text: t.text,\n            removed: t.removed,\n            origin: t.origin\n          };\n          c && Z(e, \"change\", e, p), h && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(p);\n        }\n        e.display.selForContextMenu = null;\n      }\n      u(ws, \"makeChangeSingleDocInEditor\");\n      function Ft(e, t, i, r, n) {\n        var l;\n        r || (r = i), D(r, i) < 0 && (l = [r, i], i = l[0], r = l[1]), typeof t == \"string\" && (t = e.splitLines(t)), Ht(e, { from: i, to: r, text: t, origin: n });\n      }\n      u(Ft, \"replaceRange\");\n      function uo(e, t, i, r) {\n        i < e.line ? e.line += r : t < e.line && (e.line = t, e.ch = 0);\n      }\n      u(uo, \"rebaseHistSelSingle\");\n      function fo(e, t, i, r) {\n        for (var n = 0; n < e.length; ++n) {\n          var l = e[n], o = !0;\n          if (l.ranges) {\n            l.copied || (l = e[n] = l.deepCopy(), l.copied = !0);\n            for (var a = 0; a < l.ranges.length; a++)\n              uo(l.ranges[a].anchor, t, i, r), uo(l.ranges[a].head, t, i, r);\n            continue;\n          }\n          for (var s = 0; s < l.changes.length; ++s) {\n            var f = l.changes[s];\n            if (i < f.from.line)\n              f.from = y(f.from.line + r, f.from.ch), f.to = y(f.to.line + r, f.to.ch);\n            else if (t <= f.to.line) {\n              o = !1;\n              break;\n            }\n          }\n          o || (e.splice(0, n + 1), n = 0);\n        }\n      }\n      u(fo, \"rebaseHistArray\");\n      function ho(e, t) {\n        var i = t.from.line, r = t.to.line, n = t.text.length - (r - i) - 1;\n        fo(e.done, i, r, n), fo(e.undone, i, r, n);\n      }\n      u(ho, \"rebaseHist\");\n      function cr(e, t, i, r) {\n        var n = t, l = t;\n        return typeof t == \"number\" ? l = S(e, Un(e, t)) : n = F(t), n == null ? null : (r(l, n) && e.cm && Ye(e.cm, n, i), l);\n      }\n      u(cr, \"changeLine\");\n      function dr(e) {\n        this.lines = e, this.parent = null;\n        for (var t = 0, i = 0; i < e.length; ++i)\n          e[i].parent = this, t += e[i].height;\n        this.height = t;\n      }\n      u(dr, \"LeafChunk\"), dr.prototype = {\n        chunkSize: function() {\n          return this.lines.length;\n        },\n        // Remove the n lines at offset 'at'.\n        removeInner: function(e, t) {\n          for (var i = e, r = e + t; i < r; ++i) {\n            var n = this.lines[i];\n            this.height -= n.height, Sa(n), Z(n, \"delete\");\n          }\n          this.lines.splice(e, t);\n        },\n        // Helper used to collapse a small branch into a single leaf.\n        collapse: function(e) {\n          e.push.apply(e, this.lines);\n        },\n        // Insert the given array of lines at offset 'at', count them as\n        // having the given height.\n        insertInner: function(e, t, i) {\n          this.height += i, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e));\n          for (var r = 0; r < t.length; ++r)\n            t[r].parent = this;\n        },\n        // Used to iterate over a part of the tree.\n        iterN: function(e, t, i) {\n          for (var r = e + t; e < r; ++e)\n            if (i(this.lines[e]))\n              return !0;\n        }\n      };\n      function pr(e) {\n        this.children = e;\n        for (var t = 0, i = 0, r = 0; r < e.length; ++r) {\n          var n = e[r];\n          t += n.chunkSize(), i += n.height, n.parent = this;\n        }\n        this.size = t, this.height = i, this.parent = null;\n      }\n      u(pr, \"BranchChunk\"), pr.prototype = {\n        chunkSize: function() {\n          return this.size;\n        },\n        removeInner: function(e, t) {\n          this.size -= t;\n          for (var i = 0; i < this.children.length; ++i) {\n            var r = this.children[i], n = r.chunkSize();\n            if (e < n) {\n              var l = Math.min(t, n - e), o = r.height;\n              if (r.removeInner(e, l), this.height -= o - r.height, n == l && (this.children.splice(i--, 1), r.parent = null), (t -= l) == 0)\n                break;\n              e = 0;\n            } else\n              e -= n;\n          }\n          if (this.size - t < 25 && (this.children.length > 1 || !(this.children[0] instanceof dr))) {\n            var a = [];\n            this.collapse(a), this.children = [new dr(a)], this.children[0].parent = this;\n          }\n        },\n        collapse: function(e) {\n          for (var t = 0; t < this.children.length; ++t)\n            this.children[t].collapse(e);\n        },\n        insertInner: function(e, t, i) {\n          this.size += t.length, this.height += i;\n          for (var r = 0; r < this.children.length; ++r) {\n            var n = this.children[r], l = n.chunkSize();\n            if (e <= l) {\n              if (n.insertInner(e, t, i), n.lines && n.lines.length > 50) {\n                for (var o = n.lines.length % 25 + 25, a = o; a < n.lines.length; ) {\n                  var s = new dr(n.lines.slice(a, a += 25));\n                  n.height -= s.height, this.children.splice(++r, 0, s), s.parent = this;\n                }\n                n.lines = n.lines.slice(0, o), this.maybeSpill();\n              }\n              break;\n            }\n            e -= l;\n          }\n        },\n        // When a node has grown, check whether it should be split.\n        maybeSpill: function() {\n          if (!(this.children.length <= 10)) {\n            var e = this;\n            do {\n              var t = e.children.splice(e.children.length - 5, 5), i = new pr(t);\n              if (e.parent) {\n                e.size -= i.size, e.height -= i.height;\n                var n = ee(e.parent.children, e);\n                e.parent.children.splice(n + 1, 0, i);\n              } else {\n                var r = new pr(e.children);\n                r.parent = e, e.children = [r, i], e = r;\n              }\n              i.parent = e.parent;\n            } while (e.children.length > 10);\n            e.parent.maybeSpill();\n          }\n        },\n        iterN: function(e, t, i) {\n          for (var r = 0; r < this.children.length; ++r) {\n            var n = this.children[r], l = n.chunkSize();\n            if (e < l) {\n              var o = Math.min(t, l - e);\n              if (n.iterN(e, o, i))\n                return !0;\n              if ((t -= o) == 0)\n                break;\n              e = 0;\n            } else\n              e -= l;\n          }\n        }\n      };\n      var vr = /* @__PURE__ */ u(function(e, t, i) {\n        if (i)\n          for (var r in i)\n            i.hasOwnProperty(r) && (this[r] = i[r]);\n        this.doc = e, this.node = t;\n      }, \"LineWidget\");\n      vr.prototype.clear = function() {\n        var e = this.doc.cm, t = this.line.widgets, i = this.line, r = F(i);\n        if (!(r == null || !t)) {\n          for (var n = 0; n < t.length; ++n)\n            t[n] == this && t.splice(n--, 1);\n          t.length || (i.widgets = null);\n          var l = tr(this);\n          De(i, Math.max(0, i.height - l)), e && (de(e, function() {\n            co(e, i, -l), Ye(e, r, \"widget\");\n          }), Z(e, \"lineWidgetCleared\", e, this, r));\n        }\n      }, vr.prototype.changed = function() {\n        var e = this, t = this.height, i = this.doc.cm, r = this.line;\n        this.height = null;\n        var n = tr(this) - t;\n        n && (Xe(this.doc, r) || De(r, r.height + n), i && de(i, function() {\n          i.curOp.forceUpdate = !0, co(i, r, n), Z(i, \"lineWidgetChanged\", i, e, F(r));\n        }));\n      }, xt(vr);\n      function co(e, t, i) {\n        Ie(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && nn(e, i);\n      }\n      u(co, \"adjustScrollWhenAboveVisible\");\n      function Ss(e, t, i, r) {\n        var n = new vr(e, i, r), l = e.cm;\n        return l && n.noHScroll && (l.display.alignWidgets = !0), cr(e, t, \"widget\", function(o) {\n          var a = o.widgets || (o.widgets = []);\n          if (n.insertAt == null ? a.push(n) : a.splice(Math.min(a.length, Math.max(0, n.insertAt)), 0, n), n.line = o, l && !Xe(e, o)) {\n            var s = Ie(o) < e.scrollTop;\n            De(o, o.height + tr(n)), s && nn(l, n.height), l.curOp.forceUpdate = !0;\n          }\n          return !0;\n        }), l && Z(l, \"lineWidgetAdded\", l, n, typeof t == \"number\" ? t : F(t)), n;\n      }\n      u(Ss, \"addLineWidget\");\n      var po = 0, je = /* @__PURE__ */ u(function(e, t) {\n        this.lines = [], this.type = t, this.doc = e, this.id = ++po;\n      }, \"TextMarker\");\n      je.prototype.clear = function() {\n        if (!this.explicitlyCleared) {\n          var e = this.doc.cm, t = e && !e.curOp;\n          if (t && pt(e), Ce(this, \"clear\")) {\n            var i = this.find();\n            i && Z(this, \"clear\", i.from, i.to);\n          }\n          for (var r = null, n = null, l = 0; l < this.lines.length; ++l) {\n            var o = this.lines[l], a = Vt(o.markedSpans, this);\n            e && !this.collapsed ? Ye(e, F(o), \"text\") : e && (a.to != null && (n = F(o)), a.from != null && (r = F(o))), o.markedSpans = pa(o.markedSpans, a), a.from == null && this.collapsed && !Xe(this.doc, o) && e && De(o, Tt(e.display));\n          }\n          if (e && this.collapsed && !e.options.lineWrapping)\n            for (var s = 0; s < this.lines.length; ++s) {\n              var f = Se(this.lines[s]), h = Gr(f);\n              h > e.display.maxLineLength && (e.display.maxLine = f, e.display.maxLineLength = h, e.display.maxLineChanged = !0);\n            }\n          r != null && e && this.collapsed && se(e, r, n + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && ro(e.doc)), e && Z(e, \"markerCleared\", e, this, r, n), t && vt(e), this.parent && this.parent.clear();\n        }\n      }, je.prototype.find = function(e, t) {\n        e == null && this.type == \"bookmark\" && (e = 1);\n        for (var i, r, n = 0; n < this.lines.length; ++n) {\n          var l = this.lines[n], o = Vt(l.markedSpans, this);\n          if (o.from != null && (i = y(t ? l : F(l), o.from), e == -1))\n            return i;\n          if (o.to != null && (r = y(t ? l : F(l), o.to), e == 1))\n            return r;\n        }\n        return i && { from: i, to: r };\n      }, je.prototype.changed = function() {\n        var e = this, t = this.find(-1, !0), i = this, r = this.doc.cm;\n        !t || !r || de(r, function() {\n          var n = t.line, l = F(t.line), o = _i(r, l);\n          if (o && (bl(o), r.curOp.selectionChanged = r.curOp.forceUpdate = !0), r.curOp.updateMaxLine = !0, !Xe(i.doc, n) && i.height != null) {\n            var a = i.height;\n            i.height = null;\n            var s = tr(i) - a;\n            s && De(n, n.height + s);\n          }\n          Z(r, \"markerChanged\", r, e);\n        });\n      }, je.prototype.attachLine = function(e) {\n        if (!this.lines.length && this.doc.cm) {\n          var t = this.doc.cm.curOp;\n          (!t.maybeHiddenMarkers || ee(t.maybeHiddenMarkers, this) == -1) && (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this);\n        }\n        this.lines.push(e);\n      }, je.prototype.detachLine = function(e) {\n        if (this.lines.splice(ee(this.lines, e), 1), !this.lines.length && this.doc.cm) {\n          var t = this.doc.cm.curOp;\n          (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this);\n        }\n      }, xt(je);\n      function Pt(e, t, i, r, n) {\n        if (r && r.shared)\n          return Ls(e, t, i, r, n);\n        if (e.cm && !e.cm.curOp)\n          return Q(e.cm, Pt)(e, t, i, r, n);\n        var l = new je(e, n), o = D(t, i);\n        if (r && nt(r, l, !1), o > 0 || o == 0 && l.clearWhenEmpty !== !1)\n          return l;\n        if (l.replacedWith && (l.collapsed = !0, l.widgetNode = bt(\"span\", [l.replacedWith], \"CodeMirror-widget\"), r.handleMouseEvents || l.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"), r.insertLeft && (l.widgetNode.insertLeft = !0)), l.collapsed) {\n          if (il(e, t.line, t, i, l) || t.line != i.line && il(e, i.line, t, i, l))\n            throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n          da();\n        }\n        l.addToHistory && Ql(e, { from: t, to: i, origin: \"markText\" }, e.sel, NaN);\n        var a = t.line, s = e.cm, f;\n        if (e.iter(a, i.line + 1, function(c) {\n          s && l.collapsed && !s.options.lineWrapping && Se(c) == s.display.maxLine && (f = !0), l.collapsed && a != t.line && De(c, 0), va(c, new Ir(\n            l,\n            a == t.line ? t.ch : null,\n            a == i.line ? i.ch : null\n          ), e.cm && e.cm.curOp), ++a;\n        }), l.collapsed && e.iter(t.line, i.line + 1, function(c) {\n          Xe(e, c) && De(c, 0);\n        }), l.clearOnEnter && M(l, \"beforeCursorEnter\", function() {\n          return l.clear();\n        }), l.readOnly && (ca(), (e.history.done.length || e.history.undone.length) && e.clearHistory()), l.collapsed && (l.id = ++po, l.atomic = !0), s) {\n          if (f && (s.curOp.updateMaxLine = !0), l.collapsed)\n            se(s, t.line, i.line + 1);\n          else if (l.className || l.startStyle || l.endStyle || l.css || l.attributes || l.title)\n            for (var h = t.line; h <= i.line; h++)\n              Ye(s, h, \"text\");\n          l.atomic && ro(s.doc), Z(s, \"markerAdded\", s, l);\n        }\n        return l;\n      }\n      u(Pt, \"markText\");\n      var gr = /* @__PURE__ */ u(function(e, t) {\n        this.markers = e, this.primary = t;\n        for (var i = 0; i < e.length; ++i)\n          e[i].parent = this;\n      }, \"SharedTextMarker\");\n      gr.prototype.clear = function() {\n        if (!this.explicitlyCleared) {\n          this.explicitlyCleared = !0;\n          for (var e = 0; e < this.markers.length; ++e)\n            this.markers[e].clear();\n          Z(this, \"clear\");\n        }\n      }, gr.prototype.find = function(e, t) {\n        return this.primary.find(e, t);\n      }, xt(gr);\n      function Ls(e, t, i, r, n) {\n        r = nt(r), r.shared = !1;\n        var l = [Pt(e, t, i, r, n)], o = l[0], a = r.widgetNode;\n        return Je(e, function(s) {\n          a && (r.widgetNode = a.cloneNode(!0)), l.push(Pt(s, N(s, t), N(s, i), r, n));\n          for (var f = 0; f < s.linked.length; ++f)\n            if (s.linked[f].isParent)\n              return;\n          o = H(l);\n        }), new gr(l, o);\n      }\n      u(Ls, \"markTextShared\");\n      function vo(e) {\n        return e.findMarks(y(e.first, 0), e.clipPos(y(e.lastLine())), function(t) {\n          return t.parent;\n        });\n      }\n      u(vo, \"findSharedMarkers\");\n      function ks(e, t) {\n        for (var i = 0; i < t.length; i++) {\n          var r = t[i], n = r.find(), l = e.clipPos(n.from), o = e.clipPos(n.to);\n          if (D(l, o)) {\n            var a = Pt(e, l, o, r.primary, r.primary.type);\n            r.markers.push(a), a.parent = r;\n          }\n        }\n      }\n      u(ks, \"copySharedMarkers\");\n      function Ts(e) {\n        for (var t = /* @__PURE__ */ u(function(r) {\n          var n = e[r], l = [n.primary.doc];\n          Je(n.primary.doc, function(s) {\n            return l.push(s);\n          });\n          for (var o = 0; o < n.markers.length; o++) {\n            var a = n.markers[o];\n            ee(l, a.doc) == -1 && (a.parent = null, n.markers.splice(o--, 1));\n          }\n        }, \"loop\"), i = 0; i < e.length; i++)\n          t(i);\n      }\n      u(Ts, \"detachSharedMarkers\");\n      var Ms = 0, ue = /* @__PURE__ */ u(function(e, t, i, r, n) {\n        if (!(this instanceof ue))\n          return new ue(e, t, i, r, n);\n        i == null && (i = 0), pr.call(this, [new dr([new St(\"\", null)])]), this.first = i, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = i;\n        var l = y(i, 0);\n        this.sel = Ze(l), this.history = new $r(null), this.id = ++Ms, this.modeOption = t, this.lineSep = r, this.direction = n == \"rtl\" ? \"rtl\" : \"ltr\", this.extend = !1, typeof e == \"string\" && (e = this.splitLines(e)), cn(this, { from: l, to: l, text: e }), te(this, Ze(l), Me);\n      }, \"Doc\");\n      ue.prototype = Fn(pr.prototype, {\n        constructor: ue,\n        // Iterate over the document. Supports two forms -- with only one\n        // argument, it calls that for each line in the document. With\n        // three, it iterates over the range given by the first two (with\n        // the second being non-inclusive).\n        iter: function(e, t, i) {\n          i ? this.iterN(e - this.first, t - e, i) : this.iterN(this.first, this.first + this.size, e);\n        },\n        // Non-public interface for adding and removing lines.\n        insert: function(e, t) {\n          for (var i = 0, r = 0; r < t.length; ++r)\n            i += t[r].height;\n          this.insertInner(e - this.first, t, i);\n        },\n        remove: function(e, t) {\n          this.removeInner(e - this.first, t);\n        },\n        // From here, the methods are part of the public interface. Most\n        // are also available from CodeMirror (editor) instances.\n        getValue: function(e) {\n          var t = Ai(this, this.first, this.first + this.size);\n          return e === !1 ? t : t.join(e || this.lineSeparator());\n        },\n        setValue: J(function(e) {\n          var t = y(this.first, 0), i = this.first + this.size - 1;\n          Ht(this, {\n            from: t,\n            to: y(i, S(this, i).text.length),\n            text: this.splitLines(e),\n            origin: \"setValue\",\n            full: !0\n          }, !0), this.cm && nr(this.cm, 0, 0), te(this, Ze(t), Me);\n        }),\n        replaceRange: function(e, t, i, r) {\n          t = N(this, t), i = i ? N(this, i) : t, Ft(this, e, t, i, r);\n        },\n        getRange: function(e, t, i) {\n          var r = ot(this, N(this, e), N(this, t));\n          return i === !1 ? r : i === \"\" ? r.join(\"\") : r.join(i || this.lineSeparator());\n        },\n        getLine: function(e) {\n          var t = this.getLineHandle(e);\n          return t && t.text;\n        },\n        getLineHandle: function(e) {\n          if (Jt(this, e))\n            return S(this, e);\n        },\n        getLineNumber: function(e) {\n          return F(e);\n        },\n        getLineHandleVisualStart: function(e) {\n          return typeof e == \"number\" && (e = S(this, e)), Se(e);\n        },\n        lineCount: function() {\n          return this.size;\n        },\n        firstLine: function() {\n          return this.first;\n        },\n        lastLine: function() {\n          return this.first + this.size - 1;\n        },\n        clipPos: function(e) {\n          return N(this, e);\n        },\n        getCursor: function(e) {\n          var t = this.sel.primary(), i;\n          return e == null || e == \"head\" ? i = t.head : e == \"anchor\" ? i = t.anchor : e == \"end\" || e == \"to\" || e === !1 ? i = t.to() : i = t.from(), i;\n        },\n        listSelections: function() {\n          return this.sel.ranges;\n        },\n        somethingSelected: function() {\n          return this.sel.somethingSelected();\n        },\n        setCursor: J(function(e, t, i) {\n          $l(this, N(this, typeof e == \"number\" ? y(e, t || 0) : e), null, i);\n        }),\n        setSelection: J(function(e, t, i) {\n          $l(this, N(this, e), N(this, t || e), i);\n        }),\n        extendSelection: J(function(e, t, i) {\n          ti(this, N(this, e), t && N(this, t), i);\n        }),\n        extendSelections: J(function(e, t) {\n          Vl(this, Kn(this, e), t);\n        }),\n        extendSelectionsBy: J(function(e, t) {\n          var i = Or(this.sel.ranges, e);\n          Vl(this, Kn(this, i), t);\n        }),\n        setSelections: J(function(e, t, i) {\n          if (e.length) {\n            for (var r = [], n = 0; n < e.length; n++)\n              r[n] = new W(\n                N(this, e[n].anchor),\n                N(this, e[n].head || e[n].anchor)\n              );\n            t == null && (t = Math.min(e.length - 1, this.sel.primIndex)), te(this, ke(this.cm, r, t), i);\n          }\n        }),\n        addSelection: J(function(e, t, i) {\n          var r = this.sel.ranges.slice(0);\n          r.push(new W(N(this, e), N(this, t || e))), te(this, ke(this.cm, r, r.length - 1), i);\n        }),\n        getSelection: function(e) {\n          for (var t = this.sel.ranges, i, r = 0; r < t.length; r++) {\n            var n = ot(this, t[r].from(), t[r].to());\n            i = i ? i.concat(n) : n;\n          }\n          return e === !1 ? i : i.join(e || this.lineSeparator());\n        },\n        getSelections: function(e) {\n          for (var t = [], i = this.sel.ranges, r = 0; r < i.length; r++) {\n            var n = ot(this, i[r].from(), i[r].to());\n            e !== !1 && (n = n.join(e || this.lineSeparator())), t[r] = n;\n          }\n          return t;\n        },\n        replaceSelection: function(e, t, i) {\n          for (var r = [], n = 0; n < this.sel.ranges.length; n++)\n            r[n] = e;\n          this.replaceSelections(r, t, i || \"+input\");\n        },\n        replaceSelections: J(function(e, t, i) {\n          for (var r = [], n = this.sel, l = 0; l < n.ranges.length; l++) {\n            var o = n.ranges[l];\n            r[l] = { from: o.from(), to: o.to(), text: this.splitLines(e[l]), origin: i };\n          }\n          for (var a = t && t != \"end\" && ps(this, r, t), s = r.length - 1; s >= 0; s--)\n            Ht(this, r[s]);\n          a ? eo(this, a) : this.cm && Nt(this.cm);\n        }),\n        undo: J(function() {\n          ni(this, \"undo\");\n        }),\n        redo: J(function() {\n          ni(this, \"redo\");\n        }),\n        undoSelection: J(function() {\n          ni(this, \"undo\", !0);\n        }),\n        redoSelection: J(function() {\n          ni(this, \"redo\", !0);\n        }),\n        setExtending: function(e) {\n          this.extend = e;\n        },\n        getExtending: function() {\n          return this.extend;\n        },\n        historySize: function() {\n          for (var e = this.history, t = 0, i = 0, r = 0; r < e.done.length; r++)\n            e.done[r].ranges || ++t;\n          for (var n = 0; n < e.undone.length; n++)\n            e.undone[n].ranges || ++i;\n          return { undo: t, redo: i };\n        },\n        clearHistory: function() {\n          var e = this;\n          this.history = new $r(this.history), Je(this, function(t) {\n            return t.history = e.history;\n          }, !0);\n        },\n        markClean: function() {\n          this.cleanGeneration = this.changeGeneration(!0);\n        },\n        changeGeneration: function(e) {\n          return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation;\n        },\n        isClean: function(e) {\n          return this.history.generation == (e || this.cleanGeneration);\n        },\n        getHistory: function() {\n          return {\n            done: Ot(this.history.done),\n            undone: Ot(this.history.undone)\n          };\n        },\n        setHistory: function(e) {\n          var t = this.history = new $r(this.history);\n          t.done = Ot(e.done.slice(0), null, !0), t.undone = Ot(e.undone.slice(0), null, !0);\n        },\n        setGutterMarker: J(function(e, t, i) {\n          return cr(this, e, \"gutter\", function(r) {\n            var n = r.gutterMarkers || (r.gutterMarkers = {});\n            return n[t] = i, !i && Pn(n) && (r.gutterMarkers = null), !0;\n          });\n        }),\n        clearGutter: J(function(e) {\n          var t = this;\n          this.iter(function(i) {\n            i.gutterMarkers && i.gutterMarkers[e] && cr(t, i, \"gutter\", function() {\n              return i.gutterMarkers[e] = null, Pn(i.gutterMarkers) && (i.gutterMarkers = null), !0;\n            });\n          });\n        }),\n        lineInfo: function(e) {\n          var t;\n          if (typeof e == \"number\") {\n            if (!Jt(this, e) || (t = e, e = S(this, e), !e))\n              return null;\n          } else if (t = F(e), t == null)\n            return null;\n          return {\n            line: t,\n            handle: e,\n            text: e.text,\n            gutterMarkers: e.gutterMarkers,\n            textClass: e.textClass,\n            bgClass: e.bgClass,\n            wrapClass: e.wrapClass,\n            widgets: e.widgets\n          };\n        },\n        addLineClass: J(function(e, t, i) {\n          return cr(this, e, t == \"gutter\" ? \"gutter\" : \"class\", function(r) {\n            var n = t == \"text\" ? \"textClass\" : t == \"background\" ? \"bgClass\" : t == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n            if (!r[n])\n              r[n] = i;\n            else {\n              if (mt(i).test(r[n]))\n                return !1;\n              r[n] += \" \" + i;\n            }\n            return !0;\n          });\n        }),\n        removeLineClass: J(function(e, t, i) {\n          return cr(this, e, t == \"gutter\" ? \"gutter\" : \"class\", function(r) {\n            var n = t == \"text\" ? \"textClass\" : t == \"background\" ? \"bgClass\" : t == \"gutter\" ? \"gutterClass\" : \"wrapClass\", l = r[n];\n            if (l)\n              if (i == null)\n                r[n] = null;\n              else {\n                var o = l.match(mt(i));\n                if (!o)\n                  return !1;\n                var a = o.index + o[0].length;\n                r[n] = l.slice(0, o.index) + (!o.index || a == l.length ? \"\" : \" \") + l.slice(a) || null;\n              }\n            else\n              return !1;\n            return !0;\n          });\n        }),\n        addLineWidget: J(function(e, t, i) {\n          return Ss(this, e, t, i);\n        }),\n        removeLineWidget: function(e) {\n          e.clear();\n        },\n        markText: function(e, t, i) {\n          return Pt(this, N(this, e), N(this, t), i, i && i.type || \"range\");\n        },\n        setBookmark: function(e, t) {\n          var i = {\n            replacedWith: t && (t.nodeType == null ? t.widget : t),\n            insertLeft: t && t.insertLeft,\n            clearWhenEmpty: !1,\n            shared: t && t.shared,\n            handleMouseEvents: t && t.handleMouseEvents\n          };\n          return e = N(this, e), Pt(this, e, e, i, \"bookmark\");\n        },\n        findMarksAt: function(e) {\n          e = N(this, e);\n          var t = [], i = S(this, e.line).markedSpans;\n          if (i)\n            for (var r = 0; r < i.length; ++r) {\n              var n = i[r];\n              (n.from == null || n.from <= e.ch) && (n.to == null || n.to >= e.ch) && t.push(n.marker.parent || n.marker);\n            }\n          return t;\n        },\n        findMarks: function(e, t, i) {\n          e = N(this, e), t = N(this, t);\n          var r = [], n = e.line;\n          return this.iter(e.line, t.line + 1, function(l) {\n            var o = l.markedSpans;\n            if (o)\n              for (var a = 0; a < o.length; a++) {\n                var s = o[a];\n                !(s.to != null && n == e.line && e.ch >= s.to || s.from == null && n != e.line || s.from != null && n == t.line && s.from >= t.ch) && (!i || i(s.marker)) && r.push(s.marker.parent || s.marker);\n              }\n            ++n;\n          }), r;\n        },\n        getAllMarks: function() {\n          var e = [];\n          return this.iter(function(t) {\n            var i = t.markedSpans;\n            if (i)\n              for (var r = 0; r < i.length; ++r)\n                i[r].from != null && e.push(i[r].marker);\n          }), e;\n        },\n        posFromIndex: function(e) {\n          var t, i = this.first, r = this.lineSeparator().length;\n          return this.iter(function(n) {\n            var l = n.text.length + r;\n            if (l > e)\n              return t = e, !0;\n            e -= l, ++i;\n          }), N(this, y(i, t));\n        },\n        indexFromPos: function(e) {\n          e = N(this, e);\n          var t = e.ch;\n          if (e.line < this.first || e.ch < 0)\n            return 0;\n          var i = this.lineSeparator().length;\n          return this.iter(this.first, e.line, function(r) {\n            t += r.text.length + i;\n          }), t;\n        },\n        copy: function(e) {\n          var t = new ue(\n            Ai(this, this.first, this.first + this.size),\n            this.modeOption,\n            this.first,\n            this.lineSep,\n            this.direction\n          );\n          return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t;\n        },\n        linkedDoc: function(e) {\n          e || (e = {});\n          var t = this.first, i = this.first + this.size;\n          e.from != null && e.from > t && (t = e.from), e.to != null && e.to < i && (i = e.to);\n          var r = new ue(Ai(this, t, i), e.mode || this.modeOption, t, this.lineSep, this.direction);\n          return e.sharedHist && (r.history = this.history), (this.linked || (this.linked = [])).push({ doc: r, sharedHist: e.sharedHist }), r.linked = [{ doc: this, isParent: !0, sharedHist: e.sharedHist }], ks(r, vo(this)), r;\n        },\n        unlinkDoc: function(e) {\n          if (e instanceof R && (e = e.doc), this.linked)\n            for (var t = 0; t < this.linked.length; ++t) {\n              var i = this.linked[t];\n              if (i.doc == e) {\n                this.linked.splice(t, 1), e.unlinkDoc(this), Ts(vo(this));\n                break;\n              }\n            }\n          if (e.history == this.history) {\n            var r = [e.id];\n            Je(e, function(n) {\n              return r.push(n.id);\n            }, !0), e.history = new $r(null), e.history.done = Ot(this.history.done, r), e.history.undone = Ot(this.history.undone, r);\n          }\n        },\n        iterLinkedDocs: function(e) {\n          Je(this, e);\n        },\n        getMode: function() {\n          return this.mode;\n        },\n        getEditor: function() {\n          return this.cm;\n        },\n        splitLines: function(e) {\n          return this.lineSep ? e.split(this.lineSep) : ki(e);\n        },\n        lineSeparator: function() {\n          return this.lineSep || `\n`;\n        },\n        setDirection: J(function(e) {\n          e != \"rtl\" && (e = \"ltr\"), e != this.direction && (this.direction = e, this.iter(function(t) {\n            return t.order = null;\n          }), this.cm && vs(this.cm));\n        })\n      }), ue.prototype.eachLine = ue.prototype.iter;\n      var go = 0;\n      function Ds(e) {\n        var t = this;\n        if (yo(t), !(q(t, e) || Re(t.display, e))) {\n          ae(e), O && (go = +/* @__PURE__ */ new Date());\n          var i = ft(t, e, !0), r = e.dataTransfer.files;\n          if (!(!i || t.isReadOnly()))\n            if (r && r.length && window.FileReader && window.File)\n              for (var n = r.length, l = Array(n), o = 0, a = /* @__PURE__ */ u(function() {\n                ++o == n && Q(t, function() {\n                  i = N(t.doc, i);\n                  var d = {\n                    from: i,\n                    to: i,\n                    text: t.doc.splitLines(\n                      l.filter(function(v) {\n                        return v != null;\n                      }).join(t.doc.lineSeparator())\n                    ),\n                    origin: \"paste\"\n                  };\n                  Ht(t.doc, d), eo(t.doc, Ze(N(t.doc, i), N(t.doc, Qe(d))));\n                })();\n              }, \"markAsReadAndPasteIfAllFilesAreRead\"), s = /* @__PURE__ */ u(function(d, v) {\n                if (t.options.allowDropFileTypes && ee(t.options.allowDropFileTypes, d.type) == -1) {\n                  a();\n                  return;\n                }\n                var g = new FileReader();\n                g.onerror = function() {\n                  return a();\n                }, g.onload = function() {\n                  var m = g.result;\n                  if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(m)) {\n                    a();\n                    return;\n                  }\n                  l[v] = m, a();\n                }, g.readAsText(d);\n              }, \"readTextFromFile\"), f = 0; f < r.length; f++)\n                s(r[f], f);\n            else {\n              if (t.state.draggingText && t.doc.sel.contains(i) > -1) {\n                t.state.draggingText(e), setTimeout(function() {\n                  return t.display.input.focus();\n                }, 20);\n                return;\n              }\n              try {\n                var h = e.dataTransfer.getData(\"Text\");\n                if (h) {\n                  var c;\n                  if (t.state.draggingText && !t.state.draggingText.copy && (c = t.listSelections()), ri(t.doc, Ze(i, i)), c)\n                    for (var p = 0; p < c.length; ++p)\n                      Ft(t.doc, \"\", c[p].anchor, c[p].head, \"drag\");\n                  t.replaceSelection(h, \"around\", \"paste\"), t.display.input.focus();\n                }\n              } catch {\n              }\n            }\n        }\n      }\n      u(Ds, \"onDrop\");\n      function Ns(e, t) {\n        if (O && (!e.state.draggingText || +/* @__PURE__ */ new Date() - go < 100)) {\n          Qt(t);\n          return;\n        }\n        if (!(q(e, t) || Re(e.display, t)) && (t.dataTransfer.setData(\"Text\", e.getSelection()), t.dataTransfer.effectAllowed = \"copyMove\", t.dataTransfer.setDragImage && !Mr)) {\n          var i = T(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n          i.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\", we && (i.width = i.height = 1, e.display.wrapper.appendChild(i), i._top = i.offsetTop), t.dataTransfer.setDragImage(i, 0, 0), we && i.parentNode.removeChild(i);\n        }\n      }\n      u(Ns, \"onDragStart\");\n      function As(e, t) {\n        var i = ft(e, t);\n        if (i) {\n          var r = document.createDocumentFragment();\n          Vi(e, i, r), e.display.dragCursor || (e.display.dragCursor = T(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\"), e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)), ve(e.display.dragCursor, r);\n        }\n      }\n      u(As, \"onDragOver\");\n      function yo(e) {\n        e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null);\n      }\n      u(yo, \"clearDragCursor\");\n      function mo(e) {\n        if (document.getElementsByClassName) {\n          for (var t = document.getElementsByClassName(\"CodeMirror\"), i = [], r = 0; r < t.length; r++) {\n            var n = t[r].CodeMirror;\n            n && i.push(n);\n          }\n          i.length && i[0].operation(function() {\n            for (var l = 0; l < i.length; l++)\n              e(i[l]);\n          });\n        }\n      }\n      u(mo, \"forEachCodeMirror\");\n      var bo = !1;\n      function Os() {\n        bo || (Ws(), bo = !0);\n      }\n      u(Os, \"ensureGlobalHandlers\");\n      function Ws() {\n        var e;\n        M(window, \"resize\", function() {\n          e == null && (e = setTimeout(function() {\n            e = null, mo(Hs);\n          }, 100));\n        }), M(window, \"blur\", function() {\n          return mo(Dt);\n        });\n      }\n      u(Ws, \"registerGlobalHandlers\");\n      function Hs(e) {\n        var t = e.display;\n        t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize();\n      }\n      u(Hs, \"onResize\");\n      for (var Ve = {\n        3: \"Pause\",\n        8: \"Backspace\",\n        9: \"Tab\",\n        13: \"Enter\",\n        16: \"Shift\",\n        17: \"Ctrl\",\n        18: \"Alt\",\n        19: \"Pause\",\n        20: \"CapsLock\",\n        27: \"Esc\",\n        32: \"Space\",\n        33: \"PageUp\",\n        34: \"PageDown\",\n        35: \"End\",\n        36: \"Home\",\n        37: \"Left\",\n        38: \"Up\",\n        39: \"Right\",\n        40: \"Down\",\n        44: \"PrintScrn\",\n        45: \"Insert\",\n        46: \"Delete\",\n        59: \";\",\n        61: \"=\",\n        91: \"Mod\",\n        92: \"Mod\",\n        93: \"Mod\",\n        106: \"*\",\n        107: \"=\",\n        109: \"-\",\n        110: \".\",\n        111: \"/\",\n        145: \"ScrollLock\",\n        173: \"-\",\n        186: \";\",\n        187: \"=\",\n        188: \",\",\n        189: \"-\",\n        190: \".\",\n        191: \"/\",\n        192: \"`\",\n        219: \"[\",\n        220: \"\\\\\",\n        221: \"]\",\n        222: \"'\",\n        224: \"Mod\",\n        63232: \"Up\",\n        63233: \"Down\",\n        63234: \"Left\",\n        63235: \"Right\",\n        63272: \"Delete\",\n        63273: \"Home\",\n        63275: \"End\",\n        63276: \"PageUp\",\n        63277: \"PageDown\",\n        63302: \"Insert\"\n      }, yr = 0; yr < 10; yr++)\n        Ve[yr + 48] = Ve[yr + 96] = String(yr);\n      for (var li = 65; li <= 90; li++)\n        Ve[li] = String.fromCharCode(li);\n      for (var mr = 1; mr <= 12; mr++)\n        Ve[mr + 111] = Ve[mr + 63235] = \"F\" + mr;\n      var ze = {};\n      ze.basic = {\n        Left: \"goCharLeft\",\n        Right: \"goCharRight\",\n        Up: \"goLineUp\",\n        Down: \"goLineDown\",\n        End: \"goLineEnd\",\n        Home: \"goLineStartSmart\",\n        PageUp: \"goPageUp\",\n        PageDown: \"goPageDown\",\n        Delete: \"delCharAfter\",\n        Backspace: \"delCharBefore\",\n        \"Shift-Backspace\": \"delCharBefore\",\n        Tab: \"defaultTab\",\n        \"Shift-Tab\": \"indentAuto\",\n        Enter: \"newlineAndIndent\",\n        Insert: \"toggleOverwrite\",\n        Esc: \"singleSelection\"\n      }, ze.pcDefault = {\n        \"Ctrl-A\": \"selectAll\",\n        \"Ctrl-D\": \"deleteLine\",\n        \"Ctrl-Z\": \"undo\",\n        \"Shift-Ctrl-Z\": \"redo\",\n        \"Ctrl-Y\": \"redo\",\n        \"Ctrl-Home\": \"goDocStart\",\n        \"Ctrl-End\": \"goDocEnd\",\n        \"Ctrl-Up\": \"goLineUp\",\n        \"Ctrl-Down\": \"goLineDown\",\n        \"Ctrl-Left\": \"goGroupLeft\",\n        \"Ctrl-Right\": \"goGroupRight\",\n        \"Alt-Left\": \"goLineStart\",\n        \"Alt-Right\": \"goLineEnd\",\n        \"Ctrl-Backspace\": \"delGroupBefore\",\n        \"Ctrl-Delete\": \"delGroupAfter\",\n        \"Ctrl-S\": \"save\",\n        \"Ctrl-F\": \"find\",\n        \"Ctrl-G\": \"findNext\",\n        \"Shift-Ctrl-G\": \"findPrev\",\n        \"Shift-Ctrl-F\": \"replace\",\n        \"Shift-Ctrl-R\": \"replaceAll\",\n        \"Ctrl-[\": \"indentLess\",\n        \"Ctrl-]\": \"indentMore\",\n        \"Ctrl-U\": \"undoSelection\",\n        \"Shift-Ctrl-U\": \"redoSelection\",\n        \"Alt-U\": \"redoSelection\",\n        fallthrough: \"basic\"\n      }, ze.emacsy = {\n        \"Ctrl-F\": \"goCharRight\",\n        \"Ctrl-B\": \"goCharLeft\",\n        \"Ctrl-P\": \"goLineUp\",\n        \"Ctrl-N\": \"goLineDown\",\n        \"Ctrl-A\": \"goLineStart\",\n        \"Ctrl-E\": \"goLineEnd\",\n        \"Ctrl-V\": \"goPageDown\",\n        \"Shift-Ctrl-V\": \"goPageUp\",\n        \"Ctrl-D\": \"delCharAfter\",\n        \"Ctrl-H\": \"delCharBefore\",\n        \"Alt-Backspace\": \"delWordBefore\",\n        \"Ctrl-K\": \"killLine\",\n        \"Ctrl-T\": \"transposeChars\",\n        \"Ctrl-O\": \"openLine\"\n      }, ze.macDefault = {\n        \"Cmd-A\": \"selectAll\",\n        \"Cmd-D\": \"deleteLine\",\n        \"Cmd-Z\": \"undo\",\n        \"Shift-Cmd-Z\": \"redo\",\n        \"Cmd-Y\": \"redo\",\n        \"Cmd-Home\": \"goDocStart\",\n        \"Cmd-Up\": \"goDocStart\",\n        \"Cmd-End\": \"goDocEnd\",\n        \"Cmd-Down\": \"goDocEnd\",\n        \"Alt-Left\": \"goGroupLeft\",\n        \"Alt-Right\": \"goGroupRight\",\n        \"Cmd-Left\": \"goLineLeft\",\n        \"Cmd-Right\": \"goLineRight\",\n        \"Alt-Backspace\": \"delGroupBefore\",\n        \"Ctrl-Alt-Backspace\": \"delGroupAfter\",\n        \"Alt-Delete\": \"delGroupAfter\",\n        \"Cmd-S\": \"save\",\n        \"Cmd-F\": \"find\",\n        \"Cmd-G\": \"findNext\",\n        \"Shift-Cmd-G\": \"findPrev\",\n        \"Cmd-Alt-F\": \"replace\",\n        \"Shift-Cmd-Alt-F\": \"replaceAll\",\n        \"Cmd-[\": \"indentLess\",\n        \"Cmd-]\": \"indentMore\",\n        \"Cmd-Backspace\": \"delWrappedLineLeft\",\n        \"Cmd-Delete\": \"delWrappedLineRight\",\n        \"Cmd-U\": \"undoSelection\",\n        \"Shift-Cmd-U\": \"redoSelection\",\n        \"Ctrl-Up\": \"goDocStart\",\n        \"Ctrl-Down\": \"goDocEnd\",\n        fallthrough: [\"basic\", \"emacsy\"]\n      }, ze.default = me ? ze.macDefault : ze.pcDefault;\n      function Fs(e) {\n        var t = e.split(/-(?!$)/);\n        e = t[t.length - 1];\n        for (var i, r, n, l, o = 0; o < t.length - 1; o++) {\n          var a = t[o];\n          if (/^(cmd|meta|m)$/i.test(a))\n            l = !0;\n          else if (/^a(lt)?$/i.test(a))\n            i = !0;\n          else if (/^(c|ctrl|control)$/i.test(a))\n            r = !0;\n          else if (/^s(hift)?$/i.test(a))\n            n = !0;\n          else\n            throw new Error(\"Unrecognized modifier name: \" + a);\n        }\n        return i && (e = \"Alt-\" + e), r && (e = \"Ctrl-\" + e), l && (e = \"Cmd-\" + e), n && (e = \"Shift-\" + e), e;\n      }\n      u(Fs, \"normalizeKeyName\");\n      function Ps(e) {\n        var t = {};\n        for (var i in e)\n          if (e.hasOwnProperty(i)) {\n            var r = e[i];\n            if (/^(name|fallthrough|(de|at)tach)$/.test(i))\n              continue;\n            if (r == \"...\") {\n              delete e[i];\n              continue;\n            }\n            for (var n = Or(i.split(\" \"), Fs), l = 0; l < n.length; l++) {\n              var o = void 0, a = void 0;\n              l == n.length - 1 ? (a = n.join(\" \"), o = r) : (a = n.slice(0, l + 1).join(\" \"), o = \"...\");\n              var s = t[a];\n              if (!s)\n                t[a] = o;\n              else if (s != o)\n                throw new Error(\"Inconsistent bindings for \" + a);\n            }\n            delete e[i];\n          }\n        for (var f in t)\n          e[f] = t[f];\n        return e;\n      }\n      u(Ps, \"normalizeKeyMap\");\n      function Et(e, t, i, r) {\n        t = oi(t);\n        var n = t.call ? t.call(e, r) : t[e];\n        if (n === !1)\n          return \"nothing\";\n        if (n === \"...\")\n          return \"multi\";\n        if (n != null && i(n))\n          return \"handled\";\n        if (t.fallthrough) {\n          if (Object.prototype.toString.call(t.fallthrough) != \"[object Array]\")\n            return Et(e, t.fallthrough, i, r);\n          for (var l = 0; l < t.fallthrough.length; l++) {\n            var o = Et(e, t.fallthrough[l], i, r);\n            if (o)\n              return o;\n          }\n        }\n      }\n      u(Et, \"lookupKey\");\n      function xo(e) {\n        var t = typeof e == \"string\" ? e : Ve[e.keyCode];\n        return t == \"Ctrl\" || t == \"Alt\" || t == \"Shift\" || t == \"Mod\";\n      }\n      u(xo, \"isModifierKey\");\n      function Co(e, t, i) {\n        var r = e;\n        return t.altKey && r != \"Alt\" && (e = \"Alt-\" + e), (On ? t.metaKey : t.ctrlKey) && r != \"Ctrl\" && (e = \"Ctrl-\" + e), (On ? t.ctrlKey : t.metaKey) && r != \"Mod\" && (e = \"Cmd-\" + e), !i && t.shiftKey && r != \"Shift\" && (e = \"Shift-\" + e), e;\n      }\n      u(Co, \"addModifierNames\");\n      function wo(e, t) {\n        if (we && e.keyCode == 34 && e.char)\n          return !1;\n        var i = Ve[e.keyCode];\n        return i == null || e.altGraphKey ? !1 : (e.keyCode == 3 && e.code && (i = e.code), Co(i, e, t));\n      }\n      u(wo, \"keyName\");\n      function oi(e) {\n        return typeof e == \"string\" ? ze[e] : e;\n      }\n      u(oi, \"getKeyMap\");\n      function It(e, t) {\n        for (var i = e.doc.sel.ranges, r = [], n = 0; n < i.length; n++) {\n          for (var l = t(i[n]); r.length && D(l.from, H(r).to) <= 0; ) {\n            var o = r.pop();\n            if (D(o.from, l.from) < 0) {\n              l.from = o.from;\n              break;\n            }\n          }\n          r.push(l);\n        }\n        de(e, function() {\n          for (var a = r.length - 1; a >= 0; a--)\n            Ft(e.doc, \"\", r[a].from, r[a].to, \"+delete\");\n          Nt(e);\n        });\n      }\n      u(It, \"deleteNearSelection\");\n      function gn(e, t, i) {\n        var r = En(e.text, t + i, i);\n        return r < 0 || r > e.text.length ? null : r;\n      }\n      u(gn, \"moveCharLogically\");\n      function yn(e, t, i) {\n        var r = gn(e, t.ch, i);\n        return r == null ? null : new y(t.line, r, i < 0 ? \"after\" : \"before\");\n      }\n      u(yn, \"moveLogically\");\n      function mn(e, t, i, r, n) {\n        if (e) {\n          t.doc.direction == \"rtl\" && (n = -n);\n          var l = Pe(i, t.doc.direction);\n          if (l) {\n            var o = n < 0 ? H(l) : l[0], a = n < 0 == (o.level == 1), s = a ? \"after\" : \"before\", f;\n            if (o.level > 0 || t.doc.direction == \"rtl\") {\n              var h = kt(t, i);\n              f = n < 0 ? i.text.length - 1 : 0;\n              var c = Oe(t, h, f).top;\n              f = Yt(function(p) {\n                return Oe(t, h, p).top == c;\n              }, n < 0 == (o.level == 1) ? o.from : o.to - 1, f), s == \"before\" && (f = gn(i, f, 1));\n            } else\n              f = n < 0 ? o.to : o.from;\n            return new y(r, f, s);\n          }\n        }\n        return new y(r, n < 0 ? i.text.length : 0, n < 0 ? \"before\" : \"after\");\n      }\n      u(mn, \"endOfLine\");\n      function Es(e, t, i, r) {\n        var n = Pe(t, e.doc.direction);\n        if (!n)\n          return yn(t, i, r);\n        i.ch >= t.text.length ? (i.ch = t.text.length, i.sticky = \"before\") : i.ch <= 0 && (i.ch = 0, i.sticky = \"after\");\n        var l = Zt(n, i.ch, i.sticky), o = n[l];\n        if (e.doc.direction == \"ltr\" && o.level % 2 == 0 && (r > 0 ? o.to > i.ch : o.from < i.ch))\n          return yn(t, i, r);\n        var a = /* @__PURE__ */ u(function(b, C) {\n          return gn(t, b instanceof y ? b.ch : b, C);\n        }, \"mv\"), s, f = /* @__PURE__ */ u(function(b) {\n          return e.options.lineWrapping ? (s = s || kt(e, t), Tl(e, t, s, b)) : { begin: 0, end: t.text.length };\n        }, \"getWrappedLineExtent\"), h = f(i.sticky == \"before\" ? a(i, -1) : i.ch);\n        if (e.doc.direction == \"rtl\" || o.level == 1) {\n          var c = o.level == 1 == r < 0, p = a(i, c ? 1 : -1);\n          if (p != null && (c ? p <= o.to && p <= h.end : p >= o.from && p >= h.begin)) {\n            var d = c ? \"before\" : \"after\";\n            return new y(i.line, p, d);\n          }\n        }\n        var v = /* @__PURE__ */ u(function(b, C, x) {\n          for (var w = /* @__PURE__ */ u(function(E, j) {\n            return j ? new y(i.line, a(E, 1), \"before\") : new y(i.line, E, \"after\");\n          }, \"getRes\"); b >= 0 && b < n.length; b += C) {\n            var k = n[b], L = C > 0 == (k.level != 1), A = L ? x.begin : a(x.end, -1);\n            if (k.from <= A && A < k.to || (A = L ? k.from : a(k.to, -1), x.begin <= A && A < x.end))\n              return w(A, L);\n          }\n        }, \"searchInVisualLine\"), g = v(l + r, r, h);\n        if (g)\n          return g;\n        var m = r > 0 ? h.end : a(h.begin, -1);\n        return m != null && !(r > 0 && m == t.text.length) && (g = v(r > 0 ? 0 : n.length - 1, r, f(m)), g) ? g : null;\n      }\n      u(Es, \"moveVisually\");\n      var br = {\n        selectAll: lo,\n        singleSelection: function(e) {\n          return e.setSelection(e.getCursor(\"anchor\"), e.getCursor(\"head\"), Me);\n        },\n        killLine: function(e) {\n          return It(e, function(t) {\n            if (t.empty()) {\n              var i = S(e.doc, t.head.line).text.length;\n              return t.head.ch == i && t.head.line < e.lastLine() ? { from: t.head, to: y(t.head.line + 1, 0) } : { from: t.head, to: y(t.head.line, i) };\n            } else\n              return { from: t.from(), to: t.to() };\n          });\n        },\n        deleteLine: function(e) {\n          return It(e, function(t) {\n            return {\n              from: y(t.from().line, 0),\n              to: N(e.doc, y(t.to().line + 1, 0))\n            };\n          });\n        },\n        delLineLeft: function(e) {\n          return It(e, function(t) {\n            return {\n              from: y(t.from().line, 0),\n              to: t.from()\n            };\n          });\n        },\n        delWrappedLineLeft: function(e) {\n          return It(e, function(t) {\n            var i = e.charCoords(t.head, \"div\").top + 5, r = e.coordsChar({ left: 0, top: i }, \"div\");\n            return { from: r, to: t.from() };\n          });\n        },\n        delWrappedLineRight: function(e) {\n          return It(e, function(t) {\n            var i = e.charCoords(t.head, \"div\").top + 5, r = e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: i }, \"div\");\n            return { from: t.from(), to: r };\n          });\n        },\n        undo: function(e) {\n          return e.undo();\n        },\n        redo: function(e) {\n          return e.redo();\n        },\n        undoSelection: function(e) {\n          return e.undoSelection();\n        },\n        redoSelection: function(e) {\n          return e.redoSelection();\n        },\n        goDocStart: function(e) {\n          return e.extendSelection(y(e.firstLine(), 0));\n        },\n        goDocEnd: function(e) {\n          return e.extendSelection(y(e.lastLine()));\n        },\n        goLineStart: function(e) {\n          return e.extendSelectionsBy(\n            function(t) {\n              return So(e, t.head.line);\n            },\n            { origin: \"+move\", bias: 1 }\n          );\n        },\n        goLineStartSmart: function(e) {\n          return e.extendSelectionsBy(\n            function(t) {\n              return Lo(e, t.head);\n            },\n            { origin: \"+move\", bias: 1 }\n          );\n        },\n        goLineEnd: function(e) {\n          return e.extendSelectionsBy(\n            function(t) {\n              return Is(e, t.head.line);\n            },\n            { origin: \"+move\", bias: -1 }\n          );\n        },\n        goLineRight: function(e) {\n          return e.extendSelectionsBy(function(t) {\n            var i = e.cursorCoords(t.head, \"div\").top + 5;\n            return e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: i }, \"div\");\n          }, Xt);\n        },\n        goLineLeft: function(e) {\n          return e.extendSelectionsBy(function(t) {\n            var i = e.cursorCoords(t.head, \"div\").top + 5;\n            return e.coordsChar({ left: 0, top: i }, \"div\");\n          }, Xt);\n        },\n        goLineLeftSmart: function(e) {\n          return e.extendSelectionsBy(function(t) {\n            var i = e.cursorCoords(t.head, \"div\").top + 5, r = e.coordsChar({ left: 0, top: i }, \"div\");\n            return r.ch < e.getLine(r.line).search(/\\S/) ? Lo(e, t.head) : r;\n          }, Xt);\n        },\n        goLineUp: function(e) {\n          return e.moveV(-1, \"line\");\n        },\n        goLineDown: function(e) {\n          return e.moveV(1, \"line\");\n        },\n        goPageUp: function(e) {\n          return e.moveV(-1, \"page\");\n        },\n        goPageDown: function(e) {\n          return e.moveV(1, \"page\");\n        },\n        goCharLeft: function(e) {\n          return e.moveH(-1, \"char\");\n        },\n        goCharRight: function(e) {\n          return e.moveH(1, \"char\");\n        },\n        goColumnLeft: function(e) {\n          return e.moveH(-1, \"column\");\n        },\n        goColumnRight: function(e) {\n          return e.moveH(1, \"column\");\n        },\n        goWordLeft: function(e) {\n          return e.moveH(-1, \"word\");\n        },\n        goGroupRight: function(e) {\n          return e.moveH(1, \"group\");\n        },\n        goGroupLeft: function(e) {\n          return e.moveH(-1, \"group\");\n        },\n        goWordRight: function(e) {\n          return e.moveH(1, \"word\");\n        },\n        delCharBefore: function(e) {\n          return e.deleteH(-1, \"codepoint\");\n        },\n        delCharAfter: function(e) {\n          return e.deleteH(1, \"char\");\n        },\n        delWordBefore: function(e) {\n          return e.deleteH(-1, \"word\");\n        },\n        delWordAfter: function(e) {\n          return e.deleteH(1, \"word\");\n        },\n        delGroupBefore: function(e) {\n          return e.deleteH(-1, \"group\");\n        },\n        delGroupAfter: function(e) {\n          return e.deleteH(1, \"group\");\n        },\n        indentAuto: function(e) {\n          return e.indentSelection(\"smart\");\n        },\n        indentMore: function(e) {\n          return e.indentSelection(\"add\");\n        },\n        indentLess: function(e) {\n          return e.indentSelection(\"subtract\");\n        },\n        insertTab: function(e) {\n          return e.replaceSelection(\"\t\");\n        },\n        insertSoftTab: function(e) {\n          for (var t = [], i = e.listSelections(), r = e.options.tabSize, n = 0; n < i.length; n++) {\n            var l = i[n].from(), o = xe(e.getLine(l.line), l.ch, r);\n            t.push(yi(r - o % r));\n          }\n          e.replaceSelections(t);\n        },\n        defaultTab: function(e) {\n          e.somethingSelected() ? e.indentSelection(\"add\") : e.execCommand(\"insertTab\");\n        },\n        // Swap the two chars left and right of each selection's head.\n        // Move cursor behind the two swapped characters afterwards.\n        //\n        // Doesn't consider line feeds a character.\n        // Doesn't scan more than one line above to find a character.\n        // Doesn't do anything on an empty line.\n        // Doesn't do anything with non-empty selections.\n        transposeChars: function(e) {\n          return de(e, function() {\n            for (var t = e.listSelections(), i = [], r = 0; r < t.length; r++)\n              if (t[r].empty()) {\n                var n = t[r].head, l = S(e.doc, n.line).text;\n                if (l) {\n                  if (n.ch == l.length && (n = new y(n.line, n.ch - 1)), n.ch > 0)\n                    n = new y(n.line, n.ch + 1), e.replaceRange(\n                      l.charAt(n.ch - 1) + l.charAt(n.ch - 2),\n                      y(n.line, n.ch - 2),\n                      n,\n                      \"+transpose\"\n                    );\n                  else if (n.line > e.doc.first) {\n                    var o = S(e.doc, n.line - 1).text;\n                    o && (n = new y(n.line, 1), e.replaceRange(\n                      l.charAt(0) + e.doc.lineSeparator() + o.charAt(o.length - 1),\n                      y(n.line - 1, o.length - 1),\n                      n,\n                      \"+transpose\"\n                    ));\n                  }\n                }\n                i.push(new W(n, n));\n              }\n            e.setSelections(i);\n          });\n        },\n        newlineAndIndent: function(e) {\n          return de(e, function() {\n            for (var t = e.listSelections(), i = t.length - 1; i >= 0; i--)\n              e.replaceRange(e.doc.lineSeparator(), t[i].anchor, t[i].head, \"+input\");\n            t = e.listSelections();\n            for (var r = 0; r < t.length; r++)\n              e.indentLine(t[r].from().line, null, !0);\n            Nt(e);\n          });\n        },\n        openLine: function(e) {\n          return e.replaceSelection(`\n`, \"start\");\n        },\n        toggleOverwrite: function(e) {\n          return e.toggleOverwrite();\n        }\n      };\n      function So(e, t) {\n        var i = S(e.doc, t), r = Se(i);\n        return r != i && (t = F(r)), mn(!0, e, r, t, 1);\n      }\n      u(So, \"lineStart\");\n      function Is(e, t) {\n        var i = S(e.doc, t), r = xa(i);\n        return r != i && (t = F(r)), mn(!0, e, i, t, -1);\n      }\n      u(Is, \"lineEnd\");\n      function Lo(e, t) {\n        var i = So(e, t.line), r = S(e.doc, i.line), n = Pe(r, e.doc.direction);\n        if (!n || n[0].level == 0) {\n          var l = Math.max(i.ch, r.text.search(/\\S/)), o = t.line == i.line && t.ch <= l && t.ch;\n          return y(i.line, o ? 0 : l, i.sticky);\n        }\n        return i;\n      }\n      u(Lo, \"lineStartSmart\");\n      function ai(e, t, i) {\n        if (typeof t == \"string\" && (t = br[t], !t))\n          return !1;\n        e.display.input.ensurePolled();\n        var r = e.display.shift, n = !1;\n        try {\n          e.isReadOnly() && (e.state.suppressEdits = !0), i && (e.display.shift = !1), n = t(e) != Nr;\n        } finally {\n          e.display.shift = r, e.state.suppressEdits = !1;\n        }\n        return n;\n      }\n      u(ai, \"doHandleBinding\");\n      function Rs(e, t, i) {\n        for (var r = 0; r < e.state.keyMaps.length; r++) {\n          var n = Et(t, e.state.keyMaps[r], i, e);\n          if (n)\n            return n;\n        }\n        return e.options.extraKeys && Et(t, e.options.extraKeys, i, e) || Et(t, e.options.keyMap, i, e);\n      }\n      u(Rs, \"lookupKeyForEditor\");\n      var Bs = new _e();\n      function xr(e, t, i, r) {\n        var n = e.state.keySeq;\n        if (n) {\n          if (xo(t))\n            return \"handled\";\n          if (/\\'$/.test(t) ? e.state.keySeq = null : Bs.set(50, function() {\n            e.state.keySeq == n && (e.state.keySeq = null, e.display.input.reset());\n          }), ko(e, n + \" \" + t, i, r))\n            return !0;\n        }\n        return ko(e, t, i, r);\n      }\n      u(xr, \"dispatchKey\");\n      function ko(e, t, i, r) {\n        var n = Rs(e, t, r);\n        return n == \"multi\" && (e.state.keySeq = t), n == \"handled\" && Z(e, \"keyHandled\", e, t, i), (n == \"handled\" || n == \"multi\") && (ae(i), $i(e)), !!n;\n      }\n      u(ko, \"dispatchKeyInner\");\n      function To(e, t) {\n        var i = wo(t, !0);\n        return i ? t.shiftKey && !e.state.keySeq ? xr(e, \"Shift-\" + i, t, function(r) {\n          return ai(e, r, !0);\n        }) || xr(e, i, t, function(r) {\n          if (typeof r == \"string\" ? /^go[A-Z]/.test(r) : r.motion)\n            return ai(e, r);\n        }) : xr(e, i, t, function(r) {\n          return ai(e, r);\n        }) : !1;\n      }\n      u(To, \"handleKeyBinding\");\n      function zs(e, t, i) {\n        return xr(e, \"'\" + i + \"'\", t, function(r) {\n          return ai(e, r, !0);\n        });\n      }\n      u(zs, \"handleCharBinding\");\n      var bn = null;\n      function Mo(e) {\n        var t = this;\n        if (!(e.target && e.target != t.display.input.getField()) && (t.curOp.focus = be(), !q(t, e))) {\n          O && I < 11 && e.keyCode == 27 && (e.returnValue = !1);\n          var i = e.keyCode;\n          t.display.shift = i == 16 || e.shiftKey;\n          var r = To(t, e);\n          we && (bn = r ? i : null, !r && i == 88 && !na && (me ? e.metaKey : e.ctrlKey) && t.replaceSelection(\"\", null, \"cut\")), Fe && !me && !r && i == 46 && e.shiftKey && !e.ctrlKey && document.execCommand && document.execCommand(\"cut\"), i == 18 && !/\\bCodeMirror-crosshair\\b/.test(t.display.lineDiv.className) && Gs(t);\n        }\n      }\n      u(Mo, \"onKeyDown\");\n      function Gs(e) {\n        var t = e.display.lineDiv;\n        it(t, \"CodeMirror-crosshair\");\n        function i(r) {\n          (r.keyCode == 18 || !r.altKey) && (tt(t, \"CodeMirror-crosshair\"), ge(document, \"keyup\", i), ge(document, \"mouseover\", i));\n        }\n        u(i, \"up\"), M(document, \"keyup\", i), M(document, \"mouseover\", i);\n      }\n      u(Gs, \"showCrossHair\");\n      function Do(e) {\n        e.keyCode == 16 && (this.doc.sel.shift = !1), q(this, e);\n      }\n      u(Do, \"onKeyUp\");\n      function No(e) {\n        var t = this;\n        if (!(e.target && e.target != t.display.input.getField()) && !(Re(t.display, e) || q(t, e) || e.ctrlKey && !e.altKey || me && e.metaKey)) {\n          var i = e.keyCode, r = e.charCode;\n          if (we && i == bn) {\n            bn = null, ae(e);\n            return;\n          }\n          if (!(we && (!e.which || e.which < 10) && To(t, e))) {\n            var n = String.fromCharCode(r ?? i);\n            n != \"\\b\" && (zs(t, e, n) || t.display.input.onKeyPress(e));\n          }\n        }\n      }\n      u(No, \"onKeyPress\");\n      var Us = 400, xn = /* @__PURE__ */ u(function(e, t, i) {\n        this.time = e, this.pos = t, this.button = i;\n      }, \"PastClick\");\n      xn.prototype.compare = function(e, t, i) {\n        return this.time + Us > e && D(t, this.pos) == 0 && i == this.button;\n      };\n      var Cr, wr;\n      function Ks(e, t) {\n        var i = +/* @__PURE__ */ new Date();\n        return wr && wr.compare(i, e, t) ? (Cr = wr = null, \"triple\") : Cr && Cr.compare(i, e, t) ? (wr = new xn(i, e, t), Cr = null, \"double\") : (Cr = new xn(i, e, t), wr = null, \"single\");\n      }\n      u(Ks, \"clickRepeat\");\n      function Ao(e) {\n        var t = this, i = t.display;\n        if (!(q(t, e) || i.activeTouch && i.input.supportsTouch())) {\n          if (i.input.ensurePolled(), i.shift = e.shiftKey, Re(i, e)) {\n            ne || (i.scroller.draggable = !1, setTimeout(function() {\n              return i.scroller.draggable = !0;\n            }, 100));\n            return;\n          }\n          if (!Cn(t, e)) {\n            var r = ft(t, e), n = zn(e), l = r ? Ks(r, n) : \"single\";\n            window.focus(), n == 1 && t.state.selectingText && t.state.selectingText(e), !(r && _s(t, n, r, l, e)) && (n == 1 ? r ? Ys(t, r, l, e) : wi(e) == i.scroller && ae(e) : n == 2 ? (r && ti(t.doc, r), setTimeout(function() {\n              return i.input.focus();\n            }, 20)) : n == 3 && (ci ? t.display.input.onContextMenu(e) : en(t)));\n          }\n        }\n      }\n      u(Ao, \"onMouseDown\");\n      function _s(e, t, i, r, n) {\n        var l = \"Click\";\n        return r == \"double\" ? l = \"Double\" + l : r == \"triple\" && (l = \"Triple\" + l), l = (t == 1 ? \"Left\" : t == 2 ? \"Middle\" : \"Right\") + l, xr(e, Co(l, n), n, function(o) {\n          if (typeof o == \"string\" && (o = br[o]), !o)\n            return !1;\n          var a = !1;\n          try {\n            e.isReadOnly() && (e.state.suppressEdits = !0), a = o(e, i) != Nr;\n          } finally {\n            e.state.suppressEdits = !1;\n          }\n          return a;\n        });\n      }\n      u(_s, \"handleMappedButton\");\n      function Xs(e, t, i) {\n        var r = e.getOption(\"configureMouse\"), n = r ? r(e, t, i) : {};\n        if (n.unit == null) {\n          var l = qo ? i.shiftKey && i.metaKey : i.altKey;\n          n.unit = l ? \"rectangle\" : t == \"single\" ? \"char\" : t == \"double\" ? \"word\" : \"line\";\n        }\n        return (n.extend == null || e.doc.extend) && (n.extend = e.doc.extend || i.shiftKey), n.addNew == null && (n.addNew = me ? i.metaKey : i.ctrlKey), n.moveOnDrag == null && (n.moveOnDrag = !(me ? i.altKey : i.ctrlKey)), n;\n      }\n      u(Xs, \"configureMouse\");\n      function Ys(e, t, i, r) {\n        O ? setTimeout(pi(Al, e), 0) : e.curOp.focus = be();\n        var n = Xs(e, i, r), l = e.doc.sel, o;\n        e.options.dragDrop && ea && !e.isReadOnly() && i == \"single\" && (o = l.contains(t)) > -1 && (D((o = l.ranges[o]).from(), t) < 0 || t.xRel > 0) && (D(o.to(), t) > 0 || t.xRel < 0) ? qs(e, r, t, n) : Zs(e, r, t, n);\n      }\n      u(Ys, \"leftButtonDown\");\n      function qs(e, t, i, r) {\n        var n = e.display, l = !1, o = Q(e, function(f) {\n          ne && (n.scroller.draggable = !1), e.state.draggingText = !1, e.state.delayingBlurEvent && (e.hasFocus() ? e.state.delayingBlurEvent = !1 : en(e)), ge(n.wrapper.ownerDocument, \"mouseup\", o), ge(n.wrapper.ownerDocument, \"mousemove\", a), ge(n.scroller, \"dragstart\", s), ge(n.scroller, \"drop\", o), l || (ae(f), r.addNew || ti(e.doc, i, null, null, r.extend), ne && !Mr || O && I == 9 ? setTimeout(function() {\n            n.wrapper.ownerDocument.body.focus({ preventScroll: !0 }), n.input.focus();\n          }, 20) : n.input.focus());\n        }), a = /* @__PURE__ */ u(function(f) {\n          l = l || Math.abs(t.clientX - f.clientX) + Math.abs(t.clientY - f.clientY) >= 10;\n        }, \"mouseMove\"), s = /* @__PURE__ */ u(function() {\n          return l = !0;\n        }, \"dragStart\");\n        ne && (n.scroller.draggable = !0), e.state.draggingText = o, o.copy = !r.moveOnDrag, M(n.wrapper.ownerDocument, \"mouseup\", o), M(n.wrapper.ownerDocument, \"mousemove\", a), M(n.scroller, \"dragstart\", s), M(n.scroller, \"drop\", o), e.state.delayingBlurEvent = !0, setTimeout(function() {\n          return n.input.focus();\n        }, 20), n.scroller.dragDrop && n.scroller.dragDrop();\n      }\n      u(qs, \"leftButtonStartDrag\");\n      function Oo(e, t, i) {\n        if (i == \"char\")\n          return new W(t, t);\n        if (i == \"word\")\n          return e.findWordAt(t);\n        if (i == \"line\")\n          return new W(y(t.line, 0), N(e.doc, y(t.line + 1, 0)));\n        var r = i(e, t);\n        return new W(r.from, r.to);\n      }\n      u(Oo, \"rangeForUnit\");\n      function Zs(e, t, i, r) {\n        O && en(e);\n        var n = e.display, l = e.doc;\n        ae(t);\n        var o, a, s = l.sel, f = s.ranges;\n        if (r.addNew && !r.extend ? (a = l.sel.contains(i), a > -1 ? o = f[a] : o = new W(i, i)) : (o = l.sel.primary(), a = l.sel.primIndex), r.unit == \"rectangle\")\n          r.addNew || (o = new W(i, i)), i = ft(e, t, !0, !0), a = -1;\n        else {\n          var h = Oo(e, i, r.unit);\n          r.extend ? o = pn(o, h.anchor, h.head, r.extend) : o = h;\n        }\n        r.addNew ? a == -1 ? (a = f.length, te(\n          l,\n          ke(e, f.concat([o]), a),\n          { scroll: !1, origin: \"*mouse\" }\n        )) : f.length > 1 && f[a].empty() && r.unit == \"char\" && !r.extend ? (te(\n          l,\n          ke(e, f.slice(0, a).concat(f.slice(a + 1)), 0),\n          { scroll: !1, origin: \"*mouse\" }\n        ), s = l.sel) : vn(l, a, o, vi) : (a = 0, te(l, new ye([o], 0), vi), s = l.sel);\n        var c = i;\n        function p(x) {\n          if (D(c, x) != 0)\n            if (c = x, r.unit == \"rectangle\") {\n              for (var w = [], k = e.options.tabSize, L = xe(S(l, i.line).text, i.ch, k), A = xe(S(l, x.line).text, x.ch, k), E = Math.min(L, A), j = Math.max(L, A), B = Math.min(i.line, x.line), pe = Math.min(e.lastLine(), Math.max(i.line, x.line)); B <= pe; B++) {\n                var fe = S(l, B).text, _ = gi(fe, E, k);\n                E == j ? w.push(new W(y(B, _), y(B, _))) : fe.length > _ && w.push(new W(y(B, _), y(B, gi(fe, j, k))));\n              }\n              w.length || w.push(new W(i, i)), te(\n                l,\n                ke(e, s.ranges.slice(0, a).concat(w), a),\n                { origin: \"*mouse\", scroll: !1 }\n              ), e.scrollIntoView(x);\n            } else {\n              var he = o, $ = Oo(e, x, r.unit), Y = he.anchor, X;\n              D($.anchor, Y) > 0 ? (X = $.head, Y = Pr(he.from(), $.anchor)) : (X = $.anchor, Y = Fr(he.to(), $.head));\n              var z = s.ranges.slice(0);\n              z[a] = Qs(e, new W(N(l, Y), X)), te(l, ke(e, z, a), vi);\n            }\n        }\n        u(p, \"extendTo\");\n        var d = n.wrapper.getBoundingClientRect(), v = 0;\n        function g(x) {\n          var w = ++v, k = ft(e, x, !0, r.unit == \"rectangle\");\n          if (k)\n            if (D(k, c) != 0) {\n              e.curOp.focus = be(), p(k);\n              var L = Qr(n, l);\n              (k.line >= L.to || k.line < L.from) && setTimeout(Q(e, function() {\n                v == w && g(x);\n              }), 150);\n            } else {\n              var A = x.clientY < d.top ? -20 : x.clientY > d.bottom ? 20 : 0;\n              A && setTimeout(Q(e, function() {\n                v == w && (n.scroller.scrollTop += A, g(x));\n              }), 50);\n            }\n        }\n        u(g, \"extend\");\n        function m(x) {\n          e.state.selectingText = !1, v = 1 / 0, x && (ae(x), n.input.focus()), ge(n.wrapper.ownerDocument, \"mousemove\", b), ge(n.wrapper.ownerDocument, \"mouseup\", C), l.history.lastSelOrigin = null;\n        }\n        u(m, \"done\");\n        var b = Q(e, function(x) {\n          x.buttons === 0 || !zn(x) ? m(x) : g(x);\n        }), C = Q(e, m);\n        e.state.selectingText = C, M(n.wrapper.ownerDocument, \"mousemove\", b), M(n.wrapper.ownerDocument, \"mouseup\", C);\n      }\n      u(Zs, \"leftButtonSelect\");\n      function Qs(e, t) {\n        var i = t.anchor, r = t.head, n = S(e.doc, i.line);\n        if (D(i, r) == 0 && i.sticky == r.sticky)\n          return t;\n        var l = Pe(n);\n        if (!l)\n          return t;\n        var o = Zt(l, i.ch, i.sticky), a = l[o];\n        if (a.from != i.ch && a.to != i.ch)\n          return t;\n        var s = o + (a.from == i.ch == (a.level != 1) ? 0 : 1);\n        if (s == 0 || s == l.length)\n          return t;\n        var f;\n        if (r.line != i.line)\n          f = (r.line - i.line) * (e.doc.direction == \"ltr\" ? 1 : -1) > 0;\n        else {\n          var h = Zt(l, r.ch, r.sticky), c = h - o || (r.ch - i.ch) * (a.level == 1 ? -1 : 1);\n          h == s - 1 || h == s ? f = c < 0 : f = c > 0;\n        }\n        var p = l[s + (f ? -1 : 0)], d = f == (p.level == 1), v = d ? p.from : p.to, g = d ? \"after\" : \"before\";\n        return i.ch == v && i.sticky == g ? t : new W(new y(i.line, v, g), r);\n      }\n      u(Qs, \"bidiSimplify\");\n      function Wo(e, t, i, r) {\n        var n, l;\n        if (t.touches)\n          n = t.touches[0].clientX, l = t.touches[0].clientY;\n        else\n          try {\n            n = t.clientX, l = t.clientY;\n          } catch {\n            return !1;\n          }\n        if (n >= Math.floor(e.display.gutters.getBoundingClientRect().right))\n          return !1;\n        r && ae(t);\n        var o = e.display, a = o.lineDiv.getBoundingClientRect();\n        if (l > a.bottom || !Ce(e, i))\n          return Ci(t);\n        l -= a.top - o.viewOffset;\n        for (var s = 0; s < e.display.gutterSpecs.length; ++s) {\n          var f = o.gutters.childNodes[s];\n          if (f && f.getBoundingClientRect().right >= n) {\n            var h = at(e.doc, l), c = e.display.gutterSpecs[s];\n            return U(e, i, e, h, c.className, t), Ci(t);\n          }\n        }\n      }\n      u(Wo, \"gutterEvent\");\n      function Cn(e, t) {\n        return Wo(e, t, \"gutterClick\", !0);\n      }\n      u(Cn, \"clickInGutter\");\n      function Ho(e, t) {\n        Re(e.display, t) || Js(e, t) || q(e, t, \"contextmenu\") || ci || e.display.input.onContextMenu(t);\n      }\n      u(Ho, \"onContextMenu\");\n      function Js(e, t) {\n        return Ce(e, \"gutterContextMenu\") ? Wo(e, t, \"gutterContextMenu\", !1) : !1;\n      }\n      u(Js, \"contextMenuInGutter\");\n      function Fo(e) {\n        e.display.wrapper.className = e.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") + e.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\"), rr(e);\n      }\n      u(Fo, \"themeChanged\");\n      var Rt = { toString: function() {\n        return \"CodeMirror.Init\";\n      } }, Po = {}, si = {};\n      function js(e) {\n        var t = e.optionHandlers;\n        function i(r, n, l, o) {\n          e.defaults[r] = n, l && (t[r] = o ? function(a, s, f) {\n            f != Rt && l(a, s, f);\n          } : l);\n        }\n        u(i, \"option\"), e.defineOption = i, e.Init = Rt, i(\"value\", \"\", function(r, n) {\n          return r.setValue(n);\n        }, !0), i(\"mode\", null, function(r, n) {\n          r.doc.modeOption = n, hn(r);\n        }, !0), i(\"indentUnit\", 2, hn, !0), i(\"indentWithTabs\", !1), i(\"smartIndent\", !0), i(\"tabSize\", 4, function(r) {\n          fr(r), rr(r), se(r);\n        }, !0), i(\"lineSeparator\", null, function(r, n) {\n          if (r.doc.lineSep = n, !!n) {\n            var l = [], o = r.doc.first;\n            r.doc.iter(function(s) {\n              for (var f = 0; ; ) {\n                var h = s.text.indexOf(n, f);\n                if (h == -1)\n                  break;\n                f = h + n.length, l.push(y(o, h));\n              }\n              o++;\n            });\n            for (var a = l.length - 1; a >= 0; a--)\n              Ft(r.doc, n, l[a], y(l[a].line, l[a].ch + n.length));\n          }\n        }), i(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function(r, n, l) {\n          r.state.specialChars = new RegExp(n.source + (n.test(\"\t\") ? \"\" : \"|\t\"), \"g\"), l != Rt && r.refresh();\n        }), i(\"specialCharPlaceholder\", Ta, function(r) {\n          return r.refresh();\n        }, !0), i(\"electricChars\", !0), i(\"inputStyle\", Kt ? \"contenteditable\" : \"textarea\", function() {\n          throw new Error(\"inputStyle can not (yet) be changed in a running editor\");\n        }, !0), i(\"spellcheck\", !1, function(r, n) {\n          return r.getInputField().spellcheck = n;\n        }, !0), i(\"autocorrect\", !1, function(r, n) {\n          return r.getInputField().autocorrect = n;\n        }, !0), i(\"autocapitalize\", !1, function(r, n) {\n          return r.getInputField().autocapitalize = n;\n        }, !0), i(\"rtlMoveVisually\", !Zo), i(\"wholeLineUpdateBefore\", !0), i(\"theme\", \"default\", function(r) {\n          Fo(r), ur(r);\n        }, !0), i(\"keyMap\", \"default\", function(r, n, l) {\n          var o = oi(n), a = l != Rt && oi(l);\n          a && a.detach && a.detach(r, o), o.attach && o.attach(r, a || null);\n        }), i(\"extraKeys\", null), i(\"configureMouse\", null), i(\"lineWrapping\", !1, $s, !0), i(\"gutters\", [], function(r, n) {\n          r.display.gutterSpecs = un(n, r.options.lineNumbers), ur(r);\n        }, !0), i(\"fixedGutter\", !0, function(r, n) {\n          r.display.gutters.style.left = n ? Ji(r.display) + \"px\" : \"0\", r.refresh();\n        }, !0), i(\"coverGutterNextToScrollbar\", !1, function(r) {\n          return At(r);\n        }, !0), i(\"scrollbarStyle\", \"native\", function(r) {\n          El(r), At(r), r.display.scrollbars.setScrollTop(r.doc.scrollTop), r.display.scrollbars.setScrollLeft(r.doc.scrollLeft);\n        }, !0), i(\"lineNumbers\", !1, function(r, n) {\n          r.display.gutterSpecs = un(r.options.gutters, n), ur(r);\n        }, !0), i(\"firstLineNumber\", 1, ur, !0), i(\"lineNumberFormatter\", function(r) {\n          return r;\n        }, ur, !0), i(\"showCursorWhenSelecting\", !1, ir, !0), i(\"resetSelectionOnContextMenu\", !0), i(\"lineWiseCopyCut\", !0), i(\"pasteLinesPerSelection\", !0), i(\"selectionsMayTouch\", !1), i(\"readOnly\", !1, function(r, n) {\n          n == \"nocursor\" && (Dt(r), r.display.input.blur()), r.display.input.readOnlyChanged(n);\n        }), i(\"screenReaderLabel\", null, function(r, n) {\n          n = n === \"\" ? null : n, r.display.input.screenReaderLabelChanged(n);\n        }), i(\"disableInput\", !1, function(r, n) {\n          n || r.display.input.reset();\n        }, !0), i(\"dragDrop\", !0, Vs), i(\"allowDropFileTypes\", null), i(\"cursorBlinkRate\", 530), i(\"cursorScrollMargin\", 0), i(\"cursorHeight\", 1, ir, !0), i(\"singleCursorHeightPerLine\", !0, ir, !0), i(\"workTime\", 100), i(\"workDelay\", 100), i(\"flattenSpans\", !0, fr, !0), i(\"addModeClass\", !1, fr, !0), i(\"pollInterval\", 100), i(\"undoDepth\", 200, function(r, n) {\n          return r.doc.history.undoDepth = n;\n        }), i(\"historyEventDelay\", 1250), i(\"viewportMargin\", 10, function(r) {\n          return r.refresh();\n        }, !0), i(\"maxHighlightLength\", 1e4, fr, !0), i(\"moveInputWithCursor\", !0, function(r, n) {\n          n || r.display.input.resetPosition();\n        }), i(\"tabindex\", null, function(r, n) {\n          return r.display.input.getField().tabIndex = n || \"\";\n        }), i(\"autofocus\", null), i(\"direction\", \"ltr\", function(r, n) {\n          return r.doc.setDirection(n);\n        }, !0), i(\"phrases\", null);\n      }\n      u(js, \"defineOptions\");\n      function Vs(e, t, i) {\n        var r = i && i != Rt;\n        if (!t != !r) {\n          var n = e.display.dragFunctions, l = t ? M : ge;\n          l(e.display.scroller, \"dragstart\", n.start), l(e.display.scroller, \"dragenter\", n.enter), l(e.display.scroller, \"dragover\", n.over), l(e.display.scroller, \"dragleave\", n.leave), l(e.display.scroller, \"drop\", n.drop);\n        }\n      }\n      u(Vs, \"dragDropChanged\");\n      function $s(e) {\n        e.options.lineWrapping ? (it(e.display.wrapper, \"CodeMirror-wrap\"), e.display.sizer.style.minWidth = \"\", e.display.sizerWidth = null) : (tt(e.display.wrapper, \"CodeMirror-wrap\"), zi(e)), ji(e), se(e), rr(e), setTimeout(function() {\n          return At(e);\n        }, 100);\n      }\n      u($s, \"wrappingChanged\");\n      function R(e, t) {\n        var i = this;\n        if (!(this instanceof R))\n          return new R(e, t);\n        this.options = t = t ? nt(t) : {}, nt(Po, t, !1);\n        var r = t.value;\n        typeof r == \"string\" ? r = new ue(r, t.mode, null, t.lineSeparator, t.direction) : t.mode && (r.modeOption = t.mode), this.doc = r;\n        var n = new R.inputStyles[t.inputStyle](this), l = this.display = new cs(e, r, n, t);\n        l.wrapper.CodeMirror = this, Fo(this), t.lineWrapping && (this.display.wrapper.className += \" CodeMirror-wrap\"), El(this), this.state = {\n          keyMaps: [],\n          // stores maps added by addKeyMap\n          overlays: [],\n          // highlighting overlays, as added by addOverlay\n          modeGen: 0,\n          // bumped when mode/overlay changes, used to invalidate highlighting info\n          overwrite: !1,\n          delayingBlurEvent: !1,\n          focused: !1,\n          suppressEdits: !1,\n          // used to disable editing during key handlers when in readOnly mode\n          pasteIncoming: -1,\n          cutIncoming: -1,\n          // help recognize paste/cut edits in input.poll\n          selectingText: !1,\n          draggingText: !1,\n          highlight: new _e(),\n          // stores highlight worker timeout\n          keySeq: null,\n          // Unfinished key sequence\n          specialChars: null\n        }, t.autofocus && !Kt && l.input.focus(), O && I < 11 && setTimeout(function() {\n          return i.display.input.reset(!0);\n        }, 20), eu(this), Os(), pt(this), this.curOp.forceUpdate = !0, Yl(this, r), t.autofocus && !Kt || this.hasFocus() ? setTimeout(function() {\n          i.hasFocus() && !i.state.focused && tn(i);\n        }, 20) : Dt(this);\n        for (var o in si)\n          si.hasOwnProperty(o) && si[o](this, t[o], Rt);\n        Bl(this), t.finishInit && t.finishInit(this);\n        for (var a = 0; a < wn.length; ++a)\n          wn[a](this);\n        vt(this), ne && t.lineWrapping && getComputedStyle(l.lineDiv).textRendering == \"optimizelegibility\" && (l.lineDiv.style.textRendering = \"auto\");\n      }\n      u(R, \"CodeMirror\"), R.defaults = Po, R.optionHandlers = si;\n      function eu(e) {\n        var t = e.display;\n        M(t.scroller, \"mousedown\", Q(e, Ao)), O && I < 11 ? M(t.scroller, \"dblclick\", Q(e, function(s) {\n          if (!q(e, s)) {\n            var f = ft(e, s);\n            if (!(!f || Cn(e, s) || Re(e.display, s))) {\n              ae(s);\n              var h = e.findWordAt(f);\n              ti(e.doc, h.anchor, h.head);\n            }\n          }\n        })) : M(t.scroller, \"dblclick\", function(s) {\n          return q(e, s) || ae(s);\n        }), M(t.scroller, \"contextmenu\", function(s) {\n          return Ho(e, s);\n        }), M(t.input.getField(), \"contextmenu\", function(s) {\n          t.scroller.contains(s.target) || Ho(e, s);\n        });\n        var i, r = { end: 0 };\n        function n() {\n          t.activeTouch && (i = setTimeout(function() {\n            return t.activeTouch = null;\n          }, 1e3), r = t.activeTouch, r.end = +/* @__PURE__ */ new Date());\n        }\n        u(n, \"finishTouch\");\n        function l(s) {\n          if (s.touches.length != 1)\n            return !1;\n          var f = s.touches[0];\n          return f.radiusX <= 1 && f.radiusY <= 1;\n        }\n        u(l, \"isMouseLikeTouchEvent\");\n        function o(s, f) {\n          if (f.left == null)\n            return !0;\n          var h = f.left - s.left, c = f.top - s.top;\n          return h * h + c * c > 20 * 20;\n        }\n        u(o, \"farAway\"), M(t.scroller, \"touchstart\", function(s) {\n          if (!q(e, s) && !l(s) && !Cn(e, s)) {\n            t.input.ensurePolled(), clearTimeout(i);\n            var f = +/* @__PURE__ */ new Date();\n            t.activeTouch = {\n              start: f,\n              moved: !1,\n              prev: f - r.end <= 300 ? r : null\n            }, s.touches.length == 1 && (t.activeTouch.left = s.touches[0].pageX, t.activeTouch.top = s.touches[0].pageY);\n          }\n        }), M(t.scroller, \"touchmove\", function() {\n          t.activeTouch && (t.activeTouch.moved = !0);\n        }), M(t.scroller, \"touchend\", function(s) {\n          var f = t.activeTouch;\n          if (f && !Re(t, s) && f.left != null && !f.moved && /* @__PURE__ */ new Date() - f.start < 300) {\n            var h = e.coordsChar(t.activeTouch, \"page\"), c;\n            !f.prev || o(f, f.prev) ? c = new W(h, h) : !f.prev.prev || o(f, f.prev.prev) ? c = e.findWordAt(h) : c = new W(y(h.line, 0), N(e.doc, y(h.line + 1, 0))), e.setSelection(c.anchor, c.head), e.focus(), ae(s);\n          }\n          n();\n        }), M(t.scroller, \"touchcancel\", n), M(t.scroller, \"scroll\", function() {\n          t.scroller.clientHeight && (lr(e, t.scroller.scrollTop), ct(e, t.scroller.scrollLeft, !0), U(e, \"scroll\", e));\n        }), M(t.scroller, \"mousewheel\", function(s) {\n          return Ul(e, s);\n        }), M(t.scroller, \"DOMMouseScroll\", function(s) {\n          return Ul(e, s);\n        }), M(t.wrapper, \"scroll\", function() {\n          return t.wrapper.scrollTop = t.wrapper.scrollLeft = 0;\n        }), t.dragFunctions = {\n          enter: function(s) {\n            q(e, s) || Qt(s);\n          },\n          over: function(s) {\n            q(e, s) || (As(e, s), Qt(s));\n          },\n          start: function(s) {\n            return Ns(e, s);\n          },\n          drop: Q(e, Ds),\n          leave: function(s) {\n            q(e, s) || yo(e);\n          }\n        };\n        var a = t.input.getField();\n        M(a, \"keyup\", function(s) {\n          return Do.call(e, s);\n        }), M(a, \"keydown\", Q(e, Mo)), M(a, \"keypress\", Q(e, No)), M(a, \"focus\", function(s) {\n          return tn(e, s);\n        }), M(a, \"blur\", function(s) {\n          return Dt(e, s);\n        });\n      }\n      u(eu, \"registerEventHandlers\");\n      var wn = [];\n      R.defineInitHook = function(e) {\n        return wn.push(e);\n      };\n      function Sr(e, t, i, r) {\n        var n = e.doc, l;\n        i == null && (i = \"add\"), i == \"smart\" && (n.mode.indent ? l = jt(e, t).state : i = \"prev\");\n        var o = e.options.tabSize, a = S(n, t), s = xe(a.text, null, o);\n        a.stateAfter && (a.stateAfter = null);\n        var f = a.text.match(/^\\s*/)[0], h;\n        if (!r && !/\\S/.test(a.text))\n          h = 0, i = \"not\";\n        else if (i == \"smart\" && (h = n.mode.indent(l, a.text.slice(f.length), a.text), h == Nr || h > 150)) {\n          if (!r)\n            return;\n          i = \"prev\";\n        }\n        i == \"prev\" ? t > n.first ? h = xe(S(n, t - 1).text, null, o) : h = 0 : i == \"add\" ? h = s + e.options.indentUnit : i == \"subtract\" ? h = s - e.options.indentUnit : typeof i == \"number\" && (h = s + i), h = Math.max(0, h);\n        var c = \"\", p = 0;\n        if (e.options.indentWithTabs)\n          for (var d = Math.floor(h / o); d; --d)\n            p += o, c += \"\t\";\n        if (p < h && (c += yi(h - p)), c != f)\n          return Ft(n, c, y(t, 0), y(t, f.length), \"+input\"), a.stateAfter = null, !0;\n        for (var v = 0; v < n.sel.ranges.length; v++) {\n          var g = n.sel.ranges[v];\n          if (g.head.line == t && g.head.ch < f.length) {\n            var m = y(t, f.length);\n            vn(n, v, new W(m, m));\n            break;\n          }\n        }\n      }\n      u(Sr, \"indentLine\");\n      var Te = null;\n      function ui(e) {\n        Te = e;\n      }\n      u(ui, \"setLastCopied\");\n      function Sn(e, t, i, r, n) {\n        var l = e.doc;\n        e.display.shift = !1, r || (r = l.sel);\n        var o = +/* @__PURE__ */ new Date() - 200, a = n == \"paste\" || e.state.pasteIncoming > o, s = ki(t), f = null;\n        if (a && r.ranges.length > 1)\n          if (Te && Te.text.join(`\n`) == t) {\n            if (r.ranges.length % Te.text.length == 0) {\n              f = [];\n              for (var h = 0; h < Te.text.length; h++)\n                f.push(l.splitLines(Te.text[h]));\n            }\n          } else\n            s.length == r.ranges.length && e.options.pasteLinesPerSelection && (f = Or(s, function(b) {\n              return [b];\n            }));\n        for (var c = e.curOp.updateInput, p = r.ranges.length - 1; p >= 0; p--) {\n          var d = r.ranges[p], v = d.from(), g = d.to();\n          d.empty() && (i && i > 0 ? v = y(v.line, v.ch - i) : e.state.overwrite && !a ? g = y(g.line, Math.min(S(l, g.line).text.length, g.ch + H(s).length)) : a && Te && Te.lineWise && Te.text.join(`\n`) == s.join(`\n`) && (v = g = y(v.line, 0)));\n          var m = {\n            from: v,\n            to: g,\n            text: f ? f[p % f.length] : s,\n            origin: n || (a ? \"paste\" : e.state.cutIncoming > o ? \"cut\" : \"+input\")\n          };\n          Ht(e.doc, m), Z(e, \"inputRead\", e, m);\n        }\n        t && !a && Io(e, t), Nt(e), e.curOp.updateInput < 2 && (e.curOp.updateInput = c), e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = -1;\n      }\n      u(Sn, \"applyTextInput\");\n      function Eo(e, t) {\n        var i = e.clipboardData && e.clipboardData.getData(\"Text\");\n        if (i)\n          return e.preventDefault(), !t.isReadOnly() && !t.options.disableInput && de(t, function() {\n            return Sn(t, i, 0, null, \"paste\");\n          }), !0;\n      }\n      u(Eo, \"handlePaste\");\n      function Io(e, t) {\n        if (!(!e.options.electricChars || !e.options.smartIndent))\n          for (var i = e.doc.sel, r = i.ranges.length - 1; r >= 0; r--) {\n            var n = i.ranges[r];\n            if (!(n.head.ch > 100 || r && i.ranges[r - 1].head.line == n.head.line)) {\n              var l = e.getModeAt(n.head), o = !1;\n              if (l.electricChars) {\n                for (var a = 0; a < l.electricChars.length; a++)\n                  if (t.indexOf(l.electricChars.charAt(a)) > -1) {\n                    o = Sr(e, n.head.line, \"smart\");\n                    break;\n                  }\n              } else\n                l.electricInput && l.electricInput.test(S(e.doc, n.head.line).text.slice(0, n.head.ch)) && (o = Sr(e, n.head.line, \"smart\"));\n              o && Z(e, \"electricInput\", e, n.head.line);\n            }\n          }\n      }\n      u(Io, \"triggerElectric\");\n      function Ro(e) {\n        for (var t = [], i = [], r = 0; r < e.doc.sel.ranges.length; r++) {\n          var n = e.doc.sel.ranges[r].head.line, l = { anchor: y(n, 0), head: y(n + 1, 0) };\n          i.push(l), t.push(e.getRange(l.anchor, l.head));\n        }\n        return { text: t, ranges: i };\n      }\n      u(Ro, \"copyableRanges\");\n      function Bo(e, t, i, r) {\n        e.setAttribute(\"autocorrect\", i ? \"\" : \"off\"), e.setAttribute(\"autocapitalize\", r ? \"\" : \"off\"), e.setAttribute(\"spellcheck\", !!t);\n      }\n      u(Bo, \"disableBrowserMagic\");\n      function zo() {\n        var e = T(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none\"), t = T(\"div\", [e], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n        return ne ? e.style.width = \"1000px\" : e.setAttribute(\"wrap\", \"off\"), Ut && (e.style.border = \"1px solid black\"), Bo(e), t;\n      }\n      u(zo, \"hiddenTextarea\");\n      function tu(e) {\n        var t = e.optionHandlers, i = e.helpers = {};\n        e.prototype = {\n          constructor: e,\n          focus: function() {\n            window.focus(), this.display.input.focus();\n          },\n          setOption: function(r, n) {\n            var l = this.options, o = l[r];\n            l[r] == n && r != \"mode\" || (l[r] = n, t.hasOwnProperty(r) && Q(this, t[r])(this, n, o), U(this, \"optionChange\", this, r));\n          },\n          getOption: function(r) {\n            return this.options[r];\n          },\n          getDoc: function() {\n            return this.doc;\n          },\n          addKeyMap: function(r, n) {\n            this.state.keyMaps[n ? \"push\" : \"unshift\"](oi(r));\n          },\n          removeKeyMap: function(r) {\n            for (var n = this.state.keyMaps, l = 0; l < n.length; ++l)\n              if (n[l] == r || n[l].name == r)\n                return n.splice(l, 1), !0;\n          },\n          addOverlay: le(function(r, n) {\n            var l = r.token ? r : e.getMode(this.options, r);\n            if (l.startState)\n              throw new Error(\"Overlays may not be stateful.\");\n            Qo(\n              this.state.overlays,\n              {\n                mode: l,\n                modeSpec: r,\n                opaque: n && n.opaque,\n                priority: n && n.priority || 0\n              },\n              function(o) {\n                return o.priority;\n              }\n            ), this.state.modeGen++, se(this);\n          }),\n          removeOverlay: le(function(r) {\n            for (var n = this.state.overlays, l = 0; l < n.length; ++l) {\n              var o = n[l].modeSpec;\n              if (o == r || typeof r == \"string\" && o.name == r) {\n                n.splice(l, 1), this.state.modeGen++, se(this);\n                return;\n              }\n            }\n          }),\n          indentLine: le(function(r, n, l) {\n            typeof n != \"string\" && typeof n != \"number\" && (n == null ? n = this.options.smartIndent ? \"smart\" : \"prev\" : n = n ? \"add\" : \"subtract\"), Jt(this.doc, r) && Sr(this, r, n, l);\n          }),\n          indentSelection: le(function(r) {\n            for (var n = this.doc.sel.ranges, l = -1, o = 0; o < n.length; o++) {\n              var a = n[o];\n              if (a.empty())\n                a.head.line > l && (Sr(this, a.head.line, r, !0), l = a.head.line, o == this.doc.sel.primIndex && Nt(this));\n              else {\n                var s = a.from(), f = a.to(), h = Math.max(l, s.line);\n                l = Math.min(this.lastLine(), f.line - (f.ch ? 0 : 1)) + 1;\n                for (var c = h; c < l; ++c)\n                  Sr(this, c, r);\n                var p = this.doc.sel.ranges;\n                s.ch == 0 && n.length == p.length && p[o].from().ch > 0 && vn(this.doc, o, new W(s, p[o].to()), Me);\n              }\n            }\n          }),\n          // Fetch the parser token for a given character. Useful for hacks\n          // that want to inspect the mode state (say, for completion).\n          getTokenAt: function(r, n) {\n            return Zn(this, r, n);\n          },\n          getLineTokens: function(r, n) {\n            return Zn(this, y(r), n, !0);\n          },\n          getTokenTypeAt: function(r) {\n            r = N(this.doc, r);\n            var n = Xn(this, S(this.doc, r.line)), l = 0, o = (n.length - 1) / 2, a = r.ch, s;\n            if (a == 0)\n              s = n[2];\n            else\n              for (; ; ) {\n                var f = l + o >> 1;\n                if ((f ? n[f * 2 - 1] : 0) >= a)\n                  o = f;\n                else if (n[f * 2 + 1] < a)\n                  l = f + 1;\n                else {\n                  s = n[f * 2 + 2];\n                  break;\n                }\n              }\n            var h = s ? s.indexOf(\"overlay \") : -1;\n            return h < 0 ? s : h == 0 ? null : s.slice(0, h - 1);\n          },\n          getModeAt: function(r) {\n            var n = this.doc.mode;\n            return n.innerMode ? e.innerMode(n, this.getTokenAt(r).state).mode : n;\n          },\n          getHelper: function(r, n) {\n            return this.getHelpers(r, n)[0];\n          },\n          getHelpers: function(r, n) {\n            var l = [];\n            if (!i.hasOwnProperty(n))\n              return l;\n            var o = i[n], a = this.getModeAt(r);\n            if (typeof a[n] == \"string\")\n              o[a[n]] && l.push(o[a[n]]);\n            else if (a[n])\n              for (var s = 0; s < a[n].length; s++) {\n                var f = o[a[n][s]];\n                f && l.push(f);\n              }\n            else\n              a.helperType && o[a.helperType] ? l.push(o[a.helperType]) : o[a.name] && l.push(o[a.name]);\n            for (var h = 0; h < o._global.length; h++) {\n              var c = o._global[h];\n              c.pred(a, this) && ee(l, c.val) == -1 && l.push(c.val);\n            }\n            return l;\n          },\n          getStateAfter: function(r, n) {\n            var l = this.doc;\n            return r = Un(l, r ?? l.first + l.size - 1), jt(this, r + 1, n).state;\n          },\n          cursorCoords: function(r, n) {\n            var l, o = this.doc.sel.primary();\n            return r == null ? l = o.head : typeof r == \"object\" ? l = N(this.doc, r) : l = r ? o.from() : o.to(), Le(this, l, n || \"page\");\n          },\n          charCoords: function(r, n) {\n            return Xr(this, N(this.doc, r), n || \"page\");\n          },\n          coordsChar: function(r, n) {\n            return r = Sl(this, r, n || \"page\"), qi(this, r.left, r.top);\n          },\n          lineAtHeight: function(r, n) {\n            return r = Sl(this, { top: r, left: 0 }, n || \"page\").top, at(this.doc, r + this.display.viewOffset);\n          },\n          heightAtLine: function(r, n, l) {\n            var o = !1, a;\n            if (typeof r == \"number\") {\n              var s = this.doc.first + this.doc.size - 1;\n              r < this.doc.first ? r = this.doc.first : r > s && (r = s, o = !0), a = S(this.doc, r);\n            } else\n              a = r;\n            return _r(this, a, { top: 0, left: 0 }, n || \"page\", l || o).top + (o ? this.doc.height - Ie(a) : 0);\n          },\n          defaultTextHeight: function() {\n            return Tt(this.display);\n          },\n          defaultCharWidth: function() {\n            return Mt(this.display);\n          },\n          getViewport: function() {\n            return { from: this.display.viewFrom, to: this.display.viewTo };\n          },\n          addWidget: function(r, n, l, o, a) {\n            var s = this.display;\n            r = Le(this, N(this.doc, r));\n            var f = r.bottom, h = r.left;\n            if (n.style.position = \"absolute\", n.setAttribute(\"cm-ignore-events\", \"true\"), this.display.input.setUneditable(n), s.sizer.appendChild(n), o == \"over\")\n              f = r.top;\n            else if (o == \"above\" || o == \"near\") {\n              var c = Math.max(s.wrapper.clientHeight, this.doc.height), p = Math.max(s.sizer.clientWidth, s.lineSpace.clientWidth);\n              (o == \"above\" || r.bottom + n.offsetHeight > c) && r.top > n.offsetHeight ? f = r.top - n.offsetHeight : r.bottom + n.offsetHeight <= c && (f = r.bottom), h + n.offsetWidth > p && (h = p - n.offsetWidth);\n            }\n            n.style.top = f + \"px\", n.style.left = n.style.right = \"\", a == \"right\" ? (h = s.sizer.clientWidth - n.offsetWidth, n.style.right = \"0px\") : (a == \"left\" ? h = 0 : a == \"middle\" && (h = (s.sizer.clientWidth - n.offsetWidth) / 2), n.style.left = h + \"px\"), l && Va(this, { left: h, top: f, right: h + n.offsetWidth, bottom: f + n.offsetHeight });\n          },\n          triggerOnKeyDown: le(Mo),\n          triggerOnKeyPress: le(No),\n          triggerOnKeyUp: Do,\n          triggerOnMouseDown: le(Ao),\n          execCommand: function(r) {\n            if (br.hasOwnProperty(r))\n              return br[r].call(null, this);\n          },\n          triggerElectric: le(function(r) {\n            Io(this, r);\n          }),\n          findPosH: function(r, n, l, o) {\n            var a = 1;\n            n < 0 && (a = -1, n = -n);\n            for (var s = N(this.doc, r), f = 0; f < n && (s = Ln(this.doc, s, a, l, o), !s.hitSide); ++f)\n              ;\n            return s;\n          },\n          moveH: le(function(r, n) {\n            var l = this;\n            this.extendSelectionsBy(function(o) {\n              return l.display.shift || l.doc.extend || o.empty() ? Ln(l.doc, o.head, r, n, l.options.rtlMoveVisually) : r < 0 ? o.from() : o.to();\n            }, Xt);\n          }),\n          deleteH: le(function(r, n) {\n            var l = this.doc.sel, o = this.doc;\n            l.somethingSelected() ? o.replaceSelection(\"\", null, \"+delete\") : It(this, function(a) {\n              var s = Ln(o, a.head, r, n, !1);\n              return r < 0 ? { from: s, to: a.head } : { from: a.head, to: s };\n            });\n          }),\n          findPosV: function(r, n, l, o) {\n            var a = 1, s = o;\n            n < 0 && (a = -1, n = -n);\n            for (var f = N(this.doc, r), h = 0; h < n; ++h) {\n              var c = Le(this, f, \"div\");\n              if (s == null ? s = c.left : c.left = s, f = Go(this, c, a, l), f.hitSide)\n                break;\n            }\n            return f;\n          },\n          moveV: le(function(r, n) {\n            var l = this, o = this.doc, a = [], s = !this.display.shift && !o.extend && o.sel.somethingSelected();\n            if (o.extendSelectionsBy(function(h) {\n              if (s)\n                return r < 0 ? h.from() : h.to();\n              var c = Le(l, h.head, \"div\");\n              h.goalColumn != null && (c.left = h.goalColumn), a.push(c.left);\n              var p = Go(l, c, r, n);\n              return n == \"page\" && h == o.sel.primary() && nn(l, Xr(l, p, \"div\").top - c.top), p;\n            }, Xt), a.length)\n              for (var f = 0; f < o.sel.ranges.length; f++)\n                o.sel.ranges[f].goalColumn = a[f];\n          }),\n          // Find the word at the given position (as returned by coordsChar).\n          findWordAt: function(r) {\n            var n = this.doc, l = S(n, r.line).text, o = r.ch, a = r.ch;\n            if (l) {\n              var s = this.getHelper(r, \"wordChars\");\n              (r.sticky == \"before\" || a == l.length) && o ? --o : ++a;\n              for (var f = l.charAt(o), h = Wr(f, s) ? function(c) {\n                return Wr(c, s);\n              } : /\\s/.test(f) ? function(c) {\n                return /\\s/.test(c);\n              } : function(c) {\n                return !/\\s/.test(c) && !Wr(c);\n              }; o > 0 && h(l.charAt(o - 1)); )\n                --o;\n              for (; a < l.length && h(l.charAt(a)); )\n                ++a;\n            }\n            return new W(y(r.line, o), y(r.line, a));\n          },\n          toggleOverwrite: function(r) {\n            r != null && r == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? it(this.display.cursorDiv, \"CodeMirror-overwrite\") : tt(this.display.cursorDiv, \"CodeMirror-overwrite\"), U(this, \"overwriteToggle\", this, this.state.overwrite));\n          },\n          hasFocus: function() {\n            return this.display.input.getField() == be();\n          },\n          isReadOnly: function() {\n            return !!(this.options.readOnly || this.doc.cantEdit);\n          },\n          scrollTo: le(function(r, n) {\n            nr(this, r, n);\n          }),\n          getScrollInfo: function() {\n            var r = this.display.scroller;\n            return {\n              left: r.scrollLeft,\n              top: r.scrollTop,\n              height: r.scrollHeight - Ae(this) - this.display.barHeight,\n              width: r.scrollWidth - Ae(this) - this.display.barWidth,\n              clientHeight: Ki(this),\n              clientWidth: st(this)\n            };\n          },\n          scrollIntoView: le(function(r, n) {\n            r == null ? (r = { from: this.doc.sel.primary().head, to: null }, n == null && (n = this.options.cursorScrollMargin)) : typeof r == \"number\" ? r = { from: y(r, 0), to: null } : r.from == null && (r = { from: r, to: null }), r.to || (r.to = r.from), r.margin = n || 0, r.from.line != null ? $a(this, r) : Wl(this, r.from, r.to, r.margin);\n          }),\n          setSize: le(function(r, n) {\n            var l = this, o = /* @__PURE__ */ u(function(s) {\n              return typeof s == \"number\" || /^\\d+$/.test(String(s)) ? s + \"px\" : s;\n            }, \"interpret\");\n            r != null && (this.display.wrapper.style.width = o(r)), n != null && (this.display.wrapper.style.height = o(n)), this.options.lineWrapping && xl(this);\n            var a = this.display.viewFrom;\n            this.doc.iter(a, this.display.viewTo, function(s) {\n              if (s.widgets) {\n                for (var f = 0; f < s.widgets.length; f++)\n                  if (s.widgets[f].noHScroll) {\n                    Ye(l, a, \"widget\");\n                    break;\n                  }\n              }\n              ++a;\n            }), this.curOp.forceUpdate = !0, U(this, \"refresh\", this);\n          }),\n          operation: function(r) {\n            return de(this, r);\n          },\n          startOperation: function() {\n            return pt(this);\n          },\n          endOperation: function() {\n            return vt(this);\n          },\n          refresh: le(function() {\n            var r = this.display.cachedTextHeight;\n            se(this), this.curOp.forceUpdate = !0, rr(this), nr(this, this.doc.scrollLeft, this.doc.scrollTop), an(this.display), (r == null || Math.abs(r - Tt(this.display)) > 0.5 || this.options.lineWrapping) && ji(this), U(this, \"refresh\", this);\n          }),\n          swapDoc: le(function(r) {\n            var n = this.doc;\n            return n.cm = null, this.state.selectingText && this.state.selectingText(), Yl(this, r), rr(this), this.display.input.reset(), nr(this, r.scrollLeft, r.scrollTop), this.curOp.forceScroll = !0, Z(this, \"swapDoc\", this, n), n;\n          }),\n          phrase: function(r) {\n            var n = this.options.phrases;\n            return n && Object.prototype.hasOwnProperty.call(n, r) ? n[r] : r;\n          },\n          getInputField: function() {\n            return this.display.input.getField();\n          },\n          getWrapperElement: function() {\n            return this.display.wrapper;\n          },\n          getScrollerElement: function() {\n            return this.display.scroller;\n          },\n          getGutterElement: function() {\n            return this.display.gutters;\n          }\n        }, xt(e), e.registerHelper = function(r, n, l) {\n          i.hasOwnProperty(r) || (i[r] = e[r] = { _global: [] }), i[r][n] = l;\n        }, e.registerGlobalHelper = function(r, n, l, o) {\n          e.registerHelper(r, n, o), i[r]._global.push({ pred: l, val: o });\n        };\n      }\n      u(tu, \"addEditorMethods\");\n      function Ln(e, t, i, r, n) {\n        var l = t, o = i, a = S(e, t.line), s = n && e.direction == \"rtl\" ? -i : i;\n        function f() {\n          var C = t.line + s;\n          return C < e.first || C >= e.first + e.size ? !1 : (t = new y(C, t.ch, t.sticky), a = S(e, C));\n        }\n        u(f, \"findNextLine\");\n        function h(C) {\n          var x;\n          if (r == \"codepoint\") {\n            var w = a.text.charCodeAt(t.ch + (i > 0 ? 0 : -1));\n            if (isNaN(w))\n              x = null;\n            else {\n              var k = i > 0 ? w >= 55296 && w < 56320 : w >= 56320 && w < 57343;\n              x = new y(t.line, Math.max(0, Math.min(a.text.length, t.ch + i * (k ? 2 : 1))), -i);\n            }\n          } else\n            n ? x = Es(e.cm, a, t, i) : x = yn(a, t, i);\n          if (x == null)\n            if (!C && f())\n              t = mn(n, e.cm, a, t.line, s);\n            else\n              return !1;\n          else\n            t = x;\n          return !0;\n        }\n        if (u(h, \"moveOnce\"), r == \"char\" || r == \"codepoint\")\n          h();\n        else if (r == \"column\")\n          h(!0);\n        else if (r == \"word\" || r == \"group\")\n          for (var c = null, p = r == \"group\", d = e.cm && e.cm.getHelper(t, \"wordChars\"), v = !0; !(i < 0 && !h(!v)); v = !1) {\n            var g = a.text.charAt(t.ch) || `\n`, m = Wr(g, d) ? \"w\" : p && g == `\n` ? \"n\" : !p || /\\s/.test(g) ? null : \"p\";\n            if (p && !v && !m && (m = \"s\"), c && c != m) {\n              i < 0 && (i = 1, h(), t.sticky = \"after\");\n              break;\n            }\n            if (m && (c = m), i > 0 && !h(!v))\n              break;\n          }\n        var b = ii(e, t, l, o, !0);\n        return Wi(l, b) && (b.hitSide = !0), b;\n      }\n      u(Ln, \"findPosH\");\n      function Go(e, t, i, r) {\n        var n = e.doc, l = t.left, o;\n        if (r == \"page\") {\n          var a = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight), s = Math.max(a - 0.5 * Tt(e.display), 3);\n          o = (i > 0 ? t.bottom : t.top) + i * s;\n        } else\n          r == \"line\" && (o = i > 0 ? t.bottom + 3 : t.top - 3);\n        for (var f; f = qi(e, l, o), !!f.outside; ) {\n          if (i < 0 ? o <= 0 : o >= n.height) {\n            f.hitSide = !0;\n            break;\n          }\n          o += i * 5;\n        }\n        return f;\n      }\n      u(Go, \"findPosV\");\n      var P = /* @__PURE__ */ u(function(e) {\n        this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new _e(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null;\n      }, \"ContentEditableInput\");\n      P.prototype.init = function(e) {\n        var t = this, i = this, r = i.cm, n = i.div = e.lineDiv;\n        n.contentEditable = !0, Bo(n, r.options.spellcheck, r.options.autocorrect, r.options.autocapitalize);\n        function l(a) {\n          for (var s = a.target; s; s = s.parentNode) {\n            if (s == n)\n              return !0;\n            if (/\\bCodeMirror-(?:line)?widget\\b/.test(s.className))\n              break;\n          }\n          return !1;\n        }\n        u(l, \"belongsToInput\"), M(n, \"paste\", function(a) {\n          !l(a) || q(r, a) || Eo(a, r) || I <= 11 && setTimeout(Q(r, function() {\n            return t.updateFromDOM();\n          }), 20);\n        }), M(n, \"compositionstart\", function(a) {\n          t.composing = { data: a.data, done: !1 };\n        }), M(n, \"compositionupdate\", function(a) {\n          t.composing || (t.composing = { data: a.data, done: !1 });\n        }), M(n, \"compositionend\", function(a) {\n          t.composing && (a.data != t.composing.data && t.readFromDOMSoon(), t.composing.done = !0);\n        }), M(n, \"touchstart\", function() {\n          return i.forceCompositionEnd();\n        }), M(n, \"input\", function() {\n          t.composing || t.readFromDOMSoon();\n        });\n        function o(a) {\n          if (!(!l(a) || q(r, a))) {\n            if (r.somethingSelected())\n              ui({ lineWise: !1, text: r.getSelections() }), a.type == \"cut\" && r.replaceSelection(\"\", null, \"cut\");\n            else if (r.options.lineWiseCopyCut) {\n              var s = Ro(r);\n              ui({ lineWise: !0, text: s.text }), a.type == \"cut\" && r.operation(function() {\n                r.setSelections(s.ranges, 0, Me), r.replaceSelection(\"\", null, \"cut\");\n              });\n            } else\n              return;\n            if (a.clipboardData) {\n              a.clipboardData.clearData();\n              var f = Te.text.join(`\n`);\n              if (a.clipboardData.setData(\"Text\", f), a.clipboardData.getData(\"Text\") == f) {\n                a.preventDefault();\n                return;\n              }\n            }\n            var h = zo(), c = h.firstChild;\n            r.display.lineSpace.insertBefore(h, r.display.lineSpace.firstChild), c.value = Te.text.join(`\n`);\n            var p = be();\n            _t(c), setTimeout(function() {\n              r.display.lineSpace.removeChild(h), p.focus(), p == n && i.showPrimarySelection();\n            }, 50);\n          }\n        }\n        u(o, \"onCopyCut\"), M(n, \"copy\", o), M(n, \"cut\", o);\n      }, P.prototype.screenReaderLabelChanged = function(e) {\n        e ? this.div.setAttribute(\"aria-label\", e) : this.div.removeAttribute(\"aria-label\");\n      }, P.prototype.prepareSelection = function() {\n        var e = Nl(this.cm, !1);\n        return e.focus = be() == this.div, e;\n      }, P.prototype.showSelection = function(e, t) {\n        !e || !this.cm.display.view.length || ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e));\n      }, P.prototype.getSelection = function() {\n        return this.cm.display.wrapper.ownerDocument.getSelection();\n      }, P.prototype.showPrimarySelection = function() {\n        var e = this.getSelection(), t = this.cm, i = t.doc.sel.primary(), r = i.from(), n = i.to();\n        if (t.display.viewTo == t.display.viewFrom || r.line >= t.display.viewTo || n.line < t.display.viewFrom) {\n          e.removeAllRanges();\n          return;\n        }\n        var l = fi(t, e.anchorNode, e.anchorOffset), o = fi(t, e.focusNode, e.focusOffset);\n        if (!(l && !l.bad && o && !o.bad && D(Pr(l, o), r) == 0 && D(Fr(l, o), n) == 0)) {\n          var a = t.display.view, s = r.line >= t.display.viewFrom && Uo(t, r) || { node: a[0].measure.map[2], offset: 0 }, f = n.line < t.display.viewTo && Uo(t, n);\n          if (!f) {\n            var h = a[a.length - 1].measure, c = h.maps ? h.maps[h.maps.length - 1] : h.map;\n            f = { node: c[c.length - 1], offset: c[c.length - 2] - c[c.length - 3] };\n          }\n          if (!s || !f) {\n            e.removeAllRanges();\n            return;\n          }\n          var p = e.rangeCount && e.getRangeAt(0), d;\n          try {\n            d = rt(s.node, s.offset, f.offset, f.node);\n          } catch {\n          }\n          d && (!Fe && t.state.focused ? (e.collapse(s.node, s.offset), d.collapsed || (e.removeAllRanges(), e.addRange(d))) : (e.removeAllRanges(), e.addRange(d)), p && e.anchorNode == null ? e.addRange(p) : Fe && this.startGracePeriod()), this.rememberSelection();\n        }\n      }, P.prototype.startGracePeriod = function() {\n        var e = this;\n        clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {\n          e.gracePeriod = !1, e.selectionChanged() && e.cm.operation(function() {\n            return e.cm.curOp.selectionChanged = !0;\n          });\n        }, 20);\n      }, P.prototype.showMultipleSelections = function(e) {\n        ve(this.cm.display.cursorDiv, e.cursors), ve(this.cm.display.selectionDiv, e.selection);\n      }, P.prototype.rememberSelection = function() {\n        var e = this.getSelection();\n        this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset;\n      }, P.prototype.selectionInEditor = function() {\n        var e = this.getSelection();\n        if (!e.rangeCount)\n          return !1;\n        var t = e.getRangeAt(0).commonAncestorContainer;\n        return Ke(this.div, t);\n      }, P.prototype.focus = function() {\n        this.cm.options.readOnly != \"nocursor\" && ((!this.selectionInEditor() || be() != this.div) && this.showSelection(this.prepareSelection(), !0), this.div.focus());\n      }, P.prototype.blur = function() {\n        this.div.blur();\n      }, P.prototype.getField = function() {\n        return this.div;\n      }, P.prototype.supportsTouch = function() {\n        return !0;\n      }, P.prototype.receivedFocus = function() {\n        var e = this, t = this;\n        this.selectionInEditor() ? setTimeout(function() {\n          return e.pollSelection();\n        }, 20) : de(this.cm, function() {\n          return t.cm.curOp.selectionChanged = !0;\n        });\n        function i() {\n          t.cm.state.focused && (t.pollSelection(), t.polling.set(t.cm.options.pollInterval, i));\n        }\n        u(i, \"poll\"), this.polling.set(this.cm.options.pollInterval, i);\n      }, P.prototype.selectionChanged = function() {\n        var e = this.getSelection();\n        return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset;\n      }, P.prototype.pollSelection = function() {\n        if (!(this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())) {\n          var e = this.getSelection(), t = this.cm;\n          if (Dr && Tr && this.cm.display.gutterSpecs.length && ru(e.anchorNode)) {\n            this.cm.triggerOnKeyDown({ type: \"keydown\", keyCode: 8, preventDefault: Math.abs }), this.blur(), this.focus();\n            return;\n          }\n          if (!this.composing) {\n            this.rememberSelection();\n            var i = fi(t, e.anchorNode, e.anchorOffset), r = fi(t, e.focusNode, e.focusOffset);\n            i && r && de(t, function() {\n              te(t.doc, Ze(i, r), Me), (i.bad || r.bad) && (t.curOp.selectionChanged = !0);\n            });\n          }\n        }\n      }, P.prototype.pollContent = function() {\n        this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);\n        var e = this.cm, t = e.display, i = e.doc.sel.primary(), r = i.from(), n = i.to();\n        if (r.ch == 0 && r.line > e.firstLine() && (r = y(r.line - 1, S(e.doc, r.line - 1).length)), n.ch == S(e.doc, n.line).text.length && n.line < e.lastLine() && (n = y(n.line + 1, 0)), r.line < t.viewFrom || n.line > t.viewTo - 1)\n          return !1;\n        var l, o, a;\n        r.line == t.viewFrom || (l = ht(e, r.line)) == 0 ? (o = F(t.view[0].line), a = t.view[0].node) : (o = F(t.view[l].line), a = t.view[l - 1].node.nextSibling);\n        var s = ht(e, n.line), f, h;\n        if (s == t.view.length - 1 ? (f = t.viewTo - 1, h = t.lineDiv.lastChild) : (f = F(t.view[s + 1].line) - 1, h = t.view[s + 1].node.previousSibling), !a)\n          return !1;\n        for (var c = e.doc.splitLines(iu(e, a, h, o, f)), p = ot(e.doc, y(o, 0), y(f, S(e.doc, f).text.length)); c.length > 1 && p.length > 1; )\n          if (H(c) == H(p))\n            c.pop(), p.pop(), f--;\n          else if (c[0] == p[0])\n            c.shift(), p.shift(), o++;\n          else\n            break;\n        for (var d = 0, v = 0, g = c[0], m = p[0], b = Math.min(g.length, m.length); d < b && g.charCodeAt(d) == m.charCodeAt(d); )\n          ++d;\n        for (var C = H(c), x = H(p), w = Math.min(\n          C.length - (c.length == 1 ? d : 0),\n          x.length - (p.length == 1 ? d : 0)\n        ); v < w && C.charCodeAt(C.length - v - 1) == x.charCodeAt(x.length - v - 1); )\n          ++v;\n        if (c.length == 1 && p.length == 1 && o == r.line)\n          for (; d && d > r.ch && C.charCodeAt(C.length - v - 1) == x.charCodeAt(x.length - v - 1); )\n            d--, v++;\n        c[c.length - 1] = C.slice(0, C.length - v).replace(/^\\u200b+/, \"\"), c[0] = c[0].slice(d).replace(/\\u200b+$/, \"\");\n        var k = y(o, d), L = y(f, p.length ? H(p).length - v : 0);\n        if (c.length > 1 || c[0] || D(k, L))\n          return Ft(e.doc, c, k, L, \"+input\"), !0;\n      }, P.prototype.ensurePolled = function() {\n        this.forceCompositionEnd();\n      }, P.prototype.reset = function() {\n        this.forceCompositionEnd();\n      }, P.prototype.forceCompositionEnd = function() {\n        this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus());\n      }, P.prototype.readFromDOMSoon = function() {\n        var e = this;\n        this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout(function() {\n          if (e.readDOMTimeout = null, e.composing)\n            if (e.composing.done)\n              e.composing = null;\n            else\n              return;\n          e.updateFromDOM();\n        }, 80));\n      }, P.prototype.updateFromDOM = function() {\n        var e = this;\n        (this.cm.isReadOnly() || !this.pollContent()) && de(this.cm, function() {\n          return se(e.cm);\n        });\n      }, P.prototype.setUneditable = function(e) {\n        e.contentEditable = \"false\";\n      }, P.prototype.onKeyPress = function(e) {\n        e.charCode == 0 || this.composing || (e.preventDefault(), this.cm.isReadOnly() || Q(this.cm, Sn)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0));\n      }, P.prototype.readOnlyChanged = function(e) {\n        this.div.contentEditable = String(e != \"nocursor\");\n      }, P.prototype.onContextMenu = function() {\n      }, P.prototype.resetPosition = function() {\n      }, P.prototype.needsContentAttribute = !0;\n      function Uo(e, t) {\n        var i = _i(e, t.line);\n        if (!i || i.hidden)\n          return null;\n        var r = S(e.doc, t.line), n = vl(i, r, t.line), l = Pe(r, e.doc.direction), o = \"left\";\n        if (l) {\n          var a = Zt(l, t.ch);\n          o = a % 2 ? \"right\" : \"left\";\n        }\n        var s = ml(n.map, t.ch, o);\n        return s.offset = s.collapse == \"right\" ? s.end : s.start, s;\n      }\n      u(Uo, \"posToDOM\");\n      function ru(e) {\n        for (var t = e; t; t = t.parentNode)\n          if (/CodeMirror-gutter-wrapper/.test(t.className))\n            return !0;\n        return !1;\n      }\n      u(ru, \"isInGutter\");\n      function Bt(e, t) {\n        return t && (e.bad = !0), e;\n      }\n      u(Bt, \"badPos\");\n      function iu(e, t, i, r, n) {\n        var l = \"\", o = !1, a = e.doc.lineSeparator(), s = !1;\n        function f(d) {\n          return function(v) {\n            return v.id == d;\n          };\n        }\n        u(f, \"recognizeMarker\");\n        function h() {\n          o && (l += a, s && (l += a), o = s = !1);\n        }\n        u(h, \"close\");\n        function c(d) {\n          d && (h(), l += d);\n        }\n        u(c, \"addText\");\n        function p(d) {\n          if (d.nodeType == 1) {\n            var v = d.getAttribute(\"cm-text\");\n            if (v) {\n              c(v);\n              return;\n            }\n            var g = d.getAttribute(\"cm-marker\"), m;\n            if (g) {\n              var b = e.findMarks(y(r, 0), y(n + 1, 0), f(+g));\n              b.length && (m = b[0].find(0)) && c(ot(e.doc, m.from, m.to).join(a));\n              return;\n            }\n            if (d.getAttribute(\"contenteditable\") == \"false\")\n              return;\n            var C = /^(pre|div|p|li|table|br)$/i.test(d.nodeName);\n            if (!/^br$/i.test(d.nodeName) && d.textContent.length == 0)\n              return;\n            C && h();\n            for (var x = 0; x < d.childNodes.length; x++)\n              p(d.childNodes[x]);\n            /^(pre|p)$/i.test(d.nodeName) && (s = !0), C && (o = !0);\n          } else\n            d.nodeType == 3 && c(d.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n        }\n        for (u(p, \"walk\"); p(t), t != i; )\n          t = t.nextSibling, s = !1;\n        return l;\n      }\n      u(iu, \"domTextBetween\");\n      function fi(e, t, i) {\n        var r;\n        if (t == e.display.lineDiv) {\n          if (r = e.display.lineDiv.childNodes[i], !r)\n            return Bt(e.clipPos(y(e.display.viewTo - 1)), !0);\n          t = null, i = 0;\n        } else\n          for (r = t; ; r = r.parentNode) {\n            if (!r || r == e.display.lineDiv)\n              return null;\n            if (r.parentNode && r.parentNode == e.display.lineDiv)\n              break;\n          }\n        for (var n = 0; n < e.display.view.length; n++) {\n          var l = e.display.view[n];\n          if (l.node == r)\n            return nu(l, t, i);\n        }\n      }\n      u(fi, \"domToPos\");\n      function nu(e, t, i) {\n        var r = e.text.firstChild, n = !1;\n        if (!t || !Ke(r, t))\n          return Bt(y(F(e.line), 0), !0);\n        if (t == r && (n = !0, t = r.childNodes[i], i = 0, !t)) {\n          var l = e.rest ? H(e.rest) : e.line;\n          return Bt(y(F(l), l.text.length), n);\n        }\n        var o = t.nodeType == 3 ? t : null, a = t;\n        for (!o && t.childNodes.length == 1 && t.firstChild.nodeType == 3 && (o = t.firstChild, i && (i = o.nodeValue.length)); a.parentNode != r; )\n          a = a.parentNode;\n        var s = e.measure, f = s.maps;\n        function h(m, b, C) {\n          for (var x = -1; x < (f ? f.length : 0); x++)\n            for (var w = x < 0 ? s.map : f[x], k = 0; k < w.length; k += 3) {\n              var L = w[k + 2];\n              if (L == m || L == b) {\n                var A = F(x < 0 ? e.line : e.rest[x]), E = w[k] + C;\n                return (C < 0 || L != m) && (E = w[k + (C ? 1 : 0)]), y(A, E);\n              }\n            }\n        }\n        u(h, \"find\");\n        var c = h(o, a, i);\n        if (c)\n          return Bt(c, n);\n        for (var p = a.nextSibling, d = o ? o.nodeValue.length - i : 0; p; p = p.nextSibling) {\n          if (c = h(p, p.firstChild, 0), c)\n            return Bt(y(c.line, c.ch - d), n);\n          d += p.textContent.length;\n        }\n        for (var v = a.previousSibling, g = i; v; v = v.previousSibling) {\n          if (c = h(v, v.firstChild, -1), c)\n            return Bt(y(c.line, c.ch + g), n);\n          g += v.textContent.length;\n        }\n      }\n      u(nu, \"locateNodeInLineView\");\n      var G = /* @__PURE__ */ u(function(e) {\n        this.cm = e, this.prevInput = \"\", this.pollingFast = !1, this.polling = new _e(), this.hasSelection = !1, this.composing = null;\n      }, \"TextareaInput\");\n      G.prototype.init = function(e) {\n        var t = this, i = this, r = this.cm;\n        this.createField(e);\n        var n = this.textarea;\n        e.wrapper.insertBefore(this.wrapper, e.wrapper.firstChild), Ut && (n.style.width = \"0px\"), M(n, \"input\", function() {\n          O && I >= 9 && t.hasSelection && (t.hasSelection = null), i.poll();\n        }), M(n, \"paste\", function(o) {\n          q(r, o) || Eo(o, r) || (r.state.pasteIncoming = +/* @__PURE__ */ new Date(), i.fastPoll());\n        });\n        function l(o) {\n          if (!q(r, o)) {\n            if (r.somethingSelected())\n              ui({ lineWise: !1, text: r.getSelections() });\n            else if (r.options.lineWiseCopyCut) {\n              var a = Ro(r);\n              ui({ lineWise: !0, text: a.text }), o.type == \"cut\" ? r.setSelections(a.ranges, null, Me) : (i.prevInput = \"\", n.value = a.text.join(`\n`), _t(n));\n            } else\n              return;\n            o.type == \"cut\" && (r.state.cutIncoming = +/* @__PURE__ */ new Date());\n          }\n        }\n        u(l, \"prepareCopyCut\"), M(n, \"cut\", l), M(n, \"copy\", l), M(e.scroller, \"paste\", function(o) {\n          if (!(Re(e, o) || q(r, o))) {\n            if (!n.dispatchEvent) {\n              r.state.pasteIncoming = +/* @__PURE__ */ new Date(), i.focus();\n              return;\n            }\n            var a = new Event(\"paste\");\n            a.clipboardData = o.clipboardData, n.dispatchEvent(a);\n          }\n        }), M(e.lineSpace, \"selectstart\", function(o) {\n          Re(e, o) || ae(o);\n        }), M(n, \"compositionstart\", function() {\n          var o = r.getCursor(\"from\");\n          i.composing && i.composing.range.clear(), i.composing = {\n            start: o,\n            range: r.markText(o, r.getCursor(\"to\"), { className: \"CodeMirror-composing\" })\n          };\n        }), M(n, \"compositionend\", function() {\n          i.composing && (i.poll(), i.composing.range.clear(), i.composing = null);\n        });\n      }, G.prototype.createField = function(e) {\n        this.wrapper = zo(), this.textarea = this.wrapper.firstChild;\n      }, G.prototype.screenReaderLabelChanged = function(e) {\n        e ? this.textarea.setAttribute(\"aria-label\", e) : this.textarea.removeAttribute(\"aria-label\");\n      }, G.prototype.prepareSelection = function() {\n        var e = this.cm, t = e.display, i = e.doc, r = Nl(e);\n        if (e.options.moveInputWithCursor) {\n          var n = Le(e, i.sel.primary().head, \"div\"), l = t.wrapper.getBoundingClientRect(), o = t.lineDiv.getBoundingClientRect();\n          r.teTop = Math.max(0, Math.min(\n            t.wrapper.clientHeight - 10,\n            n.top + o.top - l.top\n          )), r.teLeft = Math.max(0, Math.min(\n            t.wrapper.clientWidth - 10,\n            n.left + o.left - l.left\n          ));\n        }\n        return r;\n      }, G.prototype.showSelection = function(e) {\n        var t = this.cm, i = t.display;\n        ve(i.cursorDiv, e.cursors), ve(i.selectionDiv, e.selection), e.teTop != null && (this.wrapper.style.top = e.teTop + \"px\", this.wrapper.style.left = e.teLeft + \"px\");\n      }, G.prototype.reset = function(e) {\n        if (!(this.contextMenuPending || this.composing)) {\n          var t = this.cm;\n          if (t.somethingSelected()) {\n            this.prevInput = \"\";\n            var i = t.getSelection();\n            this.textarea.value = i, t.state.focused && _t(this.textarea), O && I >= 9 && (this.hasSelection = i);\n          } else\n            e || (this.prevInput = this.textarea.value = \"\", O && I >= 9 && (this.hasSelection = null));\n        }\n      }, G.prototype.getField = function() {\n        return this.textarea;\n      }, G.prototype.supportsTouch = function() {\n        return !1;\n      }, G.prototype.focus = function() {\n        if (this.cm.options.readOnly != \"nocursor\" && (!Kt || be() != this.textarea))\n          try {\n            this.textarea.focus();\n          } catch {\n          }\n      }, G.prototype.blur = function() {\n        this.textarea.blur();\n      }, G.prototype.resetPosition = function() {\n        this.wrapper.style.top = this.wrapper.style.left = 0;\n      }, G.prototype.receivedFocus = function() {\n        this.slowPoll();\n      }, G.prototype.slowPoll = function() {\n        var e = this;\n        this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {\n          e.poll(), e.cm.state.focused && e.slowPoll();\n        });\n      }, G.prototype.fastPoll = function() {\n        var e = !1, t = this;\n        t.pollingFast = !0;\n        function i() {\n          var r = t.poll();\n          !r && !e ? (e = !0, t.polling.set(60, i)) : (t.pollingFast = !1, t.slowPoll());\n        }\n        u(i, \"p\"), t.polling.set(20, i);\n      }, G.prototype.poll = function() {\n        var e = this, t = this.cm, i = this.textarea, r = this.prevInput;\n        if (this.contextMenuPending || !t.state.focused || ia(i) && !r && !this.composing || t.isReadOnly() || t.options.disableInput || t.state.keySeq)\n          return !1;\n        var n = i.value;\n        if (n == r && !t.somethingSelected())\n          return !1;\n        if (O && I >= 9 && this.hasSelection === n || me && /[\\uf700-\\uf7ff]/.test(n))\n          return t.display.input.reset(), !1;\n        if (t.doc.sel == t.display.selForContextMenu) {\n          var l = n.charCodeAt(0);\n          if (l == 8203 && !r && (r = \"​\"), l == 8666)\n            return this.reset(), this.cm.execCommand(\"undo\");\n        }\n        for (var o = 0, a = Math.min(r.length, n.length); o < a && r.charCodeAt(o) == n.charCodeAt(o); )\n          ++o;\n        return de(t, function() {\n          Sn(\n            t,\n            n.slice(o),\n            r.length - o,\n            null,\n            e.composing ? \"*compose\" : null\n          ), n.length > 1e3 || n.indexOf(`\n`) > -1 ? i.value = e.prevInput = \"\" : e.prevInput = n, e.composing && (e.composing.range.clear(), e.composing.range = t.markText(\n            e.composing.start,\n            t.getCursor(\"to\"),\n            { className: \"CodeMirror-composing\" }\n          ));\n        }), !0;\n      }, G.prototype.ensurePolled = function() {\n        this.pollingFast && this.poll() && (this.pollingFast = !1);\n      }, G.prototype.onKeyPress = function() {\n        O && I >= 9 && (this.hasSelection = null), this.fastPoll();\n      }, G.prototype.onContextMenu = function(e) {\n        var t = this, i = t.cm, r = i.display, n = t.textarea;\n        t.contextMenuPending && t.contextMenuPending();\n        var l = ft(i, e), o = r.scroller.scrollTop;\n        if (!l || we)\n          return;\n        var a = i.options.resetSelectionOnContextMenu;\n        a && i.doc.sel.contains(l) == -1 && Q(i, te)(i.doc, Ze(l), Me);\n        var s = n.style.cssText, f = t.wrapper.style.cssText, h = t.wrapper.offsetParent.getBoundingClientRect();\n        t.wrapper.style.cssText = \"position: static\", n.style.cssText = `position: absolute; width: 30px; height: 30px;\n      top: ` + (e.clientY - h.top - 5) + \"px; left: \" + (e.clientX - h.left - 5) + `px;\n      z-index: 1000; background: ` + (O ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + `;\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`;\n        var c;\n        ne && (c = window.scrollY), r.input.focus(), ne && window.scrollTo(null, c), r.input.reset(), i.somethingSelected() || (n.value = t.prevInput = \" \"), t.contextMenuPending = d, r.selForContextMenu = i.doc.sel, clearTimeout(r.detectingSelectAll);\n        function p() {\n          if (n.selectionStart != null) {\n            var g = i.somethingSelected(), m = \"​\" + (g ? n.value : \"\");\n            n.value = \"⇚\", n.value = m, t.prevInput = g ? \"\" : \"​\", n.selectionStart = 1, n.selectionEnd = m.length, r.selForContextMenu = i.doc.sel;\n          }\n        }\n        u(p, \"prepareSelectAllHack\");\n        function d() {\n          if (t.contextMenuPending == d && (t.contextMenuPending = !1, t.wrapper.style.cssText = f, n.style.cssText = s, O && I < 9 && r.scrollbars.setScrollTop(r.scroller.scrollTop = o), n.selectionStart != null)) {\n            (!O || O && I < 9) && p();\n            var g = 0, m = /* @__PURE__ */ u(function() {\n              r.selForContextMenu == i.doc.sel && n.selectionStart == 0 && n.selectionEnd > 0 && t.prevInput == \"​\" ? Q(i, lo)(i) : g++ < 10 ? r.detectingSelectAll = setTimeout(m, 500) : (r.selForContextMenu = null, r.input.reset());\n            }, \"poll\");\n            r.detectingSelectAll = setTimeout(m, 200);\n          }\n        }\n        if (u(d, \"rehide\"), O && I >= 9 && p(), ci) {\n          Qt(e);\n          var v = /* @__PURE__ */ u(function() {\n            ge(window, \"mouseup\", v), setTimeout(d, 20);\n          }, \"mouseup\");\n          M(window, \"mouseup\", v);\n        } else\n          setTimeout(d, 50);\n      }, G.prototype.readOnlyChanged = function(e) {\n        e || this.reset(), this.textarea.disabled = e == \"nocursor\", this.textarea.readOnly = !!e;\n      }, G.prototype.setUneditable = function() {\n      }, G.prototype.needsContentAttribute = !1;\n      function lu(e, t) {\n        if (t = t ? nt(t) : {}, t.value = e.value, !t.tabindex && e.tabIndex && (t.tabindex = e.tabIndex), !t.placeholder && e.placeholder && (t.placeholder = e.placeholder), t.autofocus == null) {\n          var i = be();\n          t.autofocus = i == e || e.getAttribute(\"autofocus\") != null && i == document.body;\n        }\n        function r() {\n          e.value = a.getValue();\n        }\n        u(r, \"save\");\n        var n;\n        if (e.form && (M(e.form, \"submit\", r), !t.leaveSubmitMethodAlone)) {\n          var l = e.form;\n          n = l.submit;\n          try {\n            var o = l.submit = function() {\n              r(), l.submit = n, l.submit(), l.submit = o;\n            };\n          } catch {\n          }\n        }\n        t.finishInit = function(s) {\n          s.save = r, s.getTextArea = function() {\n            return e;\n          }, s.toTextArea = function() {\n            s.toTextArea = isNaN, r(), e.parentNode.removeChild(s.getWrapperElement()), e.style.display = \"\", e.form && (ge(e.form, \"submit\", r), !t.leaveSubmitMethodAlone && typeof e.form.submit == \"function\" && (e.form.submit = n));\n          };\n        }, e.style.display = \"none\";\n        var a = R(\n          function(s) {\n            return e.parentNode.insertBefore(s, e.nextSibling);\n          },\n          t\n        );\n        return a;\n      }\n      u(lu, \"fromTextArea\");\n      function ou(e) {\n        e.off = ge, e.on = M, e.wheelEventPixels = ds, e.Doc = ue, e.splitLines = ki, e.countColumn = xe, e.findColumn = gi, e.isWordChar = mi, e.Pass = Nr, e.signal = U, e.Line = St, e.changeEnd = Qe, e.scrollbarModel = Pl, e.Pos = y, e.cmpPos = D, e.modes = Mi, e.mimeModes = Ct, e.resolveMode = Hr, e.getMode = Di, e.modeExtensions = wt, e.extendMode = sa, e.copyState = lt, e.startState = Gn, e.innerMode = Ni, e.commands = br, e.keyMap = ze, e.keyName = wo, e.isModifierKey = xo, e.lookupKey = Et, e.normalizeKeyMap = Ps, e.StringStream = K, e.SharedTextMarker = gr, e.TextMarker = je, e.LineWidget = vr, e.e_preventDefault = ae, e.e_stopPropagation = Bn, e.e_stop = Qt, e.addClass = it, e.contains = Ke, e.rmClass = tt, e.keyNames = Ve;\n      }\n      u(ou, \"addLegacyProps\"), js(R), tu(R);\n      var au = \"iter insert remove copy getEditor constructor\".split(\" \");\n      for (var hi in ue.prototype)\n        ue.prototype.hasOwnProperty(hi) && ee(au, hi) < 0 && (R.prototype[hi] = function(e) {\n          return function() {\n            return e.apply(this.doc, arguments);\n          };\n        }(ue.prototype[hi]));\n      return xt(ue), R.inputStyles = { textarea: G, contenteditable: P }, R.defineMode = function(e) {\n        !R.defaults.mode && e != \"null\" && (R.defaults.mode = e), oa.apply(this, arguments);\n      }, R.defineMIME = aa, R.defineMode(\"null\", function() {\n        return { token: function(e) {\n          return e.skipToEnd();\n        } };\n      }), R.defineMIME(\"text/plain\", \"null\"), R.defineExtension = function(e, t) {\n        R.prototype[e] = t;\n      }, R.defineDocExtension = function(e, t) {\n        ue.prototype[e] = t;\n      }, R.fromTextArea = lu, ou(R), R.version = \"5.65.3\", R;\n    });\n  }(Mn)), Mn.exports;\n}\nu(cu, \"requireCodemirror\");\n\n//# sourceMappingURL=codemirror.es2.js.map\n\n\n//# sourceURL=webpack://www/./node_modules/@graphiql/react/dist/codemirror.es2.js?");

/***/ })

}]);