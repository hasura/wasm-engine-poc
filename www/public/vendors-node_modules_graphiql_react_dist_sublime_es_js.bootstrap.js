"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwww"] = self["webpackChunkwww"] || []).push([["vendors-node_modules_graphiql_react_dist_sublime_es_js"],{

/***/ "./node_modules/@graphiql/react/dist/matchbrackets.es2.js":
/*!****************************************************************!*\
  !*** ./node_modules/@graphiql/react/dist/matchbrackets.es2.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   r: () => (/* binding */ j)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codemirror.es2.js */ \"./node_modules/@graphiql/react/dist/codemirror.es2.js\");\nvar R = Object.defineProperty;\nvar f = (L, y) => R(L, \"name\", { value: y, configurable: !0 });\n\nvar T = { exports: {} }, E;\nfunction j() {\n  return E || (E = 1, function(L, y) {\n    (function(o) {\n      o((0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.r)());\n    })(function(o) {\n      var S = /MSIE \\d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8), g = o.Pos, p = { \"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\" };\n      function A(t) {\n        return t && t.bracketRegex || /[(){}[\\]]/;\n      }\n      f(A, \"bracketRegex\");\n      function b(t, r, e) {\n        var i = t.getLineHandle(r.line), n = r.ch - 1, l = e && e.afterCursor;\n        l == null && (l = /(^| )cm-fat-cursor($| )/.test(t.getWrapperElement().className));\n        var h = A(e), u = !l && n >= 0 && h.test(i.text.charAt(n)) && p[i.text.charAt(n)] || h.test(i.text.charAt(n + 1)) && p[i.text.charAt(++n)];\n        if (!u)\n          return null;\n        var a = u.charAt(1) == \">\" ? 1 : -1;\n        if (e && e.strict && a > 0 != (n == r.ch))\n          return null;\n        var k = t.getTokenTypeAt(g(r.line, n + 1)), s = H(t, g(r.line, n + (a > 0 ? 1 : 0)), a, k, e);\n        return s == null ? null : {\n          from: g(r.line, n),\n          to: s && s.pos,\n          match: s && s.ch == u.charAt(0),\n          forward: a > 0\n        };\n      }\n      f(b, \"findMatchingBracket\");\n      function H(t, r, e, i, n) {\n        for (var l = n && n.maxScanLineLength || 1e4, h = n && n.maxScanLines || 1e3, u = [], a = A(n), k = e > 0 ? Math.min(r.line + h, t.lastLine() + 1) : Math.max(t.firstLine() - 1, r.line - h), s = r.line; s != k; s += e) {\n          var c = t.getLine(s);\n          if (c) {\n            var v = e > 0 ? 0 : c.length - 1, q = e > 0 ? c.length : -1;\n            if (!(c.length > l))\n              for (s == r.line && (v = r.ch - (e < 0 ? 1 : 0)); v != q; v += e) {\n                var d = c.charAt(v);\n                if (a.test(d) && (i === void 0 || (t.getTokenTypeAt(g(s, v + 1)) || \"\") == (i || \"\"))) {\n                  var m = p[d];\n                  if (m && m.charAt(1) == \">\" == e > 0)\n                    u.push(d);\n                  else if (u.length)\n                    u.pop();\n                  else\n                    return { pos: g(s, v), ch: d };\n                }\n              }\n          }\n        }\n        return s - e == (e > 0 ? t.lastLine() : t.firstLine()) ? !1 : null;\n      }\n      f(H, \"scanForBracket\");\n      function M(t, r, e) {\n        for (var i = t.state.matchBrackets.maxHighlightLineLength || 1e3, n = e && e.highlightNonMatching, l = [], h = t.listSelections(), u = 0; u < h.length; u++) {\n          var a = h[u].empty() && b(t, h[u].head, e);\n          if (a && (a.match || n !== !1) && t.getLine(a.from.line).length <= i) {\n            var k = a.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n            l.push(t.markText(a.from, g(a.from.line, a.from.ch + 1), { className: k })), a.to && t.getLine(a.to.line).length <= i && l.push(t.markText(a.to, g(a.to.line, a.to.ch + 1), { className: k }));\n          }\n        }\n        if (l.length) {\n          S && t.state.focused && t.focus();\n          var s = /* @__PURE__ */ f(function() {\n            t.operation(function() {\n              for (var c = 0; c < l.length; c++)\n                l[c].clear();\n            });\n          }, \"clear\");\n          if (r)\n            setTimeout(s, 800);\n          else\n            return s;\n        }\n      }\n      f(M, \"matchBrackets\");\n      function x(t) {\n        t.operation(function() {\n          t.state.matchBrackets.currentlyHighlighted && (t.state.matchBrackets.currentlyHighlighted(), t.state.matchBrackets.currentlyHighlighted = null), t.state.matchBrackets.currentlyHighlighted = M(t, !1, t.state.matchBrackets);\n        });\n      }\n      f(x, \"doMatchBrackets\");\n      function B(t) {\n        t.state.matchBrackets && t.state.matchBrackets.currentlyHighlighted && (t.state.matchBrackets.currentlyHighlighted(), t.state.matchBrackets.currentlyHighlighted = null);\n      }\n      f(B, \"clearHighlighted\"), o.defineOption(\"matchBrackets\", !1, function(t, r, e) {\n        e && e != o.Init && (t.off(\"cursorActivity\", x), t.off(\"focus\", x), t.off(\"blur\", B), B(t)), r && (t.state.matchBrackets = typeof r == \"object\" ? r : {}, t.on(\"cursorActivity\", x), t.on(\"focus\", x), t.on(\"blur\", B));\n      }), o.defineExtension(\"matchBrackets\", function() {\n        M(this, !0);\n      }), o.defineExtension(\"findMatchingBracket\", function(t, r, e) {\n        return (e || typeof r == \"boolean\") && (e ? (e.strict = r, r = e) : r = r ? { strict: !0 } : null), b(this, t, r);\n      }), o.defineExtension(\"scanForBracket\", function(t, r, e, i) {\n        return H(this, t, r, e, i);\n      });\n    });\n  }()), T.exports;\n}\nf(j, \"requireMatchbrackets\");\n\n//# sourceMappingURL=matchbrackets.es2.js.map\n\n\n//# sourceURL=webpack://www/./node_modules/@graphiql/react/dist/matchbrackets.es2.js?");

/***/ }),

/***/ "./node_modules/@graphiql/react/dist/searchcursor.es2.js":
/*!***************************************************************!*\
  !*** ./node_modules/@graphiql/react/dist/searchcursor.es2.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   r: () => (/* binding */ K)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codemirror.es2.js */ \"./node_modules/@graphiql/react/dist/codemirror.es2.js\");\nvar W = Object.defineProperty;\nvar o = (d, E) => W(d, \"name\", { value: E, configurable: !0 });\n\nvar N = { exports: {} }, b;\nfunction K() {\n  return b || (b = 1, function(d, E) {\n    (function(m) {\n      m((0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.r)());\n    })(function(m) {\n      var s = m.Pos;\n      function B(e) {\n        var t = e.flags;\n        return t ?? (e.ignoreCase ? \"i\" : \"\") + (e.global ? \"g\" : \"\") + (e.multiline ? \"m\" : \"\");\n      }\n      o(B, \"regexpFlags\");\n      function F(e, t) {\n        for (var n = B(e), r = n, l = 0; l < t.length; l++)\n          r.indexOf(t.charAt(l)) == -1 && (r += t.charAt(l));\n        return n == r ? e : new RegExp(e.source, r);\n      }\n      o(F, \"ensureFlags\");\n      function R(e) {\n        return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(e.source);\n      }\n      o(R, \"maybeMultiline\");\n      function I(e, t, n) {\n        t = F(t, \"g\");\n        for (var r = n.line, l = n.ch, i = e.lastLine(); r <= i; r++, l = 0) {\n          t.lastIndex = l;\n          var h = e.getLine(r), f = t.exec(h);\n          if (f)\n            return {\n              from: s(r, f.index),\n              to: s(r, f.index + f[0].length),\n              match: f\n            };\n        }\n      }\n      o(I, \"searchRegexpForward\");\n      function j(e, t, n) {\n        if (!R(t))\n          return I(e, t, n);\n        t = F(t, \"gm\");\n        for (var r, l = 1, i = n.line, h = e.lastLine(); i <= h; ) {\n          for (var f = 0; f < l && !(i > h); f++) {\n            var p = e.getLine(i++);\n            r = r == null ? p : r + `\n` + p;\n          }\n          l = l * 2, t.lastIndex = n.ch;\n          var u = t.exec(r);\n          if (u) {\n            var a = r.slice(0, u.index).split(`\n`), c = u[0].split(`\n`), g = n.line + a.length - 1, v = a[a.length - 1].length;\n            return {\n              from: s(g, v),\n              to: s(\n                g + c.length - 1,\n                c.length == 1 ? v + c[0].length : c[c.length - 1].length\n              ),\n              match: u\n            };\n          }\n        }\n      }\n      o(j, \"searchRegexpForwardMultiline\");\n      function z(e, t, n) {\n        for (var r, l = 0; l <= e.length; ) {\n          t.lastIndex = l;\n          var i = t.exec(e);\n          if (!i)\n            break;\n          var h = i.index + i[0].length;\n          if (h > e.length - n)\n            break;\n          (!r || h > r.index + r[0].length) && (r = i), l = i.index + 1;\n        }\n        return r;\n      }\n      o(z, \"lastMatchIn\");\n      function D(e, t, n) {\n        t = F(t, \"g\");\n        for (var r = n.line, l = n.ch, i = e.firstLine(); r >= i; r--, l = -1) {\n          var h = e.getLine(r), f = z(h, t, l < 0 ? 0 : h.length - l);\n          if (f)\n            return {\n              from: s(r, f.index),\n              to: s(r, f.index + f[0].length),\n              match: f\n            };\n        }\n      }\n      o(D, \"searchRegexpBackward\");\n      function A(e, t, n) {\n        if (!R(t))\n          return D(e, t, n);\n        t = F(t, \"gm\");\n        for (var r, l = 1, i = e.getLine(n.line).length - n.ch, h = n.line, f = e.firstLine(); h >= f; ) {\n          for (var p = 0; p < l && h >= f; p++) {\n            var u = e.getLine(h--);\n            r = r == null ? u : u + `\n` + r;\n          }\n          l *= 2;\n          var a = z(r, t, i);\n          if (a) {\n            var c = r.slice(0, a.index).split(`\n`), g = a[0].split(`\n`), v = h + c.length, x = c[c.length - 1].length;\n            return {\n              from: s(v, x),\n              to: s(\n                v + g.length - 1,\n                g.length == 1 ? x + g[0].length : g[g.length - 1].length\n              ),\n              match: a\n            };\n          }\n        }\n      }\n      o(A, \"searchRegexpBackwardMultiline\");\n      var P, k;\n      String.prototype.normalize ? (P = /* @__PURE__ */ o(function(e) {\n        return e.normalize(\"NFD\").toLowerCase();\n      }, \"doFold\"), k = /* @__PURE__ */ o(function(e) {\n        return e.normalize(\"NFD\");\n      }, \"noFold\")) : (P = /* @__PURE__ */ o(function(e) {\n        return e.toLowerCase();\n      }, \"doFold\"), k = /* @__PURE__ */ o(function(e) {\n        return e;\n      }, \"noFold\"));\n      function L(e, t, n, r) {\n        if (e.length == t.length)\n          return n;\n        for (var l = 0, i = n + Math.max(0, e.length - t.length); ; ) {\n          if (l == i)\n            return l;\n          var h = l + i >> 1, f = r(e.slice(0, h)).length;\n          if (f == n)\n            return h;\n          f > n ? i = h : l = h + 1;\n        }\n      }\n      o(L, \"adjustPos\");\n      function y(e, t, n, r) {\n        if (!t.length)\n          return null;\n        var l = r ? P : k, i = l(t).split(/\\r|\\n\\r?/);\n        t:\n          for (var h = n.line, f = n.ch, p = e.lastLine() + 1 - i.length; h <= p; h++, f = 0) {\n            var u = e.getLine(h).slice(f), a = l(u);\n            if (i.length == 1) {\n              var c = a.indexOf(i[0]);\n              if (c == -1)\n                continue t;\n              var n = L(u, a, c, l) + f;\n              return {\n                from: s(h, L(u, a, c, l) + f),\n                to: s(h, L(u, a, c + i[0].length, l) + f)\n              };\n            } else {\n              var g = a.length - i[0].length;\n              if (a.slice(g) != i[0])\n                continue t;\n              for (var v = 1; v < i.length - 1; v++)\n                if (l(e.getLine(h + v)) != i[v])\n                  continue t;\n              var x = e.getLine(h + i.length - 1), O = l(x), S = i[i.length - 1];\n              if (O.slice(0, S.length) != S)\n                continue t;\n              return {\n                from: s(h, L(u, a, g, l) + f),\n                to: s(h + i.length - 1, L(x, O, S.length, l))\n              };\n            }\n          }\n      }\n      o(y, \"searchStringForward\");\n      function C(e, t, n, r) {\n        if (!t.length)\n          return null;\n        var l = r ? P : k, i = l(t).split(/\\r|\\n\\r?/);\n        t:\n          for (var h = n.line, f = n.ch, p = e.firstLine() - 1 + i.length; h >= p; h--, f = -1) {\n            var u = e.getLine(h);\n            f > -1 && (u = u.slice(0, f));\n            var a = l(u);\n            if (i.length == 1) {\n              var c = a.lastIndexOf(i[0]);\n              if (c == -1)\n                continue t;\n              return {\n                from: s(h, L(u, a, c, l)),\n                to: s(h, L(u, a, c + i[0].length, l))\n              };\n            } else {\n              var g = i[i.length - 1];\n              if (a.slice(0, g.length) != g)\n                continue t;\n              for (var v = 1, n = h - i.length + 1; v < i.length - 1; v++)\n                if (l(e.getLine(n + v)) != i[v])\n                  continue t;\n              var x = e.getLine(h + 1 - i.length), O = l(x);\n              if (O.slice(O.length - i[0].length) != i[0])\n                continue t;\n              return {\n                from: s(h + 1 - i.length, L(x, O, x.length - i[0].length, l)),\n                to: s(h, L(u, a, g.length, l))\n              };\n            }\n          }\n      }\n      o(C, \"searchStringBackward\");\n      function w(e, t, n, r) {\n        this.atOccurrence = !1, this.afterEmptyMatch = !1, this.doc = e, n = n ? e.clipPos(n) : s(0, 0), this.pos = { from: n, to: n };\n        var l;\n        typeof r == \"object\" ? l = r.caseFold : (l = r, r = null), typeof t == \"string\" ? (l == null && (l = !1), this.matches = function(i, h) {\n          return (i ? C : y)(e, t, h, l);\n        }) : (t = F(t, \"gm\"), !r || r.multiline !== !1 ? this.matches = function(i, h) {\n          return (i ? A : j)(e, t, h);\n        } : this.matches = function(i, h) {\n          return (i ? D : I)(e, t, h);\n        });\n      }\n      o(w, \"SearchCursor\"), w.prototype = {\n        findNext: function() {\n          return this.find(!1);\n        },\n        findPrevious: function() {\n          return this.find(!0);\n        },\n        find: function(e) {\n          var t = this.doc.clipPos(e ? this.pos.from : this.pos.to);\n          if (this.afterEmptyMatch && this.atOccurrence && (t = s(t.line, t.ch), e ? (t.ch--, t.ch < 0 && (t.line--, t.ch = (this.doc.getLine(t.line) || \"\").length)) : (t.ch++, t.ch > (this.doc.getLine(t.line) || \"\").length && (t.ch = 0, t.line++)), m.cmpPos(t, this.doc.clipPos(t)) != 0))\n            return this.atOccurrence = !1;\n          var n = this.matches(e, t);\n          if (this.afterEmptyMatch = n && m.cmpPos(n.from, n.to) == 0, n)\n            return this.pos = n, this.atOccurrence = !0, this.pos.match || !0;\n          var r = s(e ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);\n          return this.pos = { from: r, to: r }, this.atOccurrence = !1;\n        },\n        from: function() {\n          if (this.atOccurrence)\n            return this.pos.from;\n        },\n        to: function() {\n          if (this.atOccurrence)\n            return this.pos.to;\n        },\n        replace: function(e, t) {\n          if (this.atOccurrence) {\n            var n = m.splitLines(e);\n            this.doc.replaceRange(n, this.pos.from, this.pos.to, t), this.pos.to = s(\n              this.pos.from.line + n.length - 1,\n              n[n.length - 1].length + (n.length == 1 ? this.pos.from.ch : 0)\n            );\n          }\n        }\n      }, m.defineExtension(\"getSearchCursor\", function(e, t, n) {\n        return new w(this.doc, e, t, n);\n      }), m.defineDocExtension(\"getSearchCursor\", function(e, t, n) {\n        return new w(this, e, t, n);\n      }), m.defineExtension(\"selectMatches\", function(e, t) {\n        for (var n = [], r = this.getSearchCursor(e, this.getCursor(\"from\"), t); r.findNext() && !(m.cmpPos(r.to(), this.getCursor(\"to\")) > 0); )\n          n.push({ anchor: r.from(), head: r.to() });\n        n.length && this.setSelections(n, 0);\n      });\n    });\n  }()), N.exports;\n}\no(K, \"requireSearchcursor\");\n\n//# sourceMappingURL=searchcursor.es2.js.map\n\n\n//# sourceURL=webpack://www/./node_modules/@graphiql/react/dist/searchcursor.es2.js?");

/***/ }),

/***/ "./node_modules/@graphiql/react/dist/sublime.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/@graphiql/react/dist/sublime.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   s: () => (/* binding */ te)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codemirror.es2.js */ \"./node_modules/@graphiql/react/dist/codemirror.es2.js\");\n/* harmony import */ var _searchcursor_es2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./searchcursor.es2.js */ \"./node_modules/@graphiql/react/dist/searchcursor.es2.js\");\n/* harmony import */ var _matchbrackets_es2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matchbrackets.es2.js */ \"./node_modules/@graphiql/react/dist/matchbrackets.es2.js\");\nvar V = Object.defineProperty;\nvar v = (m, B) => V(m, \"name\", { value: B, configurable: !0 });\n\n\n\nfunction G(m, B) {\n  for (var h = 0; h < B.length; h++) {\n    const a = B[h];\n    if (typeof a != \"string\" && !Array.isArray(a)) {\n      for (const f in a)\n        if (f !== \"default\" && !(f in m)) {\n          const A = Object.getOwnPropertyDescriptor(a, f);\n          A && Object.defineProperty(m, f, A.get ? A : {\n            enumerable: !0,\n            get: () => a[f]\n          });\n        }\n    }\n  }\n  return Object.freeze(Object.defineProperty(m, Symbol.toStringTag, { value: \"Module\" }));\n}\nv(G, \"_mergeNamespaces\");\nvar Q = { exports: {} };\n(function(m, B) {\n  (function(h) {\n    h((0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.r)(), (0,_searchcursor_es2_js__WEBPACK_IMPORTED_MODULE_1__.r)(), (0,_matchbrackets_es2_js__WEBPACK_IMPORTED_MODULE_2__.r)());\n  })(function(h) {\n    var a = h.commands, f = h.Pos;\n    function A(e, t, n) {\n      if (n < 0 && t.ch == 0)\n        return e.clipPos(f(t.line - 1));\n      var r = e.getLine(t.line);\n      if (n > 0 && t.ch >= r.length)\n        return e.clipPos(f(t.line + 1, 0));\n      for (var l = \"start\", i, o = t.ch, s = o, u = n < 0 ? 0 : r.length, d = 0; s != u; s += n, d++) {\n        var p = r.charAt(n < 0 ? s - 1 : s), c = p != \"_\" && h.isWordChar(p) ? \"w\" : \"o\";\n        if (c == \"w\" && p.toUpperCase() == p && (c = \"W\"), l == \"start\")\n          c != \"o\" ? (l = \"in\", i = c) : o = s + n;\n        else if (l == \"in\" && i != c) {\n          if (i == \"w\" && c == \"W\" && n < 0 && s--, i == \"W\" && c == \"w\" && n > 0)\n            if (s == o + 1) {\n              i = \"w\";\n              continue;\n            } else\n              s--;\n          break;\n        }\n      }\n      return f(t.line, s);\n    }\n    v(A, \"findPosSubword\");\n    function F(e, t) {\n      e.extendSelectionsBy(function(n) {\n        return e.display.shift || e.doc.extend || n.empty() ? A(e.doc, n.head, t) : t < 0 ? n.from() : n.to();\n      });\n    }\n    v(F, \"moveSubword\"), a.goSubwordLeft = function(e) {\n      F(e, -1);\n    }, a.goSubwordRight = function(e) {\n      F(e, 1);\n    }, a.scrollLineUp = function(e) {\n      var t = e.getScrollInfo();\n      if (!e.somethingSelected()) {\n        var n = e.lineAtHeight(t.top + t.clientHeight, \"local\");\n        e.getCursor().line >= n && e.execCommand(\"goLineUp\");\n      }\n      e.scrollTo(null, t.top - e.defaultTextHeight());\n    }, a.scrollLineDown = function(e) {\n      var t = e.getScrollInfo();\n      if (!e.somethingSelected()) {\n        var n = e.lineAtHeight(t.top, \"local\") + 1;\n        e.getCursor().line <= n && e.execCommand(\"goLineDown\");\n      }\n      e.scrollTo(null, t.top + e.defaultTextHeight());\n    }, a.splitSelectionByLine = function(e) {\n      for (var t = e.listSelections(), n = [], r = 0; r < t.length; r++)\n        for (var l = t[r].from(), i = t[r].to(), o = l.line; o <= i.line; ++o)\n          i.line > l.line && o == i.line && i.ch == 0 || n.push({\n            anchor: o == l.line ? l : f(o, 0),\n            head: o == i.line ? i : f(o)\n          });\n      e.setSelections(n, 0);\n    }, a.singleSelectionTop = function(e) {\n      var t = e.listSelections()[0];\n      e.setSelection(t.anchor, t.head, { scroll: !1 });\n    }, a.selectLine = function(e) {\n      for (var t = e.listSelections(), n = [], r = 0; r < t.length; r++) {\n        var l = t[r];\n        n.push({\n          anchor: f(l.from().line, 0),\n          head: f(l.to().line + 1, 0)\n        });\n      }\n      e.setSelections(n);\n    };\n    function T(e, t) {\n      if (e.isReadOnly())\n        return h.Pass;\n      e.operation(function() {\n        for (var n = e.listSelections().length, r = [], l = -1, i = 0; i < n; i++) {\n          var o = e.listSelections()[i].head;\n          if (!(o.line <= l)) {\n            var s = f(o.line + (t ? 0 : 1), 0);\n            e.replaceRange(`\n`, s, null, \"+insertLine\"), e.indentLine(s.line, null, !0), r.push({ head: s, anchor: s }), l = o.line + 1;\n          }\n        }\n        e.setSelections(r);\n      }), e.execCommand(\"indentAuto\");\n    }\n    v(T, \"insertLine\"), a.insertLineAfter = function(e) {\n      return T(e, !1);\n    }, a.insertLineBefore = function(e) {\n      return T(e, !0);\n    };\n    function K(e, t) {\n      for (var n = t.ch, r = n, l = e.getLine(t.line); n && h.isWordChar(l.charAt(n - 1)); )\n        --n;\n      for (; r < l.length && h.isWordChar(l.charAt(r)); )\n        ++r;\n      return { from: f(t.line, n), to: f(t.line, r), word: l.slice(n, r) };\n    }\n    v(K, \"wordAt\"), a.selectNextOccurrence = function(e) {\n      var t = e.getCursor(\"from\"), n = e.getCursor(\"to\"), r = e.state.sublimeFindFullWord == e.doc.sel;\n      if (h.cmpPos(t, n) == 0) {\n        var l = K(e, t);\n        if (!l.word)\n          return;\n        e.setSelection(l.from, l.to), r = !0;\n      } else {\n        var i = e.getRange(t, n), o = r ? new RegExp(\"\\\\b\" + i + \"\\\\b\") : i, s = e.getSearchCursor(o, n), u = s.findNext();\n        if (u || (s = e.getSearchCursor(o, f(e.firstLine(), 0)), u = s.findNext()), !u || H(e.listSelections(), s.from(), s.to()))\n          return;\n        e.addSelection(s.from(), s.to());\n      }\n      r && (e.state.sublimeFindFullWord = e.doc.sel);\n    }, a.skipAndSelectNextOccurrence = function(e) {\n      var t = e.getCursor(\"anchor\"), n = e.getCursor(\"head\");\n      a.selectNextOccurrence(e), h.cmpPos(t, n) != 0 && e.doc.setSelections(e.doc.listSelections().filter(function(r) {\n        return r.anchor != t || r.head != n;\n      }));\n    };\n    function y(e, t) {\n      for (var n = e.listSelections(), r = [], l = 0; l < n.length; l++) {\n        var i = n[l], o = e.findPosV(\n          i.anchor,\n          t,\n          \"line\",\n          i.anchor.goalColumn\n        ), s = e.findPosV(\n          i.head,\n          t,\n          \"line\",\n          i.head.goalColumn\n        );\n        o.goalColumn = i.anchor.goalColumn != null ? i.anchor.goalColumn : e.cursorCoords(i.anchor, \"div\").left, s.goalColumn = i.head.goalColumn != null ? i.head.goalColumn : e.cursorCoords(i.head, \"div\").left;\n        var u = { anchor: o, head: s };\n        r.push(i), r.push(u);\n      }\n      e.setSelections(r);\n    }\n    v(y, \"addCursorToSelection\"), a.addCursorToPrevLine = function(e) {\n      y(e, -1);\n    }, a.addCursorToNextLine = function(e) {\n      y(e, 1);\n    };\n    function H(e, t, n) {\n      for (var r = 0; r < e.length; r++)\n        if (h.cmpPos(e[r].from(), t) == 0 && h.cmpPos(e[r].to(), n) == 0)\n          return !0;\n      return !1;\n    }\n    v(H, \"isSelectedRange\");\n    var P = \"(){}[]\";\n    function U(e) {\n      for (var t = e.listSelections(), n = [], r = 0; r < t.length; r++) {\n        var l = t[r], i = l.head, o = e.scanForBracket(i, -1);\n        if (!o)\n          return !1;\n        for (; ; ) {\n          var s = e.scanForBracket(i, 1);\n          if (!s)\n            return !1;\n          if (s.ch == P.charAt(P.indexOf(o.ch) + 1)) {\n            var u = f(o.pos.line, o.pos.ch + 1);\n            if (h.cmpPos(u, l.from()) == 0 && h.cmpPos(s.pos, l.to()) == 0) {\n              if (o = e.scanForBracket(o.pos, -1), !o)\n                return !1;\n            } else {\n              n.push({ anchor: u, head: s.pos });\n              break;\n            }\n          }\n          i = f(s.pos.line, s.pos.ch + 1);\n        }\n      }\n      return e.setSelections(n), !0;\n    }\n    v(U, \"selectBetweenBrackets\"), a.selectScope = function(e) {\n      U(e) || e.execCommand(\"selectAll\");\n    }, a.selectBetweenBrackets = function(e) {\n      if (!U(e))\n        return h.Pass;\n    };\n    function I(e) {\n      return e ? /\\bpunctuation\\b/.test(e) ? e : void 0 : null;\n    }\n    v(I, \"puncType\"), a.goToBracket = function(e) {\n      e.extendSelectionsBy(function(t) {\n        var n = e.scanForBracket(t.head, 1, I(e.getTokenTypeAt(t.head)));\n        if (n && h.cmpPos(n.pos, t.head) != 0)\n          return n.pos;\n        var r = e.scanForBracket(t.head, -1, I(e.getTokenTypeAt(f(t.head.line, t.head.ch + 1))));\n        return r && f(r.pos.line, r.pos.ch + 1) || t.head;\n      });\n    }, a.swapLineUp = function(e) {\n      if (e.isReadOnly())\n        return h.Pass;\n      for (var t = e.listSelections(), n = [], r = e.firstLine() - 1, l = [], i = 0; i < t.length; i++) {\n        var o = t[i], s = o.from().line - 1, u = o.to().line;\n        l.push({\n          anchor: f(o.anchor.line - 1, o.anchor.ch),\n          head: f(o.head.line - 1, o.head.ch)\n        }), o.to().ch == 0 && !o.empty() && --u, s > r ? n.push(s, u) : n.length && (n[n.length - 1] = u), r = u;\n      }\n      e.operation(function() {\n        for (var d = 0; d < n.length; d += 2) {\n          var p = n[d], c = n[d + 1], b = e.getLine(p);\n          e.replaceRange(\"\", f(p, 0), f(p + 1, 0), \"+swapLine\"), c > e.lastLine() ? e.replaceRange(`\n` + b, f(e.lastLine()), null, \"+swapLine\") : e.replaceRange(b + `\n`, f(c, 0), null, \"+swapLine\");\n        }\n        e.setSelections(l), e.scrollIntoView();\n      });\n    }, a.swapLineDown = function(e) {\n      if (e.isReadOnly())\n        return h.Pass;\n      for (var t = e.listSelections(), n = [], r = e.lastLine() + 1, l = t.length - 1; l >= 0; l--) {\n        var i = t[l], o = i.to().line + 1, s = i.from().line;\n        i.to().ch == 0 && !i.empty() && o--, o < r ? n.push(o, s) : n.length && (n[n.length - 1] = s), r = s;\n      }\n      e.operation(function() {\n        for (var u = n.length - 2; u >= 0; u -= 2) {\n          var d = n[u], p = n[u + 1], c = e.getLine(d);\n          d == e.lastLine() ? e.replaceRange(\"\", f(d - 1), f(d), \"+swapLine\") : e.replaceRange(\"\", f(d, 0), f(d + 1, 0), \"+swapLine\"), e.replaceRange(c + `\n`, f(p, 0), null, \"+swapLine\");\n        }\n        e.scrollIntoView();\n      });\n    }, a.toggleCommentIndented = function(e) {\n      e.toggleComment({ indent: !0 });\n    }, a.joinLines = function(e) {\n      for (var t = e.listSelections(), n = [], r = 0; r < t.length; r++) {\n        for (var l = t[r], i = l.from(), o = i.line, s = l.to().line; r < t.length - 1 && t[r + 1].from().line == s; )\n          s = t[++r].to().line;\n        n.push({ start: o, end: s, anchor: !l.empty() && i });\n      }\n      e.operation(function() {\n        for (var u = 0, d = [], p = 0; p < n.length; p++) {\n          for (var c = n[p], b = c.anchor && f(c.anchor.line - u, c.anchor.ch), w, g = c.start; g <= c.end; g++) {\n            var S = g - u;\n            g == c.end && (w = f(S, e.getLine(S).length + 1)), S < e.lastLine() && (e.replaceRange(\" \", f(S), f(S + 1, /^\\s*/.exec(e.getLine(S + 1))[0].length)), ++u);\n          }\n          d.push({ anchor: b || w, head: w });\n        }\n        e.setSelections(d, 0);\n      });\n    }, a.duplicateLine = function(e) {\n      e.operation(function() {\n        for (var t = e.listSelections().length, n = 0; n < t; n++) {\n          var r = e.listSelections()[n];\n          r.empty() ? e.replaceRange(e.getLine(r.head.line) + `\n`, f(r.head.line, 0)) : e.replaceRange(e.getRange(r.from(), r.to()), r.from());\n        }\n        e.scrollIntoView();\n      });\n    };\n    function R(e, t, n) {\n      if (e.isReadOnly())\n        return h.Pass;\n      for (var r = e.listSelections(), l = [], i, o = 0; o < r.length; o++) {\n        var s = r[o];\n        if (!s.empty()) {\n          for (var u = s.from().line, d = s.to().line; o < r.length - 1 && r[o + 1].from().line == d; )\n            d = r[++o].to().line;\n          r[o].to().ch || d--, l.push(u, d);\n        }\n      }\n      l.length ? i = !0 : l.push(e.firstLine(), e.lastLine()), e.operation(function() {\n        for (var p = [], c = 0; c < l.length; c += 2) {\n          var b = l[c], w = l[c + 1], g = f(b, 0), S = f(w), x = e.getRange(g, S, !1);\n          t ? x.sort(function(k, L) {\n            return k < L ? -n : k == L ? 0 : n;\n          }) : x.sort(function(k, L) {\n            var W = k.toUpperCase(), M = L.toUpperCase();\n            return W != M && (k = W, L = M), k < L ? -n : k == L ? 0 : n;\n          }), e.replaceRange(x, g, S), i && p.push({ anchor: g, head: f(w + 1, 0) });\n        }\n        i && e.setSelections(p, 0);\n      });\n    }\n    v(R, \"sortLines\"), a.sortLines = function(e) {\n      R(e, !0, 1);\n    }, a.reverseSortLines = function(e) {\n      R(e, !0, -1);\n    }, a.sortLinesInsensitive = function(e) {\n      R(e, !1, 1);\n    }, a.reverseSortLinesInsensitive = function(e) {\n      R(e, !1, -1);\n    }, a.nextBookmark = function(e) {\n      var t = e.state.sublimeBookmarks;\n      if (t)\n        for (; t.length; ) {\n          var n = t.shift(), r = n.find();\n          if (r)\n            return t.push(n), e.setSelection(r.from, r.to);\n        }\n    }, a.prevBookmark = function(e) {\n      var t = e.state.sublimeBookmarks;\n      if (t)\n        for (; t.length; ) {\n          t.unshift(t.pop());\n          var n = t[t.length - 1].find();\n          if (!n)\n            t.pop();\n          else\n            return e.setSelection(n.from, n.to);\n        }\n    }, a.toggleBookmark = function(e) {\n      for (var t = e.listSelections(), n = e.state.sublimeBookmarks || (e.state.sublimeBookmarks = []), r = 0; r < t.length; r++) {\n        for (var l = t[r].from(), i = t[r].to(), o = t[r].empty() ? e.findMarksAt(l) : e.findMarks(l, i), s = 0; s < o.length; s++)\n          if (o[s].sublimeBookmark) {\n            o[s].clear();\n            for (var u = 0; u < n.length; u++)\n              n[u] == o[s] && n.splice(u--, 1);\n            break;\n          }\n        s == o.length && n.push(e.markText(l, i, { sublimeBookmark: !0, clearWhenEmpty: !1 }));\n      }\n    }, a.clearBookmarks = function(e) {\n      var t = e.state.sublimeBookmarks;\n      if (t)\n        for (var n = 0; n < t.length; n++)\n          t[n].clear();\n      t.length = 0;\n    }, a.selectBookmarks = function(e) {\n      var t = e.state.sublimeBookmarks, n = [];\n      if (t)\n        for (var r = 0; r < t.length; r++) {\n          var l = t[r].find();\n          l ? n.push({ anchor: l.from, head: l.to }) : t.splice(r--, 0);\n        }\n      n.length && e.setSelections(n, 0);\n    };\n    function D(e, t) {\n      e.operation(function() {\n        for (var n = e.listSelections(), r = [], l = [], i = 0; i < n.length; i++) {\n          var o = n[i];\n          o.empty() ? (r.push(i), l.push(\"\")) : l.push(t(e.getRange(o.from(), o.to())));\n        }\n        e.replaceSelections(l, \"around\", \"case\");\n        for (var i = r.length - 1, s; i >= 0; i--) {\n          var o = n[r[i]];\n          if (!(s && h.cmpPos(o.head, s) > 0)) {\n            var u = K(e, o.head);\n            s = u.from, e.replaceRange(t(u.word), u.from, u.to);\n          }\n        }\n      });\n    }\n    v(D, \"modifyWordOrSelection\"), a.smartBackspace = function(e) {\n      if (e.somethingSelected())\n        return h.Pass;\n      e.operation(function() {\n        for (var t = e.listSelections(), n = e.getOption(\"indentUnit\"), r = t.length - 1; r >= 0; r--) {\n          var l = t[r].head, i = e.getRange({ line: l.line, ch: 0 }, l), o = h.countColumn(i, null, e.getOption(\"tabSize\")), s = e.findPosH(l, -1, \"char\", !1);\n          if (i && !/\\S/.test(i) && o % n == 0) {\n            var u = new f(\n              l.line,\n              h.findColumn(i, o - n, n)\n            );\n            u.ch != l.ch && (s = u);\n          }\n          e.replaceRange(\"\", s, l, \"+delete\");\n        }\n      });\n    }, a.delLineRight = function(e) {\n      e.operation(function() {\n        for (var t = e.listSelections(), n = t.length - 1; n >= 0; n--)\n          e.replaceRange(\"\", t[n].anchor, f(t[n].to().line), \"+delete\");\n        e.scrollIntoView();\n      });\n    }, a.upcaseAtCursor = function(e) {\n      D(e, function(t) {\n        return t.toUpperCase();\n      });\n    }, a.downcaseAtCursor = function(e) {\n      D(e, function(t) {\n        return t.toLowerCase();\n      });\n    }, a.setSublimeMark = function(e) {\n      e.state.sublimeMark && e.state.sublimeMark.clear(), e.state.sublimeMark = e.setBookmark(e.getCursor());\n    }, a.selectToSublimeMark = function(e) {\n      var t = e.state.sublimeMark && e.state.sublimeMark.find();\n      t && e.setSelection(e.getCursor(), t);\n    }, a.deleteToSublimeMark = function(e) {\n      var t = e.state.sublimeMark && e.state.sublimeMark.find();\n      if (t) {\n        var n = e.getCursor(), r = t;\n        if (h.cmpPos(n, r) > 0) {\n          var l = r;\n          r = n, n = l;\n        }\n        e.state.sublimeKilled = e.getRange(n, r), e.replaceRange(\"\", n, r);\n      }\n    }, a.swapWithSublimeMark = function(e) {\n      var t = e.state.sublimeMark && e.state.sublimeMark.find();\n      t && (e.state.sublimeMark.clear(), e.state.sublimeMark = e.setBookmark(e.getCursor()), e.setCursor(t));\n    }, a.sublimeYank = function(e) {\n      e.state.sublimeKilled != null && e.replaceSelection(e.state.sublimeKilled, null, \"paste\");\n    }, a.showInCenter = function(e) {\n      var t = e.cursorCoords(null, \"local\");\n      e.scrollTo(null, (t.top + t.bottom) / 2 - e.getScrollInfo().clientHeight / 2);\n    };\n    function N(e) {\n      var t = e.getCursor(\"from\"), n = e.getCursor(\"to\");\n      if (h.cmpPos(t, n) == 0) {\n        var r = K(e, t);\n        if (!r.word)\n          return;\n        t = r.from, n = r.to;\n      }\n      return { from: t, to: n, query: e.getRange(t, n), word: r };\n    }\n    v(N, \"getTarget\");\n    function O(e, t) {\n      var n = N(e);\n      if (n) {\n        var r = n.query, l = e.getSearchCursor(r, t ? n.to : n.from);\n        (t ? l.findNext() : l.findPrevious()) ? e.setSelection(l.from(), l.to()) : (l = e.getSearchCursor(r, t ? f(e.firstLine(), 0) : e.clipPos(f(e.lastLine()))), (t ? l.findNext() : l.findPrevious()) ? e.setSelection(l.from(), l.to()) : n.word && e.setSelection(n.from, n.to));\n      }\n    }\n    v(O, \"findAndGoTo\"), a.findUnder = function(e) {\n      O(e, !0);\n    }, a.findUnderPrevious = function(e) {\n      O(e, !1);\n    }, a.findAllUnder = function(e) {\n      var t = N(e);\n      if (t) {\n        for (var n = e.getSearchCursor(t.query), r = [], l = -1; n.findNext(); )\n          r.push({ anchor: n.from(), head: n.to() }), n.from().line <= t.from.line && n.from().ch <= t.from.ch && l++;\n        e.setSelections(r, l);\n      }\n    };\n    var C = h.keyMap;\n    C.macSublime = {\n      \"Cmd-Left\": \"goLineStartSmart\",\n      \"Shift-Tab\": \"indentLess\",\n      \"Shift-Ctrl-K\": \"deleteLine\",\n      \"Alt-Q\": \"wrapLines\",\n      \"Ctrl-Left\": \"goSubwordLeft\",\n      \"Ctrl-Right\": \"goSubwordRight\",\n      \"Ctrl-Alt-Up\": \"scrollLineUp\",\n      \"Ctrl-Alt-Down\": \"scrollLineDown\",\n      \"Cmd-L\": \"selectLine\",\n      \"Shift-Cmd-L\": \"splitSelectionByLine\",\n      Esc: \"singleSelectionTop\",\n      \"Cmd-Enter\": \"insertLineAfter\",\n      \"Shift-Cmd-Enter\": \"insertLineBefore\",\n      \"Cmd-D\": \"selectNextOccurrence\",\n      \"Shift-Cmd-Space\": \"selectScope\",\n      \"Shift-Cmd-M\": \"selectBetweenBrackets\",\n      \"Cmd-M\": \"goToBracket\",\n      \"Cmd-Ctrl-Up\": \"swapLineUp\",\n      \"Cmd-Ctrl-Down\": \"swapLineDown\",\n      \"Cmd-/\": \"toggleCommentIndented\",\n      \"Cmd-J\": \"joinLines\",\n      \"Shift-Cmd-D\": \"duplicateLine\",\n      F5: \"sortLines\",\n      \"Shift-F5\": \"reverseSortLines\",\n      \"Cmd-F5\": \"sortLinesInsensitive\",\n      \"Shift-Cmd-F5\": \"reverseSortLinesInsensitive\",\n      F2: \"nextBookmark\",\n      \"Shift-F2\": \"prevBookmark\",\n      \"Cmd-F2\": \"toggleBookmark\",\n      \"Shift-Cmd-F2\": \"clearBookmarks\",\n      \"Alt-F2\": \"selectBookmarks\",\n      Backspace: \"smartBackspace\",\n      \"Cmd-K Cmd-D\": \"skipAndSelectNextOccurrence\",\n      \"Cmd-K Cmd-K\": \"delLineRight\",\n      \"Cmd-K Cmd-U\": \"upcaseAtCursor\",\n      \"Cmd-K Cmd-L\": \"downcaseAtCursor\",\n      \"Cmd-K Cmd-Space\": \"setSublimeMark\",\n      \"Cmd-K Cmd-A\": \"selectToSublimeMark\",\n      \"Cmd-K Cmd-W\": \"deleteToSublimeMark\",\n      \"Cmd-K Cmd-X\": \"swapWithSublimeMark\",\n      \"Cmd-K Cmd-Y\": \"sublimeYank\",\n      \"Cmd-K Cmd-C\": \"showInCenter\",\n      \"Cmd-K Cmd-G\": \"clearBookmarks\",\n      \"Cmd-K Cmd-Backspace\": \"delLineLeft\",\n      \"Cmd-K Cmd-1\": \"foldAll\",\n      \"Cmd-K Cmd-0\": \"unfoldAll\",\n      \"Cmd-K Cmd-J\": \"unfoldAll\",\n      \"Ctrl-Shift-Up\": \"addCursorToPrevLine\",\n      \"Ctrl-Shift-Down\": \"addCursorToNextLine\",\n      \"Cmd-F3\": \"findUnder\",\n      \"Shift-Cmd-F3\": \"findUnderPrevious\",\n      \"Alt-F3\": \"findAllUnder\",\n      \"Shift-Cmd-[\": \"fold\",\n      \"Shift-Cmd-]\": \"unfold\",\n      \"Cmd-I\": \"findIncremental\",\n      \"Shift-Cmd-I\": \"findIncrementalReverse\",\n      \"Cmd-H\": \"replace\",\n      F3: \"findNext\",\n      \"Shift-F3\": \"findPrev\",\n      fallthrough: \"macDefault\"\n    }, h.normalizeKeyMap(C.macSublime), C.pcSublime = {\n      \"Shift-Tab\": \"indentLess\",\n      \"Shift-Ctrl-K\": \"deleteLine\",\n      \"Alt-Q\": \"wrapLines\",\n      \"Ctrl-T\": \"transposeChars\",\n      \"Alt-Left\": \"goSubwordLeft\",\n      \"Alt-Right\": \"goSubwordRight\",\n      \"Ctrl-Up\": \"scrollLineUp\",\n      \"Ctrl-Down\": \"scrollLineDown\",\n      \"Ctrl-L\": \"selectLine\",\n      \"Shift-Ctrl-L\": \"splitSelectionByLine\",\n      Esc: \"singleSelectionTop\",\n      \"Ctrl-Enter\": \"insertLineAfter\",\n      \"Shift-Ctrl-Enter\": \"insertLineBefore\",\n      \"Ctrl-D\": \"selectNextOccurrence\",\n      \"Shift-Ctrl-Space\": \"selectScope\",\n      \"Shift-Ctrl-M\": \"selectBetweenBrackets\",\n      \"Ctrl-M\": \"goToBracket\",\n      \"Shift-Ctrl-Up\": \"swapLineUp\",\n      \"Shift-Ctrl-Down\": \"swapLineDown\",\n      \"Ctrl-/\": \"toggleCommentIndented\",\n      \"Ctrl-J\": \"joinLines\",\n      \"Shift-Ctrl-D\": \"duplicateLine\",\n      F9: \"sortLines\",\n      \"Shift-F9\": \"reverseSortLines\",\n      \"Ctrl-F9\": \"sortLinesInsensitive\",\n      \"Shift-Ctrl-F9\": \"reverseSortLinesInsensitive\",\n      F2: \"nextBookmark\",\n      \"Shift-F2\": \"prevBookmark\",\n      \"Ctrl-F2\": \"toggleBookmark\",\n      \"Shift-Ctrl-F2\": \"clearBookmarks\",\n      \"Alt-F2\": \"selectBookmarks\",\n      Backspace: \"smartBackspace\",\n      \"Ctrl-K Ctrl-D\": \"skipAndSelectNextOccurrence\",\n      \"Ctrl-K Ctrl-K\": \"delLineRight\",\n      \"Ctrl-K Ctrl-U\": \"upcaseAtCursor\",\n      \"Ctrl-K Ctrl-L\": \"downcaseAtCursor\",\n      \"Ctrl-K Ctrl-Space\": \"setSublimeMark\",\n      \"Ctrl-K Ctrl-A\": \"selectToSublimeMark\",\n      \"Ctrl-K Ctrl-W\": \"deleteToSublimeMark\",\n      \"Ctrl-K Ctrl-X\": \"swapWithSublimeMark\",\n      \"Ctrl-K Ctrl-Y\": \"sublimeYank\",\n      \"Ctrl-K Ctrl-C\": \"showInCenter\",\n      \"Ctrl-K Ctrl-G\": \"clearBookmarks\",\n      \"Ctrl-K Ctrl-Backspace\": \"delLineLeft\",\n      \"Ctrl-K Ctrl-1\": \"foldAll\",\n      \"Ctrl-K Ctrl-0\": \"unfoldAll\",\n      \"Ctrl-K Ctrl-J\": \"unfoldAll\",\n      \"Ctrl-Alt-Up\": \"addCursorToPrevLine\",\n      \"Ctrl-Alt-Down\": \"addCursorToNextLine\",\n      \"Ctrl-F3\": \"findUnder\",\n      \"Shift-Ctrl-F3\": \"findUnderPrevious\",\n      \"Alt-F3\": \"findAllUnder\",\n      \"Shift-Ctrl-[\": \"fold\",\n      \"Shift-Ctrl-]\": \"unfold\",\n      \"Ctrl-I\": \"findIncremental\",\n      \"Shift-Ctrl-I\": \"findIncrementalReverse\",\n      \"Ctrl-H\": \"replace\",\n      F3: \"findNext\",\n      \"Shift-F3\": \"findPrev\",\n      fallthrough: \"pcDefault\"\n    }, h.normalizeKeyMap(C.pcSublime);\n    var q = C.default == C.macDefault;\n    C.sublime = q ? C.macSublime : C.pcSublime;\n  });\n})();\nvar E = Q.exports;\nconst X = /* @__PURE__ */ (0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.g)(E), te = /* @__PURE__ */ G({\n  __proto__: null,\n  default: X\n}, [E]);\n\n//# sourceMappingURL=sublime.es.js.map\n\n\n//# sourceURL=webpack://www/./node_modules/@graphiql/react/dist/sublime.es.js?");

/***/ })

}]);