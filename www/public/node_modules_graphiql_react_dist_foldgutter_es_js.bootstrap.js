"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwww"] = self["webpackChunkwww"] || []).push([["node_modules_graphiql_react_dist_foldgutter_es_js"],{

/***/ "./node_modules/@graphiql/react/dist/foldgutter.es.js":
/*!************************************************************!*\
  !*** ./node_modules/@graphiql/react/dist/foldgutter.es.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   f: () => (/* binding */ H)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codemirror.es2.js */ \"./node_modules/@graphiql/react/dist/codemirror.es2.js\");\nvar z = Object.defineProperty;\nvar u = (O, k) => z(O, \"name\", { value: k, configurable: !0 });\n\nfunction j(O, k) {\n  for (var i = 0; i < k.length; i++) {\n    const s = k[i];\n    if (typeof s != \"string\" && !Array.isArray(s)) {\n      for (const p in s)\n        if (p !== \"default\" && !(p in O)) {\n          const w = Object.getOwnPropertyDescriptor(s, p);\n          w && Object.defineProperty(O, p, w.get ? w : {\n            enumerable: !0,\n            get: () => s[p]\n          });\n        }\n    }\n  }\n  return Object.freeze(Object.defineProperty(O, Symbol.toStringTag, { value: \"Module\" }));\n}\nu(j, \"_mergeNamespaces\");\nvar D = { exports: {} }, b = { exports: {} }, U;\nfunction V() {\n  return U || (U = 1, function(O, k) {\n    (function(i) {\n      i((0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.r)());\n    })(function(i) {\n      function s(e, o, f, a) {\n        if (f && f.call) {\n          var g = f;\n          f = null;\n        } else\n          var g = v(e, f, \"rangeFinder\");\n        typeof o == \"number\" && (o = i.Pos(o, 0));\n        var y = v(e, f, \"minFoldSize\");\n        function x(l) {\n          var r = g(e, o);\n          if (!r || r.to.line - r.from.line < y)\n            return null;\n          if (a === \"fold\")\n            return r;\n          for (var c = e.findMarksAt(r.from), h = 0; h < c.length; ++h)\n            if (c[h].__isFold) {\n              if (!l)\n                return null;\n              r.cleared = !0, c[h].clear();\n            }\n          return r;\n        }\n        u(x, \"getRange\");\n        var d = x(!0);\n        if (v(e, f, \"scanUp\"))\n          for (; !d && o.line > e.firstLine(); )\n            o = i.Pos(o.line - 1, 0), d = x(!1);\n        if (!(!d || d.cleared || a === \"unfold\")) {\n          var t = p(e, f, d);\n          i.on(t, \"mousedown\", function(l) {\n            n.clear(), i.e_preventDefault(l);\n          });\n          var n = e.markText(d.from, d.to, {\n            replacedWith: t,\n            clearOnEnter: v(e, f, \"clearOnEnter\"),\n            __isFold: !0\n          });\n          n.on(\"clear\", function(l, r) {\n            i.signal(e, \"unfold\", e, l, r);\n          }), i.signal(e, \"fold\", e, d.from, d.to);\n        }\n      }\n      u(s, \"doFold\");\n      function p(e, o, f) {\n        var a = v(e, o, \"widget\");\n        if (typeof a == \"function\" && (a = a(f.from, f.to)), typeof a == \"string\") {\n          var g = document.createTextNode(a);\n          a = document.createElement(\"span\"), a.appendChild(g), a.className = \"CodeMirror-foldmarker\";\n        } else\n          a && (a = a.cloneNode(!0));\n        return a;\n      }\n      u(p, \"makeWidget\"), i.newFoldFunction = function(e, o) {\n        return function(f, a) {\n          s(f, a, { rangeFinder: e, widget: o });\n        };\n      }, i.defineExtension(\"foldCode\", function(e, o, f) {\n        s(this, e, o, f);\n      }), i.defineExtension(\"isFolded\", function(e) {\n        for (var o = this.findMarksAt(e), f = 0; f < o.length; ++f)\n          if (o[f].__isFold)\n            return !0;\n      }), i.commands.toggleFold = function(e) {\n        e.foldCode(e.getCursor());\n      }, i.commands.fold = function(e) {\n        e.foldCode(e.getCursor(), null, \"fold\");\n      }, i.commands.unfold = function(e) {\n        e.foldCode(e.getCursor(), { scanUp: !1 }, \"unfold\");\n      }, i.commands.foldAll = function(e) {\n        e.operation(function() {\n          for (var o = e.firstLine(), f = e.lastLine(); o <= f; o++)\n            e.foldCode(i.Pos(o, 0), { scanUp: !1 }, \"fold\");\n        });\n      }, i.commands.unfoldAll = function(e) {\n        e.operation(function() {\n          for (var o = e.firstLine(), f = e.lastLine(); o <= f; o++)\n            e.foldCode(i.Pos(o, 0), { scanUp: !1 }, \"unfold\");\n        });\n      }, i.registerHelper(\"fold\", \"combine\", function() {\n        var e = Array.prototype.slice.call(arguments, 0);\n        return function(o, f) {\n          for (var a = 0; a < e.length; ++a) {\n            var g = e[a](o, f);\n            if (g)\n              return g;\n          }\n        };\n      }), i.registerHelper(\"fold\", \"auto\", function(e, o) {\n        for (var f = e.getHelpers(o, \"fold\"), a = 0; a < f.length; a++) {\n          var g = f[a](e, o);\n          if (g)\n            return g;\n        }\n      });\n      var w = {\n        rangeFinder: i.fold.auto,\n        widget: \"â†”\",\n        minFoldSize: 0,\n        scanUp: !1,\n        clearOnEnter: !0\n      };\n      i.defineOption(\"foldOptions\", null);\n      function v(e, o, f) {\n        if (o && o[f] !== void 0)\n          return o[f];\n        var a = e.options.foldOptions;\n        return a && a[f] !== void 0 ? a[f] : w[f];\n      }\n      u(v, \"getOption\"), i.defineExtension(\"foldOption\", function(e, o) {\n        return v(this, e, o);\n      });\n    });\n  }()), b.exports;\n}\nu(V, \"requireFoldcode\");\n(function(O, k) {\n  (function(i) {\n    i((0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.r)(), V());\n  })(function(i) {\n    i.defineOption(\"foldGutter\", !1, function(t, n, l) {\n      l && l != i.Init && (t.clearGutter(t.state.foldGutter.options.gutter), t.state.foldGutter = null, t.off(\"gutterClick\", g), t.off(\"changes\", y), t.off(\"viewportChange\", x), t.off(\"fold\", d), t.off(\"unfold\", d), t.off(\"swapDoc\", y)), n && (t.state.foldGutter = new p(w(n)), a(t), t.on(\"gutterClick\", g), t.on(\"changes\", y), t.on(\"viewportChange\", x), t.on(\"fold\", d), t.on(\"unfold\", d), t.on(\"swapDoc\", y));\n    });\n    var s = i.Pos;\n    function p(t) {\n      this.options = t, this.from = this.to = 0;\n    }\n    u(p, \"State\");\n    function w(t) {\n      return t === !0 && (t = {}), t.gutter == null && (t.gutter = \"CodeMirror-foldgutter\"), t.indicatorOpen == null && (t.indicatorOpen = \"CodeMirror-foldgutter-open\"), t.indicatorFolded == null && (t.indicatorFolded = \"CodeMirror-foldgutter-folded\"), t;\n    }\n    u(w, \"parseOptions\");\n    function v(t, n) {\n      for (var l = t.findMarks(s(n, 0), s(n + 1, 0)), r = 0; r < l.length; ++r)\n        if (l[r].__isFold) {\n          var c = l[r].find(-1);\n          if (c && c.line === n)\n            return l[r];\n        }\n    }\n    u(v, \"isFolded\");\n    function e(t) {\n      if (typeof t == \"string\") {\n        var n = document.createElement(\"div\");\n        return n.className = t + \" CodeMirror-guttermarker-subtle\", n;\n      } else\n        return t.cloneNode(!0);\n    }\n    u(e, \"marker\");\n    function o(t, n, l) {\n      var r = t.state.foldGutter.options, c = n - 1, h = t.foldOption(r, \"minFoldSize\"), G = t.foldOption(r, \"rangeFinder\"), E = typeof r.indicatorFolded == \"string\" && f(r.indicatorFolded), S = typeof r.indicatorOpen == \"string\" && f(r.indicatorOpen);\n      t.eachLine(n, l, function(T) {\n        ++c;\n        var _ = null, F = T.gutterMarkers;\n        if (F && (F = F[r.gutter]), v(t, c)) {\n          if (E && F && E.test(F.className))\n            return;\n          _ = e(r.indicatorFolded);\n        } else {\n          var A = s(c, 0), m = G && G(t, A);\n          if (m && m.to.line - m.from.line >= h) {\n            if (S && F && S.test(F.className))\n              return;\n            _ = e(r.indicatorOpen);\n          }\n        }\n        !_ && !F || t.setGutterMarker(T, r.gutter, _);\n      });\n    }\n    u(o, \"updateFoldInfo\");\n    function f(t) {\n      return new RegExp(\"(^|\\\\s)\" + t + \"(?:$|\\\\s)\\\\s*\");\n    }\n    u(f, \"classTest\");\n    function a(t) {\n      var n = t.getViewport(), l = t.state.foldGutter;\n      l && (t.operation(function() {\n        o(t, n.from, n.to);\n      }), l.from = n.from, l.to = n.to);\n    }\n    u(a, \"updateInViewport\");\n    function g(t, n, l) {\n      var r = t.state.foldGutter;\n      if (r) {\n        var c = r.options;\n        if (l == c.gutter) {\n          var h = v(t, n);\n          h ? h.clear() : t.foldCode(s(n, 0), c);\n        }\n      }\n    }\n    u(g, \"onGutterClick\");\n    function y(t) {\n      var n = t.state.foldGutter;\n      if (n) {\n        var l = n.options;\n        n.from = n.to = 0, clearTimeout(n.changeUpdate), n.changeUpdate = setTimeout(function() {\n          a(t);\n        }, l.foldOnChangeTimeSpan || 600);\n      }\n    }\n    u(y, \"onChange\");\n    function x(t) {\n      var n = t.state.foldGutter;\n      if (n) {\n        var l = n.options;\n        clearTimeout(n.changeUpdate), n.changeUpdate = setTimeout(function() {\n          var r = t.getViewport();\n          n.from == n.to || r.from - n.to > 20 || n.from - r.to > 20 ? a(t) : t.operation(function() {\n            r.from < n.from && (o(t, r.from, n.from), n.from = r.from), r.to > n.to && (o(t, n.to, r.to), n.to = r.to);\n          });\n        }, l.updateViewportTimeSpan || 400);\n      }\n    }\n    u(x, \"onViewportChange\");\n    function d(t, n) {\n      var l = t.state.foldGutter;\n      if (l) {\n        var r = n.line;\n        r >= l.from && r < l.to && o(t, r, r + 1);\n      }\n    }\n    u(d, \"onFold\");\n  });\n})();\nvar P = D.exports;\nconst C = /* @__PURE__ */ (0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.g)(P), H = /* @__PURE__ */ j({\n  __proto__: null,\n  default: C\n}, [P]);\n\n//# sourceMappingURL=foldgutter.es.js.map\n\n\n//# sourceURL=webpack://www/./node_modules/@graphiql/react/dist/foldgutter.es.js?");

/***/ })

}]);