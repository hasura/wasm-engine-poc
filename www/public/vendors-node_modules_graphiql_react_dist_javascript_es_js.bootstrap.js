"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwww"] = self["webpackChunkwww"] || []).push([["vendors-node_modules_graphiql_react_dist_javascript_es_js"],{

/***/ "./node_modules/@graphiql/react/dist/javascript.es.js":
/*!************************************************************!*\
  !*** ./node_modules/@graphiql/react/dist/javascript.es.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   j: () => (/* binding */ Ve)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codemirror.es2.js */ \"./node_modules/@graphiql/react/dist/codemirror.es2.js\");\nvar he = Object.defineProperty;\nvar f = (F, W) => he(F, \"name\", { value: W, configurable: !0 });\n\nfunction ye(F, W) {\n  for (var w = 0; w < W.length; w++) {\n    const M = W[w];\n    if (typeof M != \"string\" && !Array.isArray(M)) {\n      for (const h in M)\n        if (h !== \"default\" && !(h in F)) {\n          const A = Object.getOwnPropertyDescriptor(M, h);\n          A && Object.defineProperty(F, h, A.get ? A : {\n            enumerable: !0,\n            get: () => M[h]\n          });\n        }\n    }\n  }\n  return Object.freeze(Object.defineProperty(F, Symbol.toStringTag, { value: \"Module\" }));\n}\nf(ye, \"_mergeNamespaces\");\nvar je = { exports: {} };\n(function(F, W) {\n  (function(w) {\n    w((0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.r)());\n  })(function(w) {\n    w.defineMode(\"javascript\", function(M, h) {\n      var A = M.indentUnit, vr = h.statementIndent, rr = h.jsonld, O = h.json || rr, gr = h.trackScope !== !1, k = h.typescript, er = h.wordCharacters || /[\\w$\\xa1-\\uffff]/, yr = function() {\n        function r(y) {\n          return { type: y, style: \"keyword\" };\n        }\n        f(r, \"kw\");\n        var e = r(\"keyword a\"), t = r(\"keyword b\"), a = r(\"keyword c\"), o = r(\"keyword d\"), d = r(\"operator\"), p = { type: \"atom\", style: \"atom\" };\n        return {\n          if: r(\"if\"),\n          while: e,\n          with: e,\n          else: t,\n          do: t,\n          try: t,\n          finally: t,\n          return: o,\n          break: o,\n          continue: o,\n          new: r(\"new\"),\n          delete: a,\n          void: a,\n          throw: a,\n          debugger: r(\"debugger\"),\n          var: r(\"var\"),\n          const: r(\"var\"),\n          let: r(\"var\"),\n          function: r(\"function\"),\n          catch: r(\"catch\"),\n          for: r(\"for\"),\n          switch: r(\"switch\"),\n          case: r(\"case\"),\n          default: r(\"default\"),\n          in: d,\n          typeof: d,\n          instanceof: d,\n          true: p,\n          false: p,\n          null: p,\n          undefined: p,\n          NaN: p,\n          Infinity: p,\n          this: r(\"this\"),\n          class: r(\"class\"),\n          super: r(\"atom\"),\n          yield: a,\n          export: r(\"export\"),\n          import: r(\"import\"),\n          extends: a,\n          await: a\n        };\n      }(), jr = /[+\\-*&%=<>!?|~^@]/, Jr = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n      function Lr(r) {\n        for (var e = !1, t, a = !1; (t = r.next()) != null; ) {\n          if (!e) {\n            if (t == \"/\" && !a)\n              return;\n            t == \"[\" ? a = !0 : a && t == \"]\" && (a = !1);\n          }\n          e = !e && t == \"\\\\\";\n        }\n      }\n      f(Lr, \"readRegexp\");\n      var K, nr;\n      function x(r, e, t) {\n        return K = r, nr = t, e;\n      }\n      f(x, \"ret\");\n      function $(r, e) {\n        var t = r.next();\n        if (t == '\"' || t == \"'\")\n          return e.tokenize = Qr(t), e.tokenize(r, e);\n        if (t == \".\" && r.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/))\n          return x(\"number\", \"number\");\n        if (t == \".\" && r.match(\"..\"))\n          return x(\"spread\", \"meta\");\n        if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(t))\n          return x(t);\n        if (t == \"=\" && r.eat(\">\"))\n          return x(\"=>\", \"operator\");\n        if (t == \"0\" && r.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/))\n          return x(\"number\", \"number\");\n        if (/\\d/.test(t))\n          return r.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/), x(\"number\", \"number\");\n        if (t == \"/\")\n          return r.eat(\"*\") ? (e.tokenize = tr, tr(r, e)) : r.eat(\"/\") ? (r.skipToEnd(), x(\"comment\", \"comment\")) : Fr(r, e, 1) ? (Lr(r), r.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/), x(\"regexp\", \"string-2\")) : (r.eat(\"=\"), x(\"operator\", \"operator\", r.current()));\n        if (t == \"`\")\n          return e.tokenize = H, H(r, e);\n        if (t == \"#\" && r.peek() == \"!\")\n          return r.skipToEnd(), x(\"meta\", \"meta\");\n        if (t == \"#\" && r.eatWhile(er))\n          return x(\"variable\", \"property\");\n        if (t == \"<\" && r.match(\"!--\") || t == \"-\" && r.match(\"->\") && !/\\S/.test(r.string.slice(0, r.start)))\n          return r.skipToEnd(), x(\"comment\", \"comment\");\n        if (jr.test(t))\n          return (t != \">\" || !e.lexical || e.lexical.type != \">\") && (r.eat(\"=\") ? (t == \"!\" || t == \"=\") && r.eat(\"=\") : /[<>*+\\-|&?]/.test(t) && (r.eat(t), t == \">\" && r.eat(t))), t == \"?\" && r.eat(\".\") ? x(\".\") : x(\"operator\", \"operator\", r.current());\n        if (er.test(t)) {\n          r.eatWhile(er);\n          var a = r.current();\n          if (e.lastType != \".\") {\n            if (yr.propertyIsEnumerable(a)) {\n              var o = yr[a];\n              return x(o.type, o.style, a);\n            }\n            if (a == \"async\" && r.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, !1))\n              return x(\"async\", \"keyword\", a);\n          }\n          return x(\"variable\", \"variable\", a);\n        }\n      }\n      f($, \"tokenBase\");\n      function Qr(r) {\n        return function(e, t) {\n          var a = !1, o;\n          if (rr && e.peek() == \"@\" && e.match(Jr))\n            return t.tokenize = $, x(\"jsonld-keyword\", \"meta\");\n          for (; (o = e.next()) != null && !(o == r && !a); )\n            a = !a && o == \"\\\\\";\n          return a || (t.tokenize = $), x(\"string\", \"string\");\n        };\n      }\n      f(Qr, \"tokenString\");\n      function tr(r, e) {\n        for (var t = !1, a; a = r.next(); ) {\n          if (a == \"/\" && t) {\n            e.tokenize = $;\n            break;\n          }\n          t = a == \"*\";\n        }\n        return x(\"comment\", \"comment\");\n      }\n      f(tr, \"tokenComment\");\n      function H(r, e) {\n        for (var t = !1, a; (a = r.next()) != null; ) {\n          if (!t && (a == \"`\" || a == \"$\" && r.eat(\"{\"))) {\n            e.tokenize = $;\n            break;\n          }\n          t = !t && a == \"\\\\\";\n        }\n        return x(\"quasi\", \"string-2\", r.current());\n      }\n      f(H, \"tokenQuasi\");\n      var Rr = \"([{}])\";\n      function dr(r, e) {\n        e.fatArrowAt && (e.fatArrowAt = null);\n        var t = r.string.indexOf(\"=>\", r.start);\n        if (!(t < 0)) {\n          if (k) {\n            var a = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(r.string.slice(r.start, t));\n            a && (t = a.index);\n          }\n          for (var o = 0, d = !1, p = t - 1; p >= 0; --p) {\n            var y = r.string.charAt(p), V = Rr.indexOf(y);\n            if (V >= 0 && V < 3) {\n              if (!o) {\n                ++p;\n                break;\n              }\n              if (--o == 0) {\n                y == \"(\" && (d = !0);\n                break;\n              }\n            } else if (V >= 3 && V < 6)\n              ++o;\n            else if (er.test(y))\n              d = !0;\n            else if (/[\"'\\/`]/.test(y))\n              for (; ; --p) {\n                if (p == 0)\n                  return;\n                var xe = r.string.charAt(p - 1);\n                if (xe == y && r.string.charAt(p - 2) != \"\\\\\") {\n                  p--;\n                  break;\n                }\n              }\n            else if (d && !o) {\n              ++p;\n              break;\n            }\n          }\n          d && !o && (e.fatArrowAt = p);\n        }\n      }\n      f(dr, \"findFatArrow\");\n      var Ur = {\n        atom: !0,\n        number: !0,\n        variable: !0,\n        string: !0,\n        regexp: !0,\n        this: !0,\n        import: !0,\n        \"jsonld-keyword\": !0\n      };\n      function Er(r, e, t, a, o, d) {\n        this.indented = r, this.column = e, this.type = t, this.prev = o, this.info = d, a != null && (this.align = a);\n      }\n      f(Er, \"JSLexical\");\n      function Wr(r, e) {\n        if (!gr)\n          return !1;\n        for (var t = r.localVars; t; t = t.next)\n          if (t.name == e)\n            return !0;\n        for (var a = r.context; a; a = a.prev)\n          for (var t = a.vars; t; t = t.next)\n            if (t.name == e)\n              return !0;\n      }\n      f(Wr, \"inScope\");\n      function Tr(r, e, t, a, o) {\n        var d = r.cc;\n        for (i.state = r, i.stream = o, i.marked = null, i.cc = d, i.style = e, r.lexical.hasOwnProperty(\"align\") || (r.lexical.align = !0); ; ) {\n          var p = d.length ? d.pop() : O ? b : v;\n          if (p(t, a)) {\n            for (; d.length && d[d.length - 1].lex; )\n              d.pop()();\n            return i.marked ? i.marked : t == \"variable\" && Wr(r, a) ? \"variable-2\" : e;\n          }\n        }\n      }\n      f(Tr, \"parseJS\");\n      var i = { state: null, column: null, marked: null, cc: null };\n      function s() {\n        for (var r = arguments.length - 1; r >= 0; r--)\n          i.cc.push(arguments[r]);\n      }\n      f(s, \"pass\");\n      function n() {\n        return s.apply(null, arguments), !0;\n      }\n      f(n, \"cont\");\n      function mr(r, e) {\n        for (var t = e; t; t = t.next)\n          if (t.name == r)\n            return !0;\n        return !1;\n      }\n      f(mr, \"inList\");\n      function D(r) {\n        var e = i.state;\n        if (i.marked = \"def\", !!gr) {\n          if (e.context) {\n            if (e.lexical.info == \"var\" && e.context && e.context.block) {\n              var t = Ar(r, e.context);\n              if (t != null) {\n                e.context = t;\n                return;\n              }\n            } else if (!mr(r, e.localVars)) {\n              e.localVars = new X(r, e.localVars);\n              return;\n            }\n          }\n          h.globalVars && !mr(r, e.globalVars) && (e.globalVars = new X(r, e.globalVars));\n        }\n      }\n      f(D, \"register\");\n      function Ar(r, e) {\n        if (e)\n          if (e.block) {\n            var t = Ar(r, e.prev);\n            return t ? t == e.prev ? e : new G(t, e.vars, !0) : null;\n          } else\n            return mr(r, e.vars) ? e : new G(e.prev, new X(r, e.vars), !1);\n        else\n          return null;\n      }\n      f(Ar, \"registerVarScoped\");\n      function ir(r) {\n        return r == \"public\" || r == \"private\" || r == \"protected\" || r == \"abstract\" || r == \"readonly\";\n      }\n      f(ir, \"isModifier\");\n      function G(r, e, t) {\n        this.prev = r, this.vars = e, this.block = t;\n      }\n      f(G, \"Context\");\n      function X(r, e) {\n        this.name = r, this.next = e;\n      }\n      f(X, \"Var\");\n      var Kr = new X(\"this\", new X(\"arguments\", null));\n      function q() {\n        i.state.context = new G(i.state.context, i.state.localVars, !1), i.state.localVars = Kr;\n      }\n      f(q, \"pushcontext\");\n      function fr() {\n        i.state.context = new G(i.state.context, i.state.localVars, !0), i.state.localVars = null;\n      }\n      f(fr, \"pushblockcontext\"), q.lex = fr.lex = !0;\n      function E() {\n        i.state.localVars = i.state.context.vars, i.state.context = i.state.context.prev;\n      }\n      f(E, \"popcontext\"), E.lex = !0;\n      function c(r, e) {\n        var t = /* @__PURE__ */ f(function() {\n          var a = i.state, o = a.indented;\n          if (a.lexical.type == \"stat\")\n            o = a.lexical.indented;\n          else\n            for (var d = a.lexical; d && d.type == \")\" && d.align; d = d.prev)\n              o = d.indented;\n          a.lexical = new Er(o, i.stream.column(), r, null, a.lexical, e);\n        }, \"result\");\n        return t.lex = !0, t;\n      }\n      f(c, \"pushlex\");\n      function u() {\n        var r = i.state;\n        r.lexical.prev && (r.lexical.type == \")\" && (r.indented = r.lexical.indented), r.lexical = r.lexical.prev);\n      }\n      f(u, \"poplex\"), u.lex = !0;\n      function l(r) {\n        function e(t) {\n          return t == r ? n() : r == \";\" || t == \"}\" || t == \")\" || t == \"]\" ? s() : n(e);\n        }\n        return f(e, \"exp\"), e;\n      }\n      f(l, \"expect\");\n      function v(r, e) {\n        return r == \"var\" ? n(c(\"vardef\", e), xr, l(\";\"), u) : r == \"keyword a\" ? n(c(\"form\"), pr, v, u) : r == \"keyword b\" ? n(c(\"form\"), v, u) : r == \"keyword d\" ? i.stream.match(/^\\s*$/, !1) ? n() : n(c(\"stat\"), J, l(\";\"), u) : r == \"debugger\" ? n(l(\";\")) : r == \"{\" ? n(c(\"}\"), fr, or, u, E) : r == \";\" ? n() : r == \"if\" ? (i.state.lexical.info == \"else\" && i.state.cc[i.state.cc.length - 1] == u && i.state.cc.pop()(), n(c(\"form\"), pr, v, u, Mr)) : r == \"function\" ? n(z) : r == \"for\" ? n(c(\"form\"), fr, Or, v, E, u) : r == \"class\" || k && e == \"interface\" ? (i.marked = \"keyword\", n(c(\"form\", r == \"class\" ? r : e), qr, u)) : r == \"variable\" ? k && e == \"declare\" ? (i.marked = \"keyword\", n(v)) : k && (e == \"module\" || e == \"enum\" || e == \"type\") && i.stream.match(/^\\s*\\w/, !1) ? (i.marked = \"keyword\", e == \"enum\" ? n(Pr) : e == \"type\" ? n($r, l(\"operator\"), m, l(\";\")) : n(c(\"form\"), T, l(\"{\"), c(\"}\"), or, u, u)) : k && e == \"namespace\" ? (i.marked = \"keyword\", n(c(\"form\"), b, v, u)) : k && e == \"abstract\" ? (i.marked = \"keyword\", n(v)) : n(c(\"stat\"), Cr) : r == \"switch\" ? n(\n          c(\"form\"),\n          pr,\n          l(\"{\"),\n          c(\"}\", \"switch\"),\n          fr,\n          or,\n          u,\n          u,\n          E\n        ) : r == \"case\" ? n(b, l(\":\")) : r == \"default\" ? n(l(\":\")) : r == \"catch\" ? n(c(\"form\"), q, Hr, v, u, E) : r == \"export\" ? n(c(\"stat\"), de, u) : r == \"import\" ? n(c(\"stat\"), me, u) : r == \"async\" ? n(v) : e == \"@\" ? n(b, v) : s(c(\"stat\"), b, l(\";\"), u);\n      }\n      f(v, \"statement\");\n      function Hr(r) {\n        if (r == \"(\")\n          return n(P, l(\")\"));\n      }\n      f(Hr, \"maybeCatchBinding\");\n      function b(r, e) {\n        return Vr(r, e, !1);\n      }\n      f(b, \"expression\");\n      function j(r, e) {\n        return Vr(r, e, !0);\n      }\n      f(j, \"expressionNoComma\");\n      function pr(r) {\n        return r != \"(\" ? s() : n(c(\")\"), J, l(\")\"), u);\n      }\n      f(pr, \"parenExpr\");\n      function Vr(r, e, t) {\n        if (i.state.fatArrowAt == i.stream.start) {\n          var a = t ? Sr : Ir;\n          if (r == \"(\")\n            return n(q, c(\")\"), g(P, \")\"), u, l(\"=>\"), a, E);\n          if (r == \"variable\")\n            return s(q, T, l(\"=>\"), a, E);\n        }\n        var o = t ? L : N;\n        return Ur.hasOwnProperty(r) ? n(o) : r == \"function\" ? n(z, o) : r == \"class\" || k && e == \"interface\" ? (i.marked = \"keyword\", n(c(\"form\"), le, u)) : r == \"keyword c\" || r == \"async\" ? n(t ? j : b) : r == \"(\" ? n(c(\")\"), J, l(\")\"), u, o) : r == \"operator\" || r == \"spread\" ? n(t ? j : b) : r == \"[\" ? n(c(\"]\"), ke, u, o) : r == \"{\" ? Y(ur, \"}\", null, o) : r == \"quasi\" ? s(ar, o) : r == \"new\" ? n(Xr(t)) : n();\n      }\n      f(Vr, \"expressionInner\");\n      function J(r) {\n        return r.match(/[;\\}\\)\\],]/) ? s() : s(b);\n      }\n      f(J, \"maybeexpression\");\n      function N(r, e) {\n        return r == \",\" ? n(J) : L(r, e, !1);\n      }\n      f(N, \"maybeoperatorComma\");\n      function L(r, e, t) {\n        var a = t == !1 ? N : L, o = t == !1 ? b : j;\n        if (r == \"=>\")\n          return n(q, t ? Sr : Ir, E);\n        if (r == \"operator\")\n          return /\\+\\+|--/.test(e) || k && e == \"!\" ? n(a) : k && e == \"<\" && i.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, !1) ? n(c(\">\"), g(m, \">\"), u, a) : e == \"?\" ? n(b, l(\":\"), o) : n(o);\n        if (r == \"quasi\")\n          return s(ar, a);\n        if (r != \";\") {\n          if (r == \"(\")\n            return Y(j, \")\", \"call\", a);\n          if (r == \".\")\n            return n(re, a);\n          if (r == \"[\")\n            return n(c(\"]\"), J, l(\"]\"), u, a);\n          if (k && e == \"as\")\n            return i.marked = \"keyword\", n(m, a);\n          if (r == \"regexp\")\n            return i.state.lastType = i.marked = \"operator\", i.stream.backUp(i.stream.pos - i.stream.start - 1), n(o);\n        }\n      }\n      f(L, \"maybeoperatorNoComma\");\n      function ar(r, e) {\n        return r != \"quasi\" ? s() : e.slice(e.length - 2) != \"${\" ? n(ar) : n(J, Gr);\n      }\n      f(ar, \"quasi\");\n      function Gr(r) {\n        if (r == \"}\")\n          return i.marked = \"string-2\", i.state.tokenize = H, n(ar);\n      }\n      f(Gr, \"continueQuasi\");\n      function Ir(r) {\n        return dr(i.stream, i.state), s(r == \"{\" ? v : b);\n      }\n      f(Ir, \"arrowBody\");\n      function Sr(r) {\n        return dr(i.stream, i.state), s(r == \"{\" ? v : j);\n      }\n      f(Sr, \"arrowBodyNoComma\");\n      function Xr(r) {\n        return function(e) {\n          return e == \".\" ? n(r ? Zr : Yr) : e == \"variable\" && k ? n(ae, r ? L : N) : s(r ? j : b);\n        };\n      }\n      f(Xr, \"maybeTarget\");\n      function Yr(r, e) {\n        if (e == \"target\")\n          return i.marked = \"keyword\", n(N);\n      }\n      f(Yr, \"target\");\n      function Zr(r, e) {\n        if (e == \"target\")\n          return i.marked = \"keyword\", n(L);\n      }\n      f(Zr, \"targetNoComma\");\n      function Cr(r) {\n        return r == \":\" ? n(u, v) : s(N, l(\";\"), u);\n      }\n      f(Cr, \"maybelabel\");\n      function re(r) {\n        if (r == \"variable\")\n          return i.marked = \"property\", n();\n      }\n      f(re, \"property\");\n      function ur(r, e) {\n        if (r == \"async\")\n          return i.marked = \"property\", n(ur);\n        if (r == \"variable\" || i.style == \"keyword\") {\n          if (i.marked = \"property\", e == \"get\" || e == \"set\")\n            return n(ee);\n          var t;\n          return k && i.state.fatArrowAt == i.stream.start && (t = i.stream.match(/^\\s*:\\s*/, !1)) && (i.state.fatArrowAt = i.stream.pos + t[0].length), n(B);\n        } else {\n          if (r == \"number\" || r == \"string\")\n            return i.marked = rr ? \"property\" : i.style + \" property\", n(B);\n          if (r == \"jsonld-keyword\")\n            return n(B);\n          if (k && ir(e))\n            return i.marked = \"keyword\", n(ur);\n          if (r == \"[\")\n            return n(b, Q, l(\"]\"), B);\n          if (r == \"spread\")\n            return n(j, B);\n          if (e == \"*\")\n            return i.marked = \"keyword\", n(ur);\n          if (r == \":\")\n            return s(B);\n        }\n      }\n      f(ur, \"objprop\");\n      function ee(r) {\n        return r != \"variable\" ? s(B) : (i.marked = \"property\", n(z));\n      }\n      f(ee, \"getterSetter\");\n      function B(r) {\n        if (r == \":\")\n          return n(j);\n        if (r == \"(\")\n          return s(z);\n      }\n      f(B, \"afterprop\");\n      function g(r, e, t) {\n        function a(o, d) {\n          if (t ? t.indexOf(o) > -1 : o == \",\") {\n            var p = i.state.lexical;\n            return p.info == \"call\" && (p.pos = (p.pos || 0) + 1), n(function(y, V) {\n              return y == e || V == e ? s() : s(r);\n            }, a);\n          }\n          return o == e || d == e ? n() : t && t.indexOf(\";\") > -1 ? s(r) : n(l(e));\n        }\n        return f(a, \"proceed\"), function(o, d) {\n          return o == e || d == e ? n() : s(r, a);\n        };\n      }\n      f(g, \"commasep\");\n      function Y(r, e, t) {\n        for (var a = 3; a < arguments.length; a++)\n          i.cc.push(arguments[a]);\n        return n(c(e, t), g(r, e), u);\n      }\n      f(Y, \"contCommasep\");\n      function or(r) {\n        return r == \"}\" ? n() : s(v, or);\n      }\n      f(or, \"block\");\n      function Q(r, e) {\n        if (k) {\n          if (r == \":\")\n            return n(m);\n          if (e == \"?\")\n            return n(Q);\n        }\n      }\n      f(Q, \"maybetype\");\n      function ne(r, e) {\n        if (k && (r == \":\" || e == \"in\"))\n          return n(m);\n      }\n      f(ne, \"maybetypeOrIn\");\n      function _r(r) {\n        if (k && r == \":\")\n          return i.stream.match(/^\\s*\\w+\\s+is\\b/, !1) ? n(b, te, m) : n(m);\n      }\n      f(_r, \"mayberettype\");\n      function te(r, e) {\n        if (e == \"is\")\n          return i.marked = \"keyword\", n();\n      }\n      f(te, \"isKW\");\n      function m(r, e) {\n        if (e == \"keyof\" || e == \"typeof\" || e == \"infer\" || e == \"readonly\")\n          return i.marked = \"keyword\", n(e == \"typeof\" ? j : m);\n        if (r == \"variable\" || e == \"void\")\n          return i.marked = \"type\", n(I);\n        if (e == \"|\" || e == \"&\")\n          return n(m);\n        if (r == \"string\" || r == \"number\" || r == \"atom\")\n          return n(I);\n        if (r == \"[\")\n          return n(c(\"]\"), g(m, \"]\", \",\"), u, I);\n        if (r == \"{\")\n          return n(c(\"}\"), kr, u, I);\n        if (r == \"(\")\n          return n(g(wr, \")\"), ie, I);\n        if (r == \"<\")\n          return n(g(m, \">\"), m);\n        if (r == \"quasi\")\n          return s(br, I);\n      }\n      f(m, \"typeexpr\");\n      function ie(r) {\n        if (r == \"=>\")\n          return n(m);\n      }\n      f(ie, \"maybeReturnType\");\n      function kr(r) {\n        return r.match(/[\\}\\)\\]]/) ? n() : r == \",\" || r == \";\" ? n(kr) : s(Z, kr);\n      }\n      f(kr, \"typeprops\");\n      function Z(r, e) {\n        if (r == \"variable\" || i.style == \"keyword\")\n          return i.marked = \"property\", n(Z);\n        if (e == \"?\" || r == \"number\" || r == \"string\")\n          return n(Z);\n        if (r == \":\")\n          return n(m);\n        if (r == \"[\")\n          return n(l(\"variable\"), ne, l(\"]\"), Z);\n        if (r == \"(\")\n          return s(U, Z);\n        if (!r.match(/[;\\}\\)\\],]/))\n          return n();\n      }\n      f(Z, \"typeprop\");\n      function br(r, e) {\n        return r != \"quasi\" ? s() : e.slice(e.length - 2) != \"${\" ? n(br) : n(m, fe);\n      }\n      f(br, \"quasiType\");\n      function fe(r) {\n        if (r == \"}\")\n          return i.marked = \"string-2\", i.state.tokenize = H, n(br);\n      }\n      f(fe, \"continueQuasiType\");\n      function wr(r, e) {\n        return r == \"variable\" && i.stream.match(/^\\s*[?:]/, !1) || e == \"?\" ? n(wr) : r == \":\" ? n(m) : r == \"spread\" ? n(wr) : s(m);\n      }\n      f(wr, \"typearg\");\n      function I(r, e) {\n        if (e == \"<\")\n          return n(c(\">\"), g(m, \">\"), u, I);\n        if (e == \"|\" || r == \".\" || e == \"&\")\n          return n(m);\n        if (r == \"[\")\n          return n(m, l(\"]\"), I);\n        if (e == \"extends\" || e == \"implements\")\n          return i.marked = \"keyword\", n(m);\n        if (e == \"?\")\n          return n(m, l(\":\"), m);\n      }\n      f(I, \"afterType\");\n      function ae(r, e) {\n        if (e == \"<\")\n          return n(c(\">\"), g(m, \">\"), u, I);\n      }\n      f(ae, \"maybeTypeArgs\");\n      function sr() {\n        return s(m, ue);\n      }\n      f(sr, \"typeparam\");\n      function ue(r, e) {\n        if (e == \"=\")\n          return n(m);\n      }\n      f(ue, \"maybeTypeDefault\");\n      function xr(r, e) {\n        return e == \"enum\" ? (i.marked = \"keyword\", n(Pr)) : s(T, Q, _, se);\n      }\n      f(xr, \"vardef\");\n      function T(r, e) {\n        if (k && ir(e))\n          return i.marked = \"keyword\", n(T);\n        if (r == \"variable\")\n          return D(e), n();\n        if (r == \"spread\")\n          return n(T);\n        if (r == \"[\")\n          return Y(oe, \"]\");\n        if (r == \"{\")\n          return Y(zr, \"}\");\n      }\n      f(T, \"pattern\");\n      function zr(r, e) {\n        return r == \"variable\" && !i.stream.match(/^\\s*:/, !1) ? (D(e), n(_)) : (r == \"variable\" && (i.marked = \"property\"), r == \"spread\" ? n(T) : r == \"}\" ? s() : r == \"[\" ? n(b, l(\"]\"), l(\":\"), zr) : n(l(\":\"), T, _));\n      }\n      f(zr, \"proppattern\");\n      function oe() {\n        return s(T, _);\n      }\n      f(oe, \"eltpattern\");\n      function _(r, e) {\n        if (e == \"=\")\n          return n(j);\n      }\n      f(_, \"maybeAssign\");\n      function se(r) {\n        if (r == \",\")\n          return n(xr);\n      }\n      f(se, \"vardefCont\");\n      function Mr(r, e) {\n        if (r == \"keyword b\" && e == \"else\")\n          return n(c(\"form\", \"else\"), v, u);\n      }\n      f(Mr, \"maybeelse\");\n      function Or(r, e) {\n        if (e == \"await\")\n          return n(Or);\n        if (r == \"(\")\n          return n(c(\")\"), ce, u);\n      }\n      f(Or, \"forspec\");\n      function ce(r) {\n        return r == \"var\" ? n(xr, R) : r == \"variable\" ? n(R) : s(R);\n      }\n      f(ce, \"forspec1\");\n      function R(r, e) {\n        return r == \")\" ? n() : r == \";\" ? n(R) : e == \"in\" || e == \"of\" ? (i.marked = \"keyword\", n(b, R)) : s(b, R);\n      }\n      f(R, \"forspec2\");\n      function z(r, e) {\n        if (e == \"*\")\n          return i.marked = \"keyword\", n(z);\n        if (r == \"variable\")\n          return D(e), n(z);\n        if (r == \"(\")\n          return n(q, c(\")\"), g(P, \")\"), u, _r, v, E);\n        if (k && e == \"<\")\n          return n(c(\">\"), g(sr, \">\"), u, z);\n      }\n      f(z, \"functiondef\");\n      function U(r, e) {\n        if (e == \"*\")\n          return i.marked = \"keyword\", n(U);\n        if (r == \"variable\")\n          return D(e), n(U);\n        if (r == \"(\")\n          return n(q, c(\")\"), g(P, \")\"), u, _r, E);\n        if (k && e == \"<\")\n          return n(c(\">\"), g(sr, \">\"), u, U);\n      }\n      f(U, \"functiondecl\");\n      function $r(r, e) {\n        if (r == \"keyword\" || r == \"variable\")\n          return i.marked = \"type\", n($r);\n        if (e == \"<\")\n          return n(c(\">\"), g(sr, \">\"), u);\n      }\n      f($r, \"typename\");\n      function P(r, e) {\n        return e == \"@\" && n(b, P), r == \"spread\" ? n(P) : k && ir(e) ? (i.marked = \"keyword\", n(P)) : k && r == \"this\" ? n(Q, _) : s(T, Q, _);\n      }\n      f(P, \"funarg\");\n      function le(r, e) {\n        return r == \"variable\" ? qr(r, e) : cr(r, e);\n      }\n      f(le, \"classExpression\");\n      function qr(r, e) {\n        if (r == \"variable\")\n          return D(e), n(cr);\n      }\n      f(qr, \"className\");\n      function cr(r, e) {\n        if (e == \"<\")\n          return n(c(\">\"), g(sr, \">\"), u, cr);\n        if (e == \"extends\" || e == \"implements\" || k && r == \",\")\n          return e == \"implements\" && (i.marked = \"keyword\"), n(k ? m : b, cr);\n        if (r == \"{\")\n          return n(c(\"}\"), S, u);\n      }\n      f(cr, \"classNameAfter\");\n      function S(r, e) {\n        if (r == \"async\" || r == \"variable\" && (e == \"static\" || e == \"get\" || e == \"set\" || k && ir(e)) && i.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, !1))\n          return i.marked = \"keyword\", n(S);\n        if (r == \"variable\" || i.style == \"keyword\")\n          return i.marked = \"property\", n(C, S);\n        if (r == \"number\" || r == \"string\")\n          return n(C, S);\n        if (r == \"[\")\n          return n(b, Q, l(\"]\"), C, S);\n        if (e == \"*\")\n          return i.marked = \"keyword\", n(S);\n        if (k && r == \"(\")\n          return s(U, S);\n        if (r == \";\" || r == \",\")\n          return n(S);\n        if (r == \"}\")\n          return n();\n        if (e == \"@\")\n          return n(b, S);\n      }\n      f(S, \"classBody\");\n      function C(r, e) {\n        if (e == \"!\" || e == \"?\")\n          return n(C);\n        if (r == \":\")\n          return n(m, _);\n        if (e == \"=\")\n          return n(j);\n        var t = i.state.lexical.prev, a = t && t.info == \"interface\";\n        return s(a ? U : z);\n      }\n      f(C, \"classfield\");\n      function de(r, e) {\n        return e == \"*\" ? (i.marked = \"keyword\", n(hr, l(\";\"))) : e == \"default\" ? (i.marked = \"keyword\", n(b, l(\";\"))) : r == \"{\" ? n(g(Nr, \"}\"), hr, l(\";\")) : s(v);\n      }\n      f(de, \"afterExport\");\n      function Nr(r, e) {\n        if (e == \"as\")\n          return i.marked = \"keyword\", n(l(\"variable\"));\n        if (r == \"variable\")\n          return s(j, Nr);\n      }\n      f(Nr, \"exportField\");\n      function me(r) {\n        return r == \"string\" ? n() : r == \"(\" ? s(b) : r == \".\" ? s(N) : s(lr, Br, hr);\n      }\n      f(me, \"afterImport\");\n      function lr(r, e) {\n        return r == \"{\" ? Y(lr, \"}\") : (r == \"variable\" && D(e), e == \"*\" && (i.marked = \"keyword\"), n(pe));\n      }\n      f(lr, \"importSpec\");\n      function Br(r) {\n        if (r == \",\")\n          return n(lr, Br);\n      }\n      f(Br, \"maybeMoreImports\");\n      function pe(r, e) {\n        if (e == \"as\")\n          return i.marked = \"keyword\", n(lr);\n      }\n      f(pe, \"maybeAs\");\n      function hr(r, e) {\n        if (e == \"from\")\n          return i.marked = \"keyword\", n(b);\n      }\n      f(hr, \"maybeFrom\");\n      function ke(r) {\n        return r == \"]\" ? n() : s(g(j, \"]\"));\n      }\n      f(ke, \"arrayLiteral\");\n      function Pr() {\n        return s(c(\"form\"), T, l(\"{\"), c(\"}\"), g(be, \"}\"), u, u);\n      }\n      f(Pr, \"enumdef\");\n      function be() {\n        return s(T, _);\n      }\n      f(be, \"enummember\");\n      function we(r, e) {\n        return r.lastType == \"operator\" || r.lastType == \",\" || jr.test(e.charAt(0)) || /[,.]/.test(e.charAt(0));\n      }\n      f(we, \"isContinuedStatement\");\n      function Fr(r, e, t) {\n        return e.tokenize == $ && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(e.lastType) || e.lastType == \"quasi\" && /\\{\\s*$/.test(r.string.slice(0, r.pos - (t || 0)));\n      }\n      return f(Fr, \"expressionAllowed\"), {\n        startState: function(r) {\n          var e = {\n            tokenize: $,\n            lastType: \"sof\",\n            cc: [],\n            lexical: new Er((r || 0) - A, 0, \"block\", !1),\n            localVars: h.localVars,\n            context: h.localVars && new G(null, null, !1),\n            indented: r || 0\n          };\n          return h.globalVars && typeof h.globalVars == \"object\" && (e.globalVars = h.globalVars), e;\n        },\n        token: function(r, e) {\n          if (r.sol() && (e.lexical.hasOwnProperty(\"align\") || (e.lexical.align = !1), e.indented = r.indentation(), dr(r, e)), e.tokenize != tr && r.eatSpace())\n            return null;\n          var t = e.tokenize(r, e);\n          return K == \"comment\" ? t : (e.lastType = K == \"operator\" && (nr == \"++\" || nr == \"--\") ? \"incdec\" : K, Tr(e, t, K, nr, r));\n        },\n        indent: function(r, e) {\n          if (r.tokenize == tr || r.tokenize == H)\n            return w.Pass;\n          if (r.tokenize != $)\n            return 0;\n          var t = e && e.charAt(0), a = r.lexical, o;\n          if (!/^\\s*else\\b/.test(e))\n            for (var d = r.cc.length - 1; d >= 0; --d) {\n              var p = r.cc[d];\n              if (p == u)\n                a = a.prev;\n              else if (p != Mr && p != E)\n                break;\n            }\n          for (; (a.type == \"stat\" || a.type == \"form\") && (t == \"}\" || (o = r.cc[r.cc.length - 1]) && (o == N || o == L) && !/^[,\\.=+\\-*:?[\\(]/.test(e)); )\n            a = a.prev;\n          vr && a.type == \")\" && a.prev.type == \"stat\" && (a = a.prev);\n          var y = a.type, V = t == y;\n          return y == \"vardef\" ? a.indented + (r.lastType == \"operator\" || r.lastType == \",\" ? a.info.length + 1 : 0) : y == \"form\" && t == \"{\" ? a.indented : y == \"form\" ? a.indented + A : y == \"stat\" ? a.indented + (we(r, e) ? vr || A : 0) : a.info == \"switch\" && !V && h.doubleIndentSwitch != !1 ? a.indented + (/^(?:case|default)\\b/.test(e) ? A : 2 * A) : a.align ? a.column + (V ? 0 : 1) : a.indented + (V ? 0 : A);\n        },\n        electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n        blockCommentStart: O ? null : \"/*\",\n        blockCommentEnd: O ? null : \"*/\",\n        blockCommentContinue: O ? null : \" * \",\n        lineComment: O ? null : \"//\",\n        fold: \"brace\",\n        closeBrackets: \"()[]{}''\\\"\\\"``\",\n        helperType: O ? \"json\" : \"javascript\",\n        jsonldMode: rr,\n        jsonMode: O,\n        expressionAllowed: Fr,\n        skipExpression: function(r) {\n          Tr(r, \"atom\", \"atom\", \"true\", new w.StringStream(\"\", 2, null));\n        }\n      };\n    }), w.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/), w.defineMIME(\"text/javascript\", \"javascript\"), w.defineMIME(\"text/ecmascript\", \"javascript\"), w.defineMIME(\"application/javascript\", \"javascript\"), w.defineMIME(\"application/x-javascript\", \"javascript\"), w.defineMIME(\"application/ecmascript\", \"javascript\"), w.defineMIME(\"application/json\", { name: \"javascript\", json: !0 }), w.defineMIME(\"application/x-json\", { name: \"javascript\", json: !0 }), w.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: !0 }), w.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: !0 }), w.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: !0 }), w.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: !0 });\n  });\n})();\nvar Dr = je.exports;\nconst Ee = /* @__PURE__ */ (0,_codemirror_es2_js__WEBPACK_IMPORTED_MODULE_0__.g)(Dr), Ve = /* @__PURE__ */ ye({\n  __proto__: null,\n  default: Ee\n}, [Dr]);\n\n//# sourceMappingURL=javascript.es.js.map\n\n\n//# sourceURL=webpack://www/./node_modules/@graphiql/react/dist/javascript.es.js?");

/***/ })

}]);