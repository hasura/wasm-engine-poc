// import {
//   QueryRequest,
//   Expression,
//   QueryResponse,
//   RowSet,
//   BadRequest,
//   NotSupported,
//   InternalServerError,
//   Query,
//   ObjectType,
// } from "@hasura/ndc-sdk-typescript";

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * Types track the valid representations of values as JSON
 */
export type Type = {
    type: "named";
    /**
     * The name can refer to a primitive type or a scalar type
     */
    name: string;
} | {
    type: "nullable";
    /**
     * The type of the non-null inhabitants of this type
     */
    underlying_type: Type;
} | {
    type: "array";
    /**
     * The type of the elements of the array
     */
    element_type: Type;
};
export type Aggregate = {
    type: "column_count";
    /**
     * The column to apply the count aggregate function to
     */
    column: string;
    /**
     * Whether or not only distinct items should be counted
     */
    distinct: boolean;
} | {
    type: "single_column";
    /**
     * The column to apply the aggregation function to
     */
    column: string;
    /**
     * Single column aggregate function name.
     */
    function: string;
} | {
    type: "star_count";
};
export type Field = {
    type: "column";
    column: string;
} | {
    type: "relationship";
    query: Query;
    /**
     * The name of the relationship to follow for the subquery
     */
    relationship: string;
    /**
     * Values to be provided to any collection arguments
     */
    arguments: {
        [k: string]: RelationshipArgument;
    };
};
export type RelationshipArgument = {
    type: "variable";
    name: string;
} | {
    type: "literal";
    value: unknown;
} | {
    type: "column";
    name: string;
};
export type OrderDirection = "asc" | "desc";
export type OrderByTarget = {
    type: "column";
    /**
     * The name of the column
     */
    name: string;
    /**
     * Any relationships to traverse to reach this column
     */
    path: PathElement[];
} | {
    type: "single_column_aggregate";
    /**
     * The column to apply the aggregation function to
     */
    column: string;
    /**
     * Single column aggregate function name.
     */
    function: string;
    /**
     * Non-empty collection of relationships to traverse
     */
    path: PathElement[];
} | {
    type: "star_count_aggregate";
    /**
     * Non-empty collection of relationships to traverse
     */
    path: PathElement[];
};
export type Expression = {
    type: "and";
    expressions: Expression[];
} | {
    type: "or";
    expressions: Expression[];
} | {
    type: "not";
    expression: Expression;
} | {
    type: "unary_comparison_operator";
    column: ComparisonTarget;
    operator: UnaryComparisonOperator;
} | {
    type: "binary_comparison_operator";
    column: ComparisonTarget;
    operator: BinaryComparisonOperator;
    value: ComparisonValue;
} | {
    type: "binary_array_comparison_operator";
    column: ComparisonTarget;
    operator: BinaryArrayComparisonOperator;
    values: ComparisonValue[];
} | {
    type: "exists";
    in_collection: ExistsInCollection;
    where: Expression;
};
export type ComparisonTarget = {
    type: "column";
    /**
     * The name of the column
     */
    name: string;
    /**
     * Any relationships to traverse to reach this column
     */
    path: PathElement[];
} | {
    type: "root_collection_column";
    /**
     * The name of the column
     */
    name: string;
};
export type UnaryComparisonOperator = "is_null";
export type BinaryComparisonOperator = {
    type: "equal";
} | {
    type: "other";
    name: string;
};
export type ComparisonValue = {
    type: "column";
    column: ComparisonTarget;
} | {
    type: "scalar";
    value: unknown;
} | {
    type: "variable";
    name: string;
};
export type BinaryArrayComparisonOperator = "in";
export type ExistsInCollection = {
    type: "related";
    relationship: string;
    /**
     * Values to be provided to any collection arguments
     */
    arguments: {
        [k: string]: RelationshipArgument;
    };
} | {
    type: "unrelated";
    /**
     * The name of a collection
     */
    collection: string;
    /**
     * Values to be provided to any collection arguments
     */
    arguments: {
        [k: string]: RelationshipArgument;
    };
};
export type Argument = {
    type: "variable";
    name: string;
} | {
    type: "literal";
    value: unknown;
};
export type RelationshipType = "object" | "array";
/**
 * Query responses may return multiple RowSets when using queries with variables. Else, there should always be exactly one RowSet
 */
export type QueryResponse = RowSet[];
export type MutationOperation = {
    type: "procedure";
    /**
     * The name of a procedure
     */
    name: string;
    /**
     * Any named procedure arguments
     */
    arguments: {
        [k: string]: unknown;
    };
    /**
     * The fields to return
     */
    fields?: {
        [k: string]: Field;
    } | null;
};
export interface SchemaRoot {
    capabilities_response: CapabilitiesResponse;
    schema_response: SchemaResponse;
    query_request: QueryRequest;
    query_response: QueryResponse;
    mutation_request: MutationRequest;
    mutation_response: MutationResponse;
    explain_response: ExplainResponse;
    error_response: ErrorResponse;
    validate_response: ValidateResponse;
}
export interface CapabilitiesResponse {
    versions: string;
    capabilities: Capabilities;
}
/**
 * Describes the features of the specification which a data connector implements.
 */
export interface Capabilities {
    query: QueryCapabilities;
    explain?: LeafCapability | null;
    relationships?: RelationshipCapabilities | null;
}
export interface QueryCapabilities {
    /**
     * Does the connector support aggregate queries
     */
    aggregates?: LeafCapability | null;
    /**
     * Does the connector support queries which use variables
     */
    variables?: LeafCapability | null;
}
/**
 * A unit value to indicate a particular leaf capability is supported. This is an empty struct to allow for future sub-capabilities.
 */
export interface LeafCapability {
}
export interface RelationshipCapabilities {
    /**
     * Does the connector support comparisons that involve related collections (ie. joins)?
     */
    relation_comparisons?: LeafCapability | null;
    /**
     * Does the connector support ordering by an aggregated array relationship?
     */
    order_by_aggregate?: LeafCapability | null;
}
export interface SchemaResponse {
    /**
     * A list of scalar types which will be used as the types of collection columns
     */
    scalar_types: {
        [k: string]: ScalarType;
    };
    /**
     * A list of object types which can be used as the types of arguments, or return types of procedures. Names should not overlap with scalar type names.
     */
    object_types: {
        [k: string]: ObjectType;
    };
    /**
     * Collections which are available for queries
     */
    collections: CollectionInfo[];
    /**
     * Functions (i.e. collections which return a single column and row)
     */
    functions: FunctionInfo[];
    /**
     * Procedures which are available for execution as part of mutations
     */
    procedures: ProcedureInfo[];
}
/**
 * The definition of a scalar type, i.e. types that can be used as the types of columns.
 */
export interface ScalarType {
    /**
     * A map from aggregate function names to their definitions. Result type names must be defined scalar types declared in ScalarTypesCapabilities.
     */
    aggregate_functions: {
        [k: string]: AggregateFunctionDefinition;
    };
    /**
     * A map from comparison operator names to their definitions. Argument type names must be defined scalar types declared in ScalarTypesCapabilities.
     */
    comparison_operators: {
        [k: string]: ComparisonOperatorDefinition;
    };
}
/**
 * The definition of an aggregation function on a scalar type
 */
export interface AggregateFunctionDefinition {
    /**
     * The scalar or object type of the result of this function
     */
    result_type: Type;
}
/**
 * The definition of a comparison operator on a scalar type
 */
export interface ComparisonOperatorDefinition {
    /**
     * The type of the argument to this operator
     */
    argument_type: Type;
}
/**
 * The definition of an object type
 */
export interface ObjectType {
    /**
     * Description of this type
     */
    description?: string | null;
    /**
     * Fields defined on this object type
     */
    fields: {
        [k: string]: ObjectField;
    };
}
/**
 * The definition of an object field
 */
export interface ObjectField {
    /**
     * Description of this field
     */
    description?: string | null;
    /**
     * The type of this field
     */
    type: Type;
}
export interface CollectionInfo {
    /**
     * The name of the collection
     *
     * Note: these names are abstract - there is no requirement that this name correspond to the name of an actual collection in the database.
     */
    name: string;
    /**
     * Description of the collection
     */
    description?: string | null;
    /**
     * Any arguments that this collection requires
     */
    arguments: {
        [k: string]: ArgumentInfo;
    };
    /**
     * The name of the collection's object type
     */
    type: string;
    /**
     * Any uniqueness constraints enforced on this collection
     */
    uniqueness_constraints: {
        [k: string]: UniquenessConstraint;
    };
    /**
     * Any foreign key constraints enforced on this collection
     */
    foreign_keys: {
        [k: string]: ForeignKeyConstraint;
    };
}
export interface ArgumentInfo {
    /**
     * Argument description
     */
    description?: string | null;
    /**
     * The name of the type of this argument
     */
    type: Type;
}
export interface UniquenessConstraint {
    /**
     * A list of columns which this constraint requires to be unique
     */
    unique_columns: string[];
}
export interface ForeignKeyConstraint {
    /**
     * The columns on which you want want to define the foreign key.
     */
    column_mapping: {
        [k: string]: string;
    };
    /**
     * The name of a collection
     */
    foreign_collection: string;
}
export interface FunctionInfo {
    /**
     * The name of the function
     */
    name: string;
    /**
     * Description of the function
     */
    description?: string | null;
    /**
     * Any arguments that this collection requires
     */
    arguments: {
        [k: string]: ArgumentInfo;
    };
    /**
     * The name of the function's result type
     */
    result_type: Type;
}
export interface ProcedureInfo {
    /**
     * The name of the procedure
     */
    name: string;
    /**
     * Column description
     */
    description?: string | null;
    /**
     * Any arguments that this collection requires
     */
    arguments: {
        [k: string]: ArgumentInfo;
    };
    /**
     * The name of the result type
     */
    result_type: Type;
}
/**
 * This is the request body of the query POST endpoint
 */
export interface QueryRequest {
    /**
     * The name of a collection
     */
    collection: string;
    /**
     * The query syntax tree
     */
    query: Query;
    /**
     * Values to be provided to any collection arguments
     */
    arguments: {
        [k: string]: Argument;
    };
    /**
     * Any relationships between collections involved in the query request
     */
    collection_relationships: {
        [k: string]: Relationship;
    };
    /**
     * One set of named variables for each rowset to fetch. Each variable set should be subtituted in turn, and a fresh set of rows returned.
     */
    variables?: {
        [k: string]: unknown;
    }[] | null;
}
export interface Query {
    /**
     * Aggregate fields of the query
     */
    aggregates?: {
        [k: string]: Aggregate;
    } | null;
    /**
     * Fields of the query
     */
    fields?: {
        [k: string]: Field;
    } | null;
    /**
     * Optionally limit to N results
     */
    limit?: number | null;
    /**
     * Optionally offset from the Nth result
     */
    offset?: number | null;
    order_by?: OrderBy | null;
    where?: Expression | null;
}
export interface OrderBy {
    /**
     * The elements to order by, in priority order
     */
    elements: OrderByElement[];
}
export interface OrderByElement {
    order_direction: OrderDirection;
    target: OrderByTarget;
}
export interface PathElement {
    /**
     * The name of the relationship to follow
     */
    relationship: string;
    /**
     * Values to be provided to any collection arguments
     */
    arguments: {
        [k: string]: RelationshipArgument;
    };
    /**
     * A predicate expression to apply to the target collection
     */
    predicate: Expression;
}
export interface Relationship {
    /**
     * A mapping between columns on the source collection to columns on the target collection
     */
    column_mapping: {
        [k: string]: string;
    };
    relationship_type: RelationshipType;
    /**
     * The name of a collection
     */
    target_collection: string;
    /**
     * Values to be provided to any collection arguments
     */
    arguments: {
        [k: string]: RelationshipArgument;
    };
}
export interface RowSet {
    /**
     * The results of the aggregates returned by the query
     */
    aggregates?: {
        [k: string]: unknown;
    } | null;
    /**
     * The rows returned by the query, corresponding to the query's fields
     */
    rows?: {
        [k: string]: RowFieldValue;
    }[] | null;
}
export type RowFieldValue = unknown;
export interface MutationRequest {
    /**
     * The mutation operations to perform
     */
    operations: MutationOperation[];
    /**
     * The relationships between collections involved in the entire mutation request
     */
    collection_relationships: {
        [k: string]: Relationship;
    };
}
export interface MutationResponse {
    /**
     * The results of each mutation operation, in the same order as they were received
     */
    operation_results: MutationOperationResults[];
}
export interface MutationOperationResults {
    /**
     * The number of rows affected by the mutation operation
     */
    affected_rows: number;
    /**
     * The rows affected by the mutation operation
     */
    returning?: {
        [k: string]: RowFieldValue;
    }[] | null;
}
export interface ExplainResponse {
    /**
     * A list of human-readable key-value pairs describing a query execution plan. For example, a connector for a relational database might return the generated SQL and/or the output of the `EXPLAIN` command. An API-based connector might encode a list of statically-known API calls which would be made.
     */
    details: {
        [k: string]: string;
    };
}
export interface ErrorResponse {
    /**
     * A human-readable summary of the error
     */
    message: string;
    /**
     * Any additional structured information about the error
     */
    details: {
        [k: string]: unknown;
    };
}
export interface ValidateResponse {
    schema: SchemaResponse;
    capabilities: CapabilitiesResponse;
    resolved_configuration: string;
}

type ErrorCode = /** Bad Request - The request did not match the data connector's expectation based on this specification. */ 400 | /** Forbidden - The request could not be handled because a permission check failed - for example, a mutation might fail because a check constraint was not met.*/ 403 | /** Conflict - The request could not be handled because it would create a conflicting state for the data source - for example, a mutation might fail because a foreign key constraint was not met.*/ 409 | /** Internal Server Error - The request could not be handled because of an error on the server */ 500 | /** Not Supported - The request could not be handled because it relies on an unsupported capability. Note: this ought to indicate an error on the caller side, since the caller should not generate requests which are incompatible with the indicated capabilities. */ 501;
export declare class ConnectorError extends Error {
    statusCode: ErrorCode;
    details?: ErrorResponse["details"];
    constructor(statusCode: ErrorCode, message: ErrorResponse["message"], details?: ErrorResponse["details"]);
}
/** The request did not match the data connector's expectation based on this specification */
export declare class BadRequest extends ConnectorError {
    constructor(message: ErrorResponse["message"], details?: ErrorResponse["details"]);
}
/** The request could not be handled because a permission check failed - for example, a mutation might fail because a check constraint was not met */
export declare class Forbidden extends ConnectorError {
    constructor(message: ErrorResponse["message"], details?: ErrorResponse["details"]);
}
/** The request could not be handled because it would create a conflicting state for the data source - for example, a mutation might fail because a foreign key constraint was not met */
export declare class Conflict extends ConnectorError {
    constructor(message: ErrorResponse["message"], details?: ErrorResponse["details"]);
}
/** The request could not be handled because of an error on the server */
export declare class InternalServerError extends ConnectorError {
    constructor(message: ErrorResponse["message"], details?: ErrorResponse["details"]);
}
/** The request could not be handled because it relies on an unsupported capability. Note: this ought to indicate an error on the caller side, since the caller should not generate requests which are incompatible with the indicated capabilities */
export declare class NotSupported extends ConnectorError {
    constructor(message: ErrorResponse["message"], details?: ErrorResponse["details"]);
}









import config from "../configuration.json";
import { createClient, Client } from "@libsql/client/web";
// import sqlite3InitModule from '@sqlite.org/sqlite-wasm';
// import { sqlite3Worker1Promiser } from '@sqlite.org/sqlite-wasm';
// declare module '@sqlite.org/sqlite-wasm' {
//     export function sqlite3Worker1Promiser(...args: any): any
// };

// import {sqlite3Wo}
const SqlString = require("sqlstring-sqlite");
const escape_single = (s: any) => SqlString.escape(s);
const escape_double = (s: any) => `"${SqlString.escape(s).slice(1, -1)}"`;

const MAX_32_INT: number = 2147483647;

function get_turso_client(credentials: CredentialSchema): Client {
  return createClient({
    url: credentials.url,
    syncUrl: credentials.syncUrl,
    authToken: credentials.authToken,
  });
}

type ObjectFieldDetails = {
  field_names: string[];
  field_types: { [k: string]: string };
  primary_keys: string[];
  unique_keys: string[];
  nullable_keys: string[];
  foreign_keys: { [k: string]: { table: string; column: string } };
};

type ConfigurationSchema = {
  collection_names: string[];
  object_types: { [k: string]: ObjectType };
  object_fields: { [k: string]: ObjectFieldDetails };
};

type CredentialSchema = {
  url: string;
  syncUrl?: string;
  authToken?: string;
};

type Configuration = {
  credentials: CredentialSchema;
  config?: ConfigurationSchema;
};

type RawConfiguration = Configuration;

type State = {
  client: Client;
};

// TODO: EXISTS, IN

type QueryVariables = {
  [key: string]: any;
};

export type SQLiteQuery = {
  sql: string;
  args: any[];
};

function wrap_data(s: string): string {
  return `
  SELECT
  (
    ${s}
  ) as data
  `;
}

function wrap_rows(s: string): string {
  return `
  SELECT
    JSON_OBJECT('rows', JSON_GROUP_ARRAY(JSON(r)))
  FROM
    (
      ${s}
    )
  `;
}

function build_where(
  expression: Expression,
  args: any[],
  variables: QueryVariables
): string {
  let sql = "";
  switch (expression.type) {
    case "unary_comparison_operator":
      switch (expression.operator) {
        case "is_null":
          sql = `${expression.column.name} IS NULL`;
          break;
        default:
          throw new BadRequest("Unknown Unary Comparison Operator", {
            "Unknown Operator": "This should never happen.",
          });
      }
      break;
    case "binary_comparison_operator":
      switch (expression.value.type) {
        case "scalar":
          args.push(expression.value.value);
          break;
        case "variable":
          if (variables !== null) {
            args.push(variables[expression.value.name]);
          }
          break;
        case "column":
          throw new BadRequest("Not implemented", {});
        default:
          throw new BadRequest("Unknown Binary Comparison Value Type", {});
      }
      switch (expression.operator.type) {
        case "equal":
          sql = `${expression.column.name} = ?`;
          break;
        case "other":
          switch (expression.operator.name) {
            case "_like":
              sql = `${expression.column.name} LIKE ?`;
              break;
            case "_glob":
              sql = `${expression.column.name} GLOB ?`;
              break;
            case "_neq":
              sql = `${expression.column.name} != ?`;
              break;
            case "_gt":
              sql = `${expression.column.name} > ?`;
              break;
            case "_lt":
              sql = `${expression.column.name} < ?`;
              break;
            case "_gte":
              sql = `${expression.column.name} >= ?`;
              break;
            case "_lte":
              sql = `${expression.column.name} <= ?`;
              break;
            default:
              throw new NotSupported("Invalid Expression Operator Name", {});
          }
          break;
        default:
          throw new BadRequest(
            "Binary Comparison Custom Operator not implemented",
            {}
          );
      }
      break;
    case "and":
      if (expression.expressions.length === 0) {
        sql = "1";
      } else {
        const clauses = [];
        for (const expr of expression.expressions) {
          const res = build_where(expr, args, variables);
          clauses.push(res);
        }
        sql = `(${clauses.join(` AND `)})`;
      }
      break;
    case "or":
      if (expression.expressions.length === 0) {
        sql = "1";
      } else {
        const clauses = [];
        for (const expr of expression.expressions) {
          const res = build_where(expr, args, variables);
          clauses.push(res);
        }
        sql = `(${clauses.join(` OR `)})`;
      }
      break;
    case "not":
      const not_result = build_where(expression.expression, args, variables);
      sql = `NOT (${not_result})`;
      break;
    case "binary_array_comparison_operator":
      // IN
      throw new BadRequest("In not implemented", {});
    case "exists":
      // EXISTS
      throw new BadRequest("Not implemented", {});
    default:
      throw new BadRequest("Unknown Expression Type!", {});
  }
  return sql;
}

function build_query(
  config: Configuration,
  query_request: QueryRequest,
  collection: string,
  query: Query,
  path: string[],
  variables: QueryVariables,
  args: any[],
  relationship_key: string | null
): SQLiteQuery {
  let sql = "";
  path.push(collection);
  let collection_alias = path.join("_");
  // let indent = "    ".repeat(path.length - 1);

  let limit_sql = ``;
  let offset_sql = ``;
  let order_by_sql = ``;
  let collect_rows = [];
  let where_conditions = ["WHERE 1"];
  if (query.aggregates) {
    // TODO: Add each aggregate to collectRows
    throw new NotSupported("Aggregates not implemented yet!", {});
  }
  if (query.fields) {
    for (let [field_name, field_value] of Object.entries(query.fields)) {
      collect_rows.push(escape_single(field_name));
      switch (field_value.type) {
        case "column":
          collect_rows.push(escape_double(field_value.column));
          break;
        case "relationship":
          collect_rows.push(
            `(${
              build_query(
                config,
                query_request,
                field_name,
                field_value.query,
                path,
                variables,
                args,
                field_value.relationship
              ).sql
            })`
          );
          path.pop(); // POST-ORDER search stack pop!
          break;
        default:
          throw new InternalServerError("The types tricked me. 😭", {});
      }
    }
  }
  let from_sql = `${escape_double(collection)} as ${escape_double(
    collection_alias
  )}`;
  if (path.length > 1 && relationship_key !== null) {
    let relationship = query_request.collection_relationships[relationship_key];
    let parent_alias = path.slice(0, -1).join("_");
    from_sql = `${escape_double(
      relationship.target_collection
    )} as ${escape_double(collection_alias)}`;
    where_conditions.push(
      ...Object.entries(relationship.column_mapping).map(([from, to]) => {
        return `${escape_double(parent_alias)}.${escape_double(
          from
        )} = ${escape_double(collection_alias)}.${escape_double(to)}`;
      })
    );
  }

  if (query.where) {
    where_conditions.push(`(${build_where(query.where, args, variables)})`);
  }

  if (query.order_by) {
    let order_elems: string[] = [];
    for (let elem of query.order_by.elements) {
      switch (elem.target.type) {
        case "column":
          order_elems.push(
            `${escape_double(elem.target.name)} ${elem.order_direction}`
          );
          break;
        case "single_column_aggregate":
          throw new NotSupported(
            "Single Column Aggregate not supported yet",
            {}
          );
        case "star_count_aggregate":
          throw new NotSupported(
            "Single Column Aggregate not supported yet",
            {}
          );
        default:
          throw new BadRequest("The types lied 😭", {});
      }
    }
    if (order_elems.length > 0) {
      order_by_sql = `ORDER BY ${order_elems.join(" , ")}`;
    }
  }

  if (query.limit) {
    limit_sql = `LIMIT ${escape_single(query.limit)}`;
  }

  if (query.offset) {
    if (!query.limit) {
      limit_sql = `LIMIT ${MAX_32_INT}`;
    }
    offset_sql = `OFFSET ${escape_single(query.offset)}`;
  }

  sql = wrap_rows(`
  SELECT
  JSON_OBJECT(${collect_rows.join(",")}) as r
  FROM ${from_sql}
  ${where_conditions.join(" AND ")}
  ${order_by_sql}
  ${limit_sql}
  ${offset_sql}
  `);

  if (path.length === 1) {
    sql = wrap_data(sql);
    // console.log(format(sql, { language: "sqlite" }));
  }

  return {
    sql,
    args,
  };
}

export async function plan_queries(
  configuration: Configuration,
  query: QueryRequest
): Promise<SQLiteQuery[]> {
  if (!configuration.config) {
    throw new InternalServerError("Connector is not properly configured", {});
  }

  let query_plan: SQLiteQuery[];
  if (query.variables) {
    let promises = query.variables.map((var_set) => {
      let query_variables: QueryVariables = var_set;
      return build_query(
        configuration,
        query,
        query.collection,
        query.query,
        [],
        query_variables,
        [],
        null
      );
    });
    query_plan = await Promise.all(promises);
  } else {
    let promise = build_query(
      configuration,
      query,
      query.collection,
      query.query,
      [],
      {},
      [],
      null
    );
    query_plan = [promise];
  }
  return query_plan;
}

async function perform_query(
  state: State,
  query_plans: SQLiteQuery[]
): Promise<QueryResponse> {
  const client = state.client;
  const results = await client.batch(query_plans, "read");
  let res = results.map((r) => {
    let row_set = JSON.parse(r.rows[0].data as string) as RowSet;
    return row_set;
  });
  return res;
}

export async function do_query(
  configuration: Configuration,
  state: State,
  query: QueryRequest
): Promise<QueryResponse> {
  // console.log(JSON.stringify(configuration), null, 4);
  // console.log(JSON.stringify(query, null, 4));
  let query_plans = await plan_queries(configuration, query);
  return perform_query(state, query_plans);
}

const log = (...args: string[]) => console.log(...args);
const error = (...args: any[]) => console.error(...args);

export async function handle_query_request(query: string) {
//   console.log("BACK TO TS");
//   console.log(query);
//   console.log(createClient);
//   console.log(config);
  try {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok ' + response.statusText);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error('Fetch error:', error));

    const qr = JSON.parse(query) as QueryRequest;
    const conf = config as Configuration;
    console.log(conf.credentials);
    const client = createClient(conf.credentials);
    const state: State = {
      client: client
    };
    console.log("STARTING QUERY");
    const res = await do_query(conf, state, qr);
    console.log(res);
  } catch (e) {
    console.log(e);
  }
  // console.log("HERE");
  // console.log(qr);
  // console.log(conf);
//   console.log(client);
//   sqlite3InitModule({
//     print: log,
//     printErr: error,
//   }).then((sqlite3) => {
//     try {
//       log('Done initializing. Running demo...');
//       const db = new sqlite3.oo1.DB('/mydb.sqlite3', 'ct');
//       console.log("DB");
//       console.log(db);
//     } catch (err) {
//       error(err.name, err.message);
//     }
//   });

    // const promiser = await new Promise((resolve) => {
    //     const _promiser = sqlite3Worker1Promiser({
    //     onready: () => {
    //         resolve(_promiser);
    //     },
    //     });
    // }) as any;
    
    // let response;

    // response = await promiser('config-get', {});
    // log('Running SQLite3 version', response.result.version.libVersion);

    // response = await promiser('open', {
    //   filename: 'file:mydb.sqlite3?vfs=opfs',
    // });
    // const { dbId } = response;
    // log(
    //   'OPFS is available, created persisted database at',
    //   response.result.filename.replace(/^file:(.*?)\?vfs=opfs$/, '$1'),
    // );
    // try {
    //     // const res = await promiser("exec", "SELECT * FROM test;");
    //     // console.log(res);
    // } catch (e) {
    //     console.log(e);
    // }
}
